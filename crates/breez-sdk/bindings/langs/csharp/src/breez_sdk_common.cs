// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.2+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
namespace Breez.Sdk.Spark.Bindings;
using FfiConverterTypecommon_u128 = FfiConverterString;
using common_u128 = String;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            var buffer = _UniFFILib.ffi_breez_sdk_common_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.ffi_breez_sdk_common_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
public class UniffiException: System.Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

public class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

public class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

public class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

public class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

public class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

public class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

public class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: System.Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}

static class FFIObjectUtil {
    public static void DisposeAll(params Object?[] list) {
        foreach (var obj in list) {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
   private static void Dispose(Object? obj) {
         if (obj == null) {
             return;
         }

         if (obj is IDisposable disposable) {
             disposable.Dispose();
             return;
         }

         var objType = obj.GetType();
         var typeCode = Type.GetTypeCode(objType);
         if (typeCode != TypeCode.Object) {
             return;
         }

         var genericArguments = objType.GetGenericArguments();
         if (genericArguments.Length == 0) {
             return;
         }

         if (obj is System.Collections.IDictionary objDictionary) {
            //This extra code tests to not call "Dispose" for a Dictionary<something, double>()
            //for all keys as "double" and alike doesn't support interface "IDisposable"
             var valuesType = objType.GetGenericArguments()[1];
             var elementValuesTypeCode = Type.GetTypeCode(valuesType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in objDictionary.Values) {
                 Dispose(value);
             }
         }
         else if (obj is System.Collections.IEnumerable listValues) {
            //This extra code tests to not call "Dispose" for a List<int>()
            //for all keys as "int" and alike doesn't support interface "IDisposable"
             var valuesType = objType.GetGenericArguments()[0];
             var elementValuesTypeCode = Type.GetTypeCode(valuesType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in listValues) {
                 Dispose(value);
             }
         }
     }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: System.Exception {
    public StreamUnderflowException() {
    }
}

static class BigEndianStreamExtensions
{
    public static void WriteInt32(this Stream stream, int value, int bytesToWrite = 4)
    {
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
        byte[] buffer = new byte[bytesToWrite];
#endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static void WriteInt64(this Stream stream, long value)
    {
        int bytesToWrite = 8;
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToWrite];
 #else
         byte[] buffer = new byte[bytesToWrite];
 #endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static uint ReadUint32(this Stream stream, int bytesToRead = 4) {
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        uint result = 0;
        uint digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static ulong ReadUInt64(this Stream stream) {
        int bytesToRead = 8;
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        ulong result = 0;
        ulong digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static void CheckRemaining(this Stream stream, int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] buffer) {
#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public void WriteByte(byte value) => stream.WriteInt32(value, bytesToWrite: 1);
    public void WriteSByte(sbyte value) => stream.WriteInt32(value, bytesToWrite: 1);

    public void WriteUShort(ushort value) => stream.WriteInt32(value, bytesToWrite: 2);
    public void WriteShort(short value) => stream.WriteInt32(value, bytesToWrite: 2);

    public void WriteUInt(uint value) => stream.WriteInt32((int)value);
    public void WriteInt(int value) => stream.WriteInt32(value);

    public void WriteULong(ulong value) => stream.WriteInt64((long)value);
    public void WriteLong(long value) => stream.WriteInt64(value);

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }
    public void WriteDouble(double value) => stream.WriteInt64(BitConverter.DoubleToInt64Bits(value));

    public byte[] ReadBytes(int length) {
        stream.CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() => (byte)stream.ReadUint32(bytesToRead: 1);
    public ushort ReadUShort() => (ushort)stream.ReadUint32(bytesToRead: 2);
    public uint ReadUInt() => (uint)stream.ReadUint32(bytesToRead: 4);
    public ulong ReadULong() => stream.ReadUInt64();

    public sbyte ReadSByte() => (sbyte)ReadByte();
    public short ReadShort() => (short)ReadUShort();
    public int ReadInt() => (int)ReadUInt();

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() => (long)ReadULong();
    public double ReadDouble() => BitConverter.Int64BitsToDouble(ReadLong());
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib {
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(
        ulong @data,sbyte @pollResult
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(
        ulong @handle
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(
        ulong @handle
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructPointer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructVoid @result
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFiatServiceMethod0(
        ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFiatServiceMethod1(
        ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRestClientMethod0(
        ulong @uniffiHandle,RustBuffer @url,RustBuffer @headers,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRestClientMethod1(
        ulong @uniffiHandle,RustBuffer @url,RustBuffer @headers,RustBuffer @body,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceRestClientMethod2(
        ulong @uniffiHandle,RustBuffer @url,RustBuffer @headers,RustBuffer @body,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod0(
        ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod1(
        ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod2(
        ulong @uniffiHandle,uint @limit,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod3(
        ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod4(
        ulong @uniffiHandle,RustBuffer @records,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod5(
        ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod6(
        ulong @uniffiHandle,ulong @revision,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod7(
        ulong @uniffiHandle,uint @limit,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod8(
        ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceSyncStorageMethod9(
        ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceFiatService
    {
        public IntPtr @fetchFiatCurrencies;
        public IntPtr @fetchFiatRates;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceRestClient
    {
        public IntPtr @getRequest;
        public IntPtr @postRequest;
        public IntPtr @deleteRequest;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceSyncStorage
    {
        public IntPtr @addOutgoingChange;
        public IntPtr @completeOutgoingSync;
        public IntPtr @getPendingOutgoingChanges;
        public IntPtr @getLastRevision;
        public IntPtr @insertIncomingRecords;
        public IntPtr @deleteIncomingRecord;
        public IntPtr @rebasePendingOutgoingRecords;
        public IntPtr @getIncomingRecords;
        public IntPtr @getLatestOutgoingChange;
        public IntPtr @updateRecordFromIncoming;
        public IntPtr @uniffiFree;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        UniffiCallbackInterfaceFiatService.Register();
        UniffiCallbackInterfaceRestClient.Register();
        UniffiCallbackInterfaceSyncStorage.Register();
        }

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_clone_fiatservice(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_common_fn_free_fiatservice(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_common_fn_init_callback_vtable_fiatservice(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfaceFiatService*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_fiatservice_fetch_fiat_currencies(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_fiatservice_fetch_fiat_rates(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_clone_restclient(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_common_fn_free_restclient(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_common_fn_init_callback_vtable_restclient(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfaceRestClient*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_restclient_get_request(IntPtr @ptr,RustBuffer @url,RustBuffer @headers
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_restclient_post_request(IntPtr @ptr,RustBuffer @url,RustBuffer @headers,RustBuffer @body
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_restclient_delete_request(IntPtr @ptr,RustBuffer @url,RustBuffer @headers,RustBuffer @body
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_clone_syncstorage(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_common_fn_free_syncstorage(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_common_fn_init_callback_vtable_syncstorage(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfaceSyncStorage*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_add_outgoing_change(IntPtr @ptr,RustBuffer @record
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_complete_outgoing_sync(IntPtr @ptr,RustBuffer @record
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_get_pending_outgoing_changes(IntPtr @ptr,uint @limit
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_get_last_revision(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_insert_incoming_records(IntPtr @ptr,RustBuffer @records
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_delete_incoming_record(IntPtr @ptr,RustBuffer @record
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_rebase_pending_outgoing_records(IntPtr @ptr,ulong @revision
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_get_incoming_records(IntPtr @ptr,uint @limit
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_get_latest_outgoing_change(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_common_fn_method_syncstorage_update_record_from_incoming(IntPtr @ptr,RustBuffer @record
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_common_rustbuffer_alloc(ulong @size,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_common_rustbuffer_from_bytes(ForeignBytes @bytes,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rustbuffer_free(RustBuffer @buf,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_common_rustbuffer_reserve(RustBuffer @buf,ulong @additional,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_u8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_breez_sdk_common_rust_future_complete_u8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_i8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_breez_sdk_common_rust_future_complete_i8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_u16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_breez_sdk_common_rust_future_complete_u16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_i16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_breez_sdk_common_rust_future_complete_i16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_u32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_breez_sdk_common_rust_future_complete_u32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_i32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_breez_sdk_common_rust_future_complete_i32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_u64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_breez_sdk_common_rust_future_complete_u64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_i64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_breez_sdk_common_rust_future_complete_i64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_f32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_breez_sdk_common_rust_future_complete_f32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_f64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_breez_sdk_common_rust_future_complete_f64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_pointer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_breez_sdk_common_rust_future_complete_pointer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_common_rust_future_complete_rust_buffer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_poll_void(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_free_void(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_common_rust_future_complete_void(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_fiatservice_fetch_fiat_currencies(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_fiatservice_fetch_fiat_rates(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_restclient_get_request(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_restclient_post_request(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_restclient_delete_request(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_add_outgoing_change(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_complete_outgoing_sync(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_get_pending_outgoing_changes(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_get_last_revision(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_insert_incoming_records(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_delete_incoming_record(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_rebase_pending_outgoing_records(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_get_incoming_records(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_get_latest_outgoing_change(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_common_checksum_method_syncstorage_update_record_from_incoming(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_breez_sdk_common_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_breez_sdk_common_uniffi_contract_version();
        if (26 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_fiatservice_fetch_fiat_currencies();
            if (checksum != 63089) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_fiatservice_fetch_fiat_currencies` checksum `63089`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_fiatservice_fetch_fiat_rates();
            if (checksum != 48636) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_fiatservice_fetch_fiat_rates` checksum `48636`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_restclient_get_request();
            if (checksum != 1702) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_restclient_get_request` checksum `1702`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_restclient_post_request();
            if (checksum != 38998) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_restclient_post_request` checksum `38998`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_restclient_delete_request();
            if (checksum != 26893) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_restclient_delete_request` checksum `26893`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_add_outgoing_change();
            if (checksum != 18302) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_add_outgoing_change` checksum `18302`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_complete_outgoing_sync();
            if (checksum != 1608) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_complete_outgoing_sync` checksum `1608`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_get_pending_outgoing_changes();
            if (checksum != 43350) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_get_pending_outgoing_changes` checksum `43350`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_get_last_revision();
            if (checksum != 11560) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_get_last_revision` checksum `11560`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_insert_incoming_records();
            if (checksum != 65359) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_insert_incoming_records` checksum `65359`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_delete_incoming_record();
            if (checksum != 6222) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_delete_incoming_record` checksum `6222`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_rebase_pending_outgoing_records();
            if (checksum != 49312) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_rebase_pending_outgoing_records` checksum `49312`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_get_incoming_records();
            if (checksum != 39529) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_get_incoming_records` checksum `39529`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_get_latest_outgoing_change();
            if (checksum != 13979) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_get_latest_outgoing_change` checksum `13979`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_common_checksum_method_syncstorage_update_record_from_incoming();
            if (checksum != 63333) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_common_checksum_method_syncstorage_update_record_from_incoming` checksum `63333`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt16: FfiConverter<ushort, ushort> {
    public static FfiConverterUInt16 INSTANCE = new FfiConverterUInt16();

    public override ushort Lift(ushort value) {
        return value;
    }

    public override ushort Read(BigEndianStream stream) {
        return stream.ReadUShort();
    }

    public override ushort Lower(ushort value) {
        return value;
    }

    public override int AllocationSize(ushort value) {
        return 2;
    }

    public override void Write(ushort value, BigEndianStream stream) {
        stream.WriteUShort(value);
    }
}



class FfiConverterUInt32: FfiConverter<uint, uint> {
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value) {
        return value;
    }

    public override uint Read(BigEndianStream stream) {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value) {
        return value;
    }

    public override int AllocationSize(uint value) {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream) {
        stream.WriteUInt(value);
    }
}



class FfiConverterUInt64: FfiConverter<ulong, ulong> {
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value) {
        return value;
    }

    public override ulong Read(BigEndianStream stream) {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value) {
        return value;
    }

    public override int AllocationSize(ulong value) {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream) {
        stream.WriteULong(value);
    }
}



class FfiConverterDouble: FfiConverter<double, double> {
    public static FfiConverterDouble INSTANCE = new FfiConverterDouble();

    public override double Lift(double value) {
        return value;
    }

    public override double Read(BigEndianStream stream) {
        return stream.ReadDouble();
    }

    public override double Lower(double value) {
        return value;
    }

    public override int AllocationSize(double value) {
        return 8;
    }

    public override void Write(double value, BigEndianStream stream) {
        stream.WriteDouble(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}



/// <summary>
/// Trait covering fiat-related functionality
/// </summary>
public interface FiatService {
    /// <summary>
    /// List all supported fiat currencies for which there is a known exchange rate.
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    Task<List<FiatCurrency>> FetchFiatCurrencies();
    /// <summary>
    /// Get the live rates from the server.
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    Task<List<Rate>> FetchFiatRates();
}
/// <summary>
/// Trait covering fiat-related functionality
/// </summary>
public class FiatServiceImpl : FiatService, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public FiatServiceImpl(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~FiatServiceImpl() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_common_fn_free_fiatservice(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_clone_fiatservice(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// List all supported fiat currencies for which there is a known exchange rate.
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    public async Task<List<FiatCurrency>> FetchFiatCurrencies() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_fiatservice_fetch_fiat_currencies(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeFiatCurrency.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeServiceConnectivityError.INSTANCE
    );
    }
    
    /// <summary>
    /// Get the live rates from the server.
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    public async Task<List<Rate>> FetchFiatRates() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_fiatservice_fetch_fiat_rates(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeRate.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeServiceConnectivityError.INSTANCE
    );
    }
    

    
}
class UniffiCallbackInterfaceFiatService {
    static void FetchFiatCurrencies(ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeFiatService.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.FetchFiatCurrencies()
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterSequenceTypeFiatCurrency.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ServiceConnectivityException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeServiceConnectivityError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void FetchFiatRates(ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeFiatService.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.FetchFiatRates()
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterSequenceTypeRate.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ServiceConnectivityException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeServiceConnectivityError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeFiatService.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceFiatServiceMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceFiatServiceMethod0(FetchFiatCurrencies);
    static _UniFFILib.UniffiCallbackInterfaceFiatServiceMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceFiatServiceMethod1(FetchFiatRates);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfaceFiatService _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceFiatService {
            @fetchFiatCurrencies = Marshal.GetFunctionPointerForDelegate(_m0),
            @fetchFiatRates = Marshal.GetFunctionPointerForDelegate(_m1),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_common_fn_init_callback_vtable_fiatservice(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}

class ConcurrentHandleMap<T> where T: notnull {
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj) {
        lock (lock_) {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result) {
        lock (lock_) {
            #pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
            #pragma warning restore 8601
        }
    }

    public T Get(ulong handle) {
        if (TryGet(handle, out var result)) {
            return result;
        } else {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle) {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result) {
        lock (lock_) {
            // Possible null reference assignment
            #pragma warning disable 8601
            if (map.TryGetValue(handle, out result)) {
            #pragma warning restore 8601
                map.Remove(handle);
                return true;
            } else {
                return false;
            }
        }
    }
}
static class UniffiCallbackResponseStatus {
    public static sbyte SUCCESS = 0;
    public static sbyte ERROR = 1;
    public static sbyte UNEXPECTED_ERROR = 2;
}

class FfiConverterTypeFiatService: FfiConverter<FiatService, IntPtr> {
    public ConcurrentHandleMap<FiatService> handleMap = new ConcurrentHandleMap<FiatService>();
    
    public static FfiConverterTypeFiatService INSTANCE = new FfiConverterTypeFiatService();


    public override IntPtr Lower(FiatService value) {
        return (IntPtr)handleMap.Insert(value);
    }

    public override FiatService Lift(IntPtr value) {
        return new FiatServiceImpl(value);
    }

    public override FiatService Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(FiatService value) {
        return 8;
    }

    public override void Write(FiatService value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



public interface RestClient {
    /// <summary>
    /// Makes a GET request and logs on DEBUG.
    /// ### Arguments
    /// - `url`: the URL on which GET will be called
    /// - `headers`: optional headers that will be set on the request
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    Task<RestResponse> GetRequest(string @url, Dictionary<string, string>? @headers);
    /// <summary>
    /// Makes a POST request, and logs on DEBUG.
    /// ### Arguments
    /// - `url`: the URL on which POST will be called
    /// - `headers`: the optional POST headers
    /// - `body`: the optional POST body
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    Task<RestResponse> PostRequest(string @url, Dictionary<string, string>? @headers, string? @body);
    /// <summary>
    /// Makes a DELETE request, and logs on DEBUG.
    /// ### Arguments
    /// - `url`: the URL on which DELETE will be called
    /// - `headers`: the optional DELETE headers
    /// - `body`: the optional DELETE body
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    Task<RestResponse> DeleteRequest(string @url, Dictionary<string, string>? @headers, string? @body);
}
public class RestClientImpl : RestClient, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public RestClientImpl(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~RestClientImpl() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_common_fn_free_restclient(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_clone_restclient(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Makes a GET request and logs on DEBUG.
    /// ### Arguments
    /// - `url`: the URL on which GET will be called
    /// - `headers`: optional headers that will be set on the request
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    public async Task<RestResponse> GetRequest(string @url, Dictionary<string, string>? @headers) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_restclient_get_request(thisPtr, FfiConverterString.INSTANCE.Lower(@url), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@headers));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeRestResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeServiceConnectivityError.INSTANCE
    );
    }
    
    /// <summary>
    /// Makes a POST request, and logs on DEBUG.
    /// ### Arguments
    /// - `url`: the URL on which POST will be called
    /// - `headers`: the optional POST headers
    /// - `body`: the optional POST body
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    public async Task<RestResponse> PostRequest(string @url, Dictionary<string, string>? @headers, string? @body) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_restclient_post_request(thisPtr, FfiConverterString.INSTANCE.Lower(@url), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@headers), FfiConverterOptionalString.INSTANCE.Lower(@body));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeRestResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeServiceConnectivityError.INSTANCE
    );
    }
    
    /// <summary>
    /// Makes a DELETE request, and logs on DEBUG.
    /// ### Arguments
    /// - `url`: the URL on which DELETE will be called
    /// - `headers`: the optional DELETE headers
    /// - `body`: the optional DELETE body
    /// </summary>
    /// <exception cref="ServiceConnectivityException"></exception>
    public async Task<RestResponse> DeleteRequest(string @url, Dictionary<string, string>? @headers, string? @body) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_restclient_delete_request(thisPtr, FfiConverterString.INSTANCE.Lower(@url), FfiConverterOptionalDictionaryStringString.INSTANCE.Lower(@headers), FfiConverterOptionalString.INSTANCE.Lower(@body));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeRestResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeServiceConnectivityError.INSTANCE
    );
    }
    

    
}
class UniffiCallbackInterfaceRestClient {
    static void GetRequest(ulong @uniffiHandle,RustBuffer @url,RustBuffer @headers,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRestClient.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetRequest(
                    FfiConverterString.INSTANCE.Lift(@url), 
                    FfiConverterOptionalDictionaryStringString.INSTANCE.Lift(@headers))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterTypeRestResponse.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ServiceConnectivityException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeServiceConnectivityError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void PostRequest(ulong @uniffiHandle,RustBuffer @url,RustBuffer @headers,RustBuffer @body,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRestClient.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.PostRequest(
                    FfiConverterString.INSTANCE.Lift(@url), 
                    FfiConverterOptionalDictionaryStringString.INSTANCE.Lift(@headers), 
                    FfiConverterOptionalString.INSTANCE.Lift(@body))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterTypeRestResponse.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ServiceConnectivityException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeServiceConnectivityError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void DeleteRequest(ulong @uniffiHandle,RustBuffer @url,RustBuffer @headers,RustBuffer @body,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeRestClient.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.DeleteRequest(
                    FfiConverterString.INSTANCE.Lift(@url), 
                    FfiConverterOptionalDictionaryStringString.INSTANCE.Lift(@headers), 
                    FfiConverterOptionalString.INSTANCE.Lift(@body))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterTypeRestResponse.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ServiceConnectivityException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeServiceConnectivityError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeRestClient.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceRestClientMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceRestClientMethod0(GetRequest);
    static _UniFFILib.UniffiCallbackInterfaceRestClientMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceRestClientMethod1(PostRequest);
    static _UniFFILib.UniffiCallbackInterfaceRestClientMethod2 _m2 = new _UniFFILib.UniffiCallbackInterfaceRestClientMethod2(DeleteRequest);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfaceRestClient _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceRestClient {
            @getRequest = Marshal.GetFunctionPointerForDelegate(_m0),
            @postRequest = Marshal.GetFunctionPointerForDelegate(_m1),
            @deleteRequest = Marshal.GetFunctionPointerForDelegate(_m2),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_common_fn_init_callback_vtable_restclient(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}




class FfiConverterTypeRestClient: FfiConverter<RestClient, IntPtr> {
    public ConcurrentHandleMap<RestClient> handleMap = new ConcurrentHandleMap<RestClient>();
    
    public static FfiConverterTypeRestClient INSTANCE = new FfiConverterTypeRestClient();


    public override IntPtr Lower(RestClient value) {
        return (IntPtr)handleMap.Insert(value);
    }

    public override RestClient Lift(IntPtr value) {
        return new RestClientImpl(value);
    }

    public override RestClient Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(RestClient value) {
        return 8;
    }

    public override void Write(RestClient value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



public interface SyncStorage {
    /// <exception cref="SyncStorageException"></exception>
    Task<ulong> AddOutgoingChange(UnversionedRecordChange @record);
    /// <exception cref="SyncStorageException"></exception>
    Task CompleteOutgoingSync(Record @record);
    /// <exception cref="SyncStorageException"></exception>
    Task<List<OutgoingChange>> GetPendingOutgoingChanges(uint @limit);
    /// <summary>
    /// Get the revision number of the last synchronized record
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    Task<ulong> GetLastRevision();
    /// <summary>
    /// Insert incoming records from remote sync
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    Task InsertIncomingRecords(List<Record> @records);
    /// <summary>
    /// Delete an incoming record after it has been processed
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    Task DeleteIncomingRecord(Record @record);
    /// <summary>
    /// Update revision numbers of pending outgoing records to be higher than the given revision
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    Task RebasePendingOutgoingRecords(ulong @revision);
    /// <summary>
    /// Get incoming records that need to be processed, up to the specified limit
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    Task<List<IncomingChange>> GetIncomingRecords(uint @limit);
    /// <summary>
    /// Get the latest outgoing record if any exists
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    Task<OutgoingChange?> GetLatestOutgoingChange();
    /// <summary>
    /// Update the sync state record from an incoming record
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    Task UpdateRecordFromIncoming(Record @record);
}
public class SyncStorageImpl : SyncStorage, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SyncStorageImpl(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~SyncStorageImpl() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_common_fn_free_syncstorage(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_clone_syncstorage(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <exception cref="SyncStorageException"></exception>
    public async Task<ulong> AddOutgoingChange(UnversionedRecordChange @record) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_add_outgoing_change(thisPtr, FfiConverterTypeUnversionedRecordChange.INSTANCE.Lower(@record));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_u64(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_u64(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_u64(future),
        // Lift
        (result) => FfiConverterUInt64.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <exception cref="SyncStorageException"></exception>
    public async Task CompleteOutgoingSync(Record @record) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_complete_outgoing_sync(thisPtr, FfiConverterTypeRecord.INSTANCE.Lower(@record));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_common_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_void(future),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <exception cref="SyncStorageException"></exception>
    public async Task<List<OutgoingChange>> GetPendingOutgoingChanges(uint @limit) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_get_pending_outgoing_changes(thisPtr, FfiConverterUInt32.INSTANCE.Lower(@limit));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeOutgoingChange.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Get the revision number of the last synchronized record
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    public async Task<ulong> GetLastRevision() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_get_last_revision(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_u64(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_u64(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_u64(future),
        // Lift
        (result) => FfiConverterUInt64.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Insert incoming records from remote sync
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    public async Task InsertIncomingRecords(List<Record> @records) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_insert_incoming_records(thisPtr, FfiConverterSequenceTypeRecord.INSTANCE.Lower(@records));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_common_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_void(future),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Delete an incoming record after it has been processed
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    public async Task DeleteIncomingRecord(Record @record) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_delete_incoming_record(thisPtr, FfiConverterTypeRecord.INSTANCE.Lower(@record));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_common_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_void(future),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Update revision numbers of pending outgoing records to be higher than the given revision
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    public async Task RebasePendingOutgoingRecords(ulong @revision) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_rebase_pending_outgoing_records(thisPtr, FfiConverterUInt64.INSTANCE.Lower(@revision));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_common_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_void(future),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Get incoming records that need to be processed, up to the specified limit
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    public async Task<List<IncomingChange>> GetIncomingRecords(uint @limit) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_get_incoming_records(thisPtr, FfiConverterUInt32.INSTANCE.Lower(@limit));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeIncomingChange.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Get the latest outgoing record if any exists
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    public async Task<OutgoingChange?> GetLatestOutgoingChange() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_get_latest_outgoing_change(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_common_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterOptionalTypeOutgoingChange.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Update the sync state record from an incoming record
    /// </summary>
    /// <exception cref="SyncStorageException"></exception>
    public async Task UpdateRecordFromIncoming(Record @record) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_common_fn_method_syncstorage_update_record_from_incoming(thisPtr, FfiConverterTypeRecord.INSTANCE.Lower(@record));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_common_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_common_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_common_rust_future_free_void(future),
        // Error
        FfiConverterTypeSyncStorageError.INSTANCE
    );
    }
    

    
}
class UniffiCallbackInterfaceSyncStorage {
    static void AddOutgoingChange(ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructU64();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.AddOutgoingChange(
                    FfiConverterTypeUnversionedRecordChange.INSTANCE.Lift(@record))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterUInt64.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteU64>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void CompleteOutgoingSync(ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.CompleteOutgoingSync(
                    FfiConverterTypeRecord.INSTANCE.Lift(@record))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetPendingOutgoingChanges(ulong @uniffiHandle,uint @limit,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetPendingOutgoingChanges(
                    FfiConverterUInt32.INSTANCE.Lift(@limit))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterSequenceTypeOutgoingChange.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetLastRevision(ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructU64();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetLastRevision()
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterUInt64.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteU64>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void InsertIncomingRecords(ulong @uniffiHandle,RustBuffer @records,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.InsertIncomingRecords(
                    FfiConverterSequenceTypeRecord.INSTANCE.Lift(@records))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void DeleteIncomingRecord(ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.DeleteIncomingRecord(
                    FfiConverterTypeRecord.INSTANCE.Lift(@record))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void RebasePendingOutgoingRecords(ulong @uniffiHandle,ulong @revision,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.RebasePendingOutgoingRecords(
                    FfiConverterUInt64.INSTANCE.Lift(@revision))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetIncomingRecords(ulong @uniffiHandle,uint @limit,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetIncomingRecords(
                    FfiConverterUInt32.INSTANCE.Lift(@limit))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterSequenceTypeIncomingChange.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetLatestOutgoingChange(ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetLatestOutgoingChange()
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterOptionalTypeOutgoingChange.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void UpdateRecordFromIncoming(ulong @uniffiHandle,RustBuffer @record,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeSyncStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.UpdateRecordFromIncoming(
                    FfiConverterTypeRecord.INSTANCE.Lift(@record))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (SyncStorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeSyncStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeSyncStorage.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod0(AddOutgoingChange);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod1(CompleteOutgoingSync);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod2 _m2 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod2(GetPendingOutgoingChanges);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod3 _m3 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod3(GetLastRevision);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod4 _m4 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod4(InsertIncomingRecords);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod5 _m5 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod5(DeleteIncomingRecord);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod6 _m6 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod6(RebasePendingOutgoingRecords);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod7 _m7 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod7(GetIncomingRecords);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod8 _m8 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod8(GetLatestOutgoingChange);
    static _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod9 _m9 = new _UniFFILib.UniffiCallbackInterfaceSyncStorageMethod9(UpdateRecordFromIncoming);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfaceSyncStorage _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceSyncStorage {
            @addOutgoingChange = Marshal.GetFunctionPointerForDelegate(_m0),
            @completeOutgoingSync = Marshal.GetFunctionPointerForDelegate(_m1),
            @getPendingOutgoingChanges = Marshal.GetFunctionPointerForDelegate(_m2),
            @getLastRevision = Marshal.GetFunctionPointerForDelegate(_m3),
            @insertIncomingRecords = Marshal.GetFunctionPointerForDelegate(_m4),
            @deleteIncomingRecord = Marshal.GetFunctionPointerForDelegate(_m5),
            @rebasePendingOutgoingRecords = Marshal.GetFunctionPointerForDelegate(_m6),
            @getIncomingRecords = Marshal.GetFunctionPointerForDelegate(_m7),
            @getLatestOutgoingChange = Marshal.GetFunctionPointerForDelegate(_m8),
            @updateRecordFromIncoming = Marshal.GetFunctionPointerForDelegate(_m9),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_common_fn_init_callback_vtable_syncstorage(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}




class FfiConverterTypeSyncStorage: FfiConverter<SyncStorage, IntPtr> {
    public ConcurrentHandleMap<SyncStorage> handleMap = new ConcurrentHandleMap<SyncStorage>();
    
    public static FfiConverterTypeSyncStorage INSTANCE = new FfiConverterTypeSyncStorage();


    public override IntPtr Lower(SyncStorage value) {
        return (IntPtr)handleMap.Insert(value);
    }

    public override SyncStorage Lift(IntPtr value) {
        return new SyncStorageImpl(value);
    }

    public override SyncStorage Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SyncStorage value) {
        return 8;
    }

    public override void Write(SyncStorage value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Payload of the AES success action, as received from the LNURL endpoint
///
/// See [`AesSuccessActionDataDecrypted`] for a similar wrapper containing the decrypted payload
/// </summary>
/// <param name="description">
/// Contents description, up to 144 characters
/// </param>
/// <param name="ciphertext">
/// Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
/// </param>
/// <param name="iv">
/// Base64, initialization vector, exactly 24 characters
/// </param>
public record AesSuccessActionData (
    /// <summary>
    /// Contents description, up to 144 characters
    /// </summary>
    string @description, 
    /// <summary>
    /// Base64, AES-encrypted data where encryption key is payment preimage, up to 4kb of characters
    /// </summary>
    string @ciphertext, 
    /// <summary>
    /// Base64, initialization vector, exactly 24 characters
    /// </summary>
    string @iv
) {
}

class FfiConverterTypeAesSuccessActionData: FfiConverterRustBuffer<AesSuccessActionData> {
    public static FfiConverterTypeAesSuccessActionData INSTANCE = new FfiConverterTypeAesSuccessActionData();

    public override AesSuccessActionData Read(BigEndianStream stream) {
        return new AesSuccessActionData(
            @description: FfiConverterString.INSTANCE.Read(stream),
            @ciphertext: FfiConverterString.INSTANCE.Read(stream),
            @iv: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AesSuccessActionData value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterString.INSTANCE.AllocationSize(value.@ciphertext)
            + FfiConverterString.INSTANCE.AllocationSize(value.@iv);
    }

    public override void Write(AesSuccessActionData value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@description, stream);
            FfiConverterString.INSTANCE.Write(value.@ciphertext, stream);
            FfiConverterString.INSTANCE.Write(value.@iv, stream);
    }
}



/// <summary>
/// Wrapper for the decrypted [`AesSuccessActionData`] payload
/// </summary>
/// <param name="description">
/// Contents description, up to 144 characters
/// </param>
/// <param name="plaintext">
/// Decrypted content
/// </param>
public record AesSuccessActionDataDecrypted (
    /// <summary>
    /// Contents description, up to 144 characters
    /// </summary>
    string @description, 
    /// <summary>
    /// Decrypted content
    /// </summary>
    string @plaintext
) {
}

class FfiConverterTypeAesSuccessActionDataDecrypted: FfiConverterRustBuffer<AesSuccessActionDataDecrypted> {
    public static FfiConverterTypeAesSuccessActionDataDecrypted INSTANCE = new FfiConverterTypeAesSuccessActionDataDecrypted();

    public override AesSuccessActionDataDecrypted Read(BigEndianStream stream) {
        return new AesSuccessActionDataDecrypted(
            @description: FfiConverterString.INSTANCE.Read(stream),
            @plaintext: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(AesSuccessActionDataDecrypted value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterString.INSTANCE.AllocationSize(value.@plaintext);
    }

    public override void Write(AesSuccessActionDataDecrypted value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@description, stream);
            FfiConverterString.INSTANCE.Write(value.@plaintext, stream);
    }
}



public record Bip21Details (
    ulong? @amountSat, 
    string? @assetId, 
    string @uri, 
    List<Bip21Extra> @extras, 
    string? @label, 
    string? @message, 
    List<InputType> @paymentMethods
) {
}

class FfiConverterTypeBip21Details: FfiConverterRustBuffer<Bip21Details> {
    public static FfiConverterTypeBip21Details INSTANCE = new FfiConverterTypeBip21Details();

    public override Bip21Details Read(BigEndianStream stream) {
        return new Bip21Details(
            @amountSat: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @assetId: FfiConverterOptionalString.INSTANCE.Read(stream),
            @uri: FfiConverterString.INSTANCE.Read(stream),
            @extras: FfiConverterSequenceTypeBip21Extra.INSTANCE.Read(stream),
            @label: FfiConverterOptionalString.INSTANCE.Read(stream),
            @message: FfiConverterOptionalString.INSTANCE.Read(stream),
            @paymentMethods: FfiConverterSequenceTypeInputType.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bip21Details value) {
        return 0
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@amountSat)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@assetId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@uri)
            + FfiConverterSequenceTypeBip21Extra.INSTANCE.AllocationSize(value.@extras)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@label)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@message)
            + FfiConverterSequenceTypeInputType.INSTANCE.AllocationSize(value.@paymentMethods);
    }

    public override void Write(Bip21Details value, BigEndianStream stream) {
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@amountSat, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@assetId, stream);
            FfiConverterString.INSTANCE.Write(value.@uri, stream);
            FfiConverterSequenceTypeBip21Extra.INSTANCE.Write(value.@extras, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@label, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@message, stream);
            FfiConverterSequenceTypeInputType.INSTANCE.Write(value.@paymentMethods, stream);
    }
}



public record Bip21Extra (
    string @key, 
    string @value
) {
}

class FfiConverterTypeBip21Extra: FfiConverterRustBuffer<Bip21Extra> {
    public static FfiConverterTypeBip21Extra INSTANCE = new FfiConverterTypeBip21Extra();

    public override Bip21Extra Read(BigEndianStream stream) {
        return new Bip21Extra(
            @key: FfiConverterString.INSTANCE.Read(stream),
            @value: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bip21Extra value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@key)
            + FfiConverterString.INSTANCE.AllocationSize(value.@value);
    }

    public override void Write(Bip21Extra value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@key, stream);
            FfiConverterString.INSTANCE.Write(value.@value, stream);
    }
}



public record BitcoinAddressDetails (
    string @address, 
    BitcoinNetwork @network, 
    PaymentRequestSource @source
) {
}

class FfiConverterTypeBitcoinAddressDetails: FfiConverterRustBuffer<BitcoinAddressDetails> {
    public static FfiConverterTypeBitcoinAddressDetails INSTANCE = new FfiConverterTypeBitcoinAddressDetails();

    public override BitcoinAddressDetails Read(BigEndianStream stream) {
        return new BitcoinAddressDetails(
            @address: FfiConverterString.INSTANCE.Read(stream),
            @network: FfiConverterTypeBitcoinNetwork.INSTANCE.Read(stream),
            @source: FfiConverterTypePaymentRequestSource.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(BitcoinAddressDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@address)
            + FfiConverterTypeBitcoinNetwork.INSTANCE.AllocationSize(value.@network)
            + FfiConverterTypePaymentRequestSource.INSTANCE.AllocationSize(value.@source);
    }

    public override void Write(BitcoinAddressDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@address, stream);
            FfiConverterTypeBitcoinNetwork.INSTANCE.Write(value.@network, stream);
            FfiConverterTypePaymentRequestSource.INSTANCE.Write(value.@source, stream);
    }
}



public record Bolt11Invoice (
    string @bolt11, 
    PaymentRequestSource @source
) {
}

class FfiConverterTypeBolt11Invoice: FfiConverterRustBuffer<Bolt11Invoice> {
    public static FfiConverterTypeBolt11Invoice INSTANCE = new FfiConverterTypeBolt11Invoice();

    public override Bolt11Invoice Read(BigEndianStream stream) {
        return new Bolt11Invoice(
            @bolt11: FfiConverterString.INSTANCE.Read(stream),
            @source: FfiConverterTypePaymentRequestSource.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt11Invoice value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@bolt11)
            + FfiConverterTypePaymentRequestSource.INSTANCE.AllocationSize(value.@source);
    }

    public override void Write(Bolt11Invoice value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@bolt11, stream);
            FfiConverterTypePaymentRequestSource.INSTANCE.Write(value.@source, stream);
    }
}



public record Bolt11InvoiceDetails (
    ulong? @amountMsat, 
    string? @description, 
    string? @descriptionHash, 
    ulong @expiry, 
    Bolt11Invoice @invoice, 
    ulong @minFinalCltvExpiryDelta, 
    BitcoinNetwork @network, 
    string @payeePubkey, 
    string @paymentHash, 
    string @paymentSecret, 
    List<Bolt11RouteHint> @routingHints, 
    ulong @timestamp
) {
}

class FfiConverterTypeBolt11InvoiceDetails: FfiConverterRustBuffer<Bolt11InvoiceDetails> {
    public static FfiConverterTypeBolt11InvoiceDetails INSTANCE = new FfiConverterTypeBolt11InvoiceDetails();

    public override Bolt11InvoiceDetails Read(BigEndianStream stream) {
        return new Bolt11InvoiceDetails(
            @amountMsat: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @description: FfiConverterOptionalString.INSTANCE.Read(stream),
            @descriptionHash: FfiConverterOptionalString.INSTANCE.Read(stream),
            @expiry: FfiConverterUInt64.INSTANCE.Read(stream),
            @invoice: FfiConverterTypeBolt11Invoice.INSTANCE.Read(stream),
            @minFinalCltvExpiryDelta: FfiConverterUInt64.INSTANCE.Read(stream),
            @network: FfiConverterTypeBitcoinNetwork.INSTANCE.Read(stream),
            @payeePubkey: FfiConverterString.INSTANCE.Read(stream),
            @paymentHash: FfiConverterString.INSTANCE.Read(stream),
            @paymentSecret: FfiConverterString.INSTANCE.Read(stream),
            @routingHints: FfiConverterSequenceTypeBolt11RouteHint.INSTANCE.Read(stream),
            @timestamp: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt11InvoiceDetails value) {
        return 0
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@amountMsat)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@descriptionHash)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@expiry)
            + FfiConverterTypeBolt11Invoice.INSTANCE.AllocationSize(value.@invoice)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@minFinalCltvExpiryDelta)
            + FfiConverterTypeBitcoinNetwork.INSTANCE.AllocationSize(value.@network)
            + FfiConverterString.INSTANCE.AllocationSize(value.@payeePubkey)
            + FfiConverterString.INSTANCE.AllocationSize(value.@paymentHash)
            + FfiConverterString.INSTANCE.AllocationSize(value.@paymentSecret)
            + FfiConverterSequenceTypeBolt11RouteHint.INSTANCE.AllocationSize(value.@routingHints)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@timestamp);
    }

    public override void Write(Bolt11InvoiceDetails value, BigEndianStream stream) {
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@amountMsat, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@description, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@descriptionHash, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@expiry, stream);
            FfiConverterTypeBolt11Invoice.INSTANCE.Write(value.@invoice, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@minFinalCltvExpiryDelta, stream);
            FfiConverterTypeBitcoinNetwork.INSTANCE.Write(value.@network, stream);
            FfiConverterString.INSTANCE.Write(value.@payeePubkey, stream);
            FfiConverterString.INSTANCE.Write(value.@paymentHash, stream);
            FfiConverterString.INSTANCE.Write(value.@paymentSecret, stream);
            FfiConverterSequenceTypeBolt11RouteHint.INSTANCE.Write(value.@routingHints, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@timestamp, stream);
    }
}



public record Bolt11RouteHint (
    List<Bolt11RouteHintHop> @hops
) {
}

class FfiConverterTypeBolt11RouteHint: FfiConverterRustBuffer<Bolt11RouteHint> {
    public static FfiConverterTypeBolt11RouteHint INSTANCE = new FfiConverterTypeBolt11RouteHint();

    public override Bolt11RouteHint Read(BigEndianStream stream) {
        return new Bolt11RouteHint(
            @hops: FfiConverterSequenceTypeBolt11RouteHintHop.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt11RouteHint value) {
        return 0
            + FfiConverterSequenceTypeBolt11RouteHintHop.INSTANCE.AllocationSize(value.@hops);
    }

    public override void Write(Bolt11RouteHint value, BigEndianStream stream) {
            FfiConverterSequenceTypeBolt11RouteHintHop.INSTANCE.Write(value.@hops, stream);
    }
}



/// <param name="src_node_id">
/// The `node_id` of the non-target end of the route
/// </param>
/// <param name="short_channel_id">
/// The `short_channel_id` of this channel
/// </param>
/// <param name="fees_base_msat">
/// The fees which must be paid to use this channel
/// </param>
/// <param name="cltv_expiry_delta">
/// The difference in CLTV values between this node and the next node.
/// </param>
/// <param name="htlc_minimum_msat">
/// The minimum value, in msat, which must be relayed to the next hop.
/// </param>
/// <param name="htlc_maximum_msat">
/// The maximum value in msat available for routing with a single HTLC.
/// </param>
public record Bolt11RouteHintHop (
    /// <summary>
    /// The `node_id` of the non-target end of the route
    /// </summary>
    string @srcNodeId, 
    /// <summary>
    /// The `short_channel_id` of this channel
    /// </summary>
    string @shortChannelId, 
    /// <summary>
    /// The fees which must be paid to use this channel
    /// </summary>
    uint @feesBaseMsat, 
    uint @feesProportionalMillionths, 
    /// <summary>
    /// The difference in CLTV values between this node and the next node.
    /// </summary>
    ushort @cltvExpiryDelta, 
    /// <summary>
    /// The minimum value, in msat, which must be relayed to the next hop.
    /// </summary>
    ulong? @htlcMinimumMsat, 
    /// <summary>
    /// The maximum value in msat available for routing with a single HTLC.
    /// </summary>
    ulong? @htlcMaximumMsat
) {
}

class FfiConverterTypeBolt11RouteHintHop: FfiConverterRustBuffer<Bolt11RouteHintHop> {
    public static FfiConverterTypeBolt11RouteHintHop INSTANCE = new FfiConverterTypeBolt11RouteHintHop();

    public override Bolt11RouteHintHop Read(BigEndianStream stream) {
        return new Bolt11RouteHintHop(
            @srcNodeId: FfiConverterString.INSTANCE.Read(stream),
            @shortChannelId: FfiConverterString.INSTANCE.Read(stream),
            @feesBaseMsat: FfiConverterUInt32.INSTANCE.Read(stream),
            @feesProportionalMillionths: FfiConverterUInt32.INSTANCE.Read(stream),
            @cltvExpiryDelta: FfiConverterUInt16.INSTANCE.Read(stream),
            @htlcMinimumMsat: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @htlcMaximumMsat: FfiConverterOptionalUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt11RouteHintHop value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@srcNodeId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@shortChannelId)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@feesBaseMsat)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@feesProportionalMillionths)
            + FfiConverterUInt16.INSTANCE.AllocationSize(value.@cltvExpiryDelta)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@htlcMinimumMsat)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@htlcMaximumMsat);
    }

    public override void Write(Bolt11RouteHintHop value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@srcNodeId, stream);
            FfiConverterString.INSTANCE.Write(value.@shortChannelId, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@feesBaseMsat, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@feesProportionalMillionths, stream);
            FfiConverterUInt16.INSTANCE.Write(value.@cltvExpiryDelta, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@htlcMinimumMsat, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@htlcMaximumMsat, stream);
    }
}



public record Bolt12Invoice (
    string @invoice, 
    PaymentRequestSource @source
) {
}

class FfiConverterTypeBolt12Invoice: FfiConverterRustBuffer<Bolt12Invoice> {
    public static FfiConverterTypeBolt12Invoice INSTANCE = new FfiConverterTypeBolt12Invoice();

    public override Bolt12Invoice Read(BigEndianStream stream) {
        return new Bolt12Invoice(
            @invoice: FfiConverterString.INSTANCE.Read(stream),
            @source: FfiConverterTypePaymentRequestSource.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt12Invoice value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@invoice)
            + FfiConverterTypePaymentRequestSource.INSTANCE.AllocationSize(value.@source);
    }

    public override void Write(Bolt12Invoice value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@invoice, stream);
            FfiConverterTypePaymentRequestSource.INSTANCE.Write(value.@source, stream);
    }
}



public record Bolt12InvoiceDetails (
    ulong @amountMsat, 
    Bolt12Invoice @invoice
) {
}

class FfiConverterTypeBolt12InvoiceDetails: FfiConverterRustBuffer<Bolt12InvoiceDetails> {
    public static FfiConverterTypeBolt12InvoiceDetails INSTANCE = new FfiConverterTypeBolt12InvoiceDetails();

    public override Bolt12InvoiceDetails Read(BigEndianStream stream) {
        return new Bolt12InvoiceDetails(
            @amountMsat: FfiConverterUInt64.INSTANCE.Read(stream),
            @invoice: FfiConverterTypeBolt12Invoice.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt12InvoiceDetails value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@amountMsat)
            + FfiConverterTypeBolt12Invoice.INSTANCE.AllocationSize(value.@invoice);
    }

    public override void Write(Bolt12InvoiceDetails value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@amountMsat, stream);
            FfiConverterTypeBolt12Invoice.INSTANCE.Write(value.@invoice, stream);
    }
}



public record Bolt12InvoiceRequestDetails (
) {
}

class FfiConverterTypeBolt12InvoiceRequestDetails: FfiConverterRustBuffer<Bolt12InvoiceRequestDetails> {
    public static FfiConverterTypeBolt12InvoiceRequestDetails INSTANCE = new FfiConverterTypeBolt12InvoiceRequestDetails();

    public override Bolt12InvoiceRequestDetails Read(BigEndianStream stream) {
        return new Bolt12InvoiceRequestDetails(
        );
    }

    public override int AllocationSize(Bolt12InvoiceRequestDetails value) {
        return 0;
    }

    public override void Write(Bolt12InvoiceRequestDetails value, BigEndianStream stream) {
    }
}



public record Bolt12Offer (
    string @offer, 
    PaymentRequestSource @source
) {
}

class FfiConverterTypeBolt12Offer: FfiConverterRustBuffer<Bolt12Offer> {
    public static FfiConverterTypeBolt12Offer INSTANCE = new FfiConverterTypeBolt12Offer();

    public override Bolt12Offer Read(BigEndianStream stream) {
        return new Bolt12Offer(
            @offer: FfiConverterString.INSTANCE.Read(stream),
            @source: FfiConverterTypePaymentRequestSource.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt12Offer value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@offer)
            + FfiConverterTypePaymentRequestSource.INSTANCE.AllocationSize(value.@source);
    }

    public override void Write(Bolt12Offer value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@offer, stream);
            FfiConverterTypePaymentRequestSource.INSTANCE.Write(value.@source, stream);
    }
}



public record Bolt12OfferBlindedPath (
    List<string> @blindedHops
) {
}

class FfiConverterTypeBolt12OfferBlindedPath: FfiConverterRustBuffer<Bolt12OfferBlindedPath> {
    public static FfiConverterTypeBolt12OfferBlindedPath INSTANCE = new FfiConverterTypeBolt12OfferBlindedPath();

    public override Bolt12OfferBlindedPath Read(BigEndianStream stream) {
        return new Bolt12OfferBlindedPath(
            @blindedHops: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt12OfferBlindedPath value) {
        return 0
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@blindedHops);
    }

    public override void Write(Bolt12OfferBlindedPath value, BigEndianStream stream) {
            FfiConverterSequenceString.INSTANCE.Write(value.@blindedHops, stream);
    }
}



public record Bolt12OfferDetails (
    ulong? @absoluteExpiry, 
    List<string> @chains, 
    string? @description, 
    string? @issuer, 
    Amount? @minAmount, 
    Bolt12Offer @offer, 
    List<Bolt12OfferBlindedPath> @paths, 
    string? @signingPubkey
) {
}

class FfiConverterTypeBolt12OfferDetails: FfiConverterRustBuffer<Bolt12OfferDetails> {
    public static FfiConverterTypeBolt12OfferDetails INSTANCE = new FfiConverterTypeBolt12OfferDetails();

    public override Bolt12OfferDetails Read(BigEndianStream stream) {
        return new Bolt12OfferDetails(
            @absoluteExpiry: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @chains: FfiConverterSequenceString.INSTANCE.Read(stream),
            @description: FfiConverterOptionalString.INSTANCE.Read(stream),
            @issuer: FfiConverterOptionalString.INSTANCE.Read(stream),
            @minAmount: FfiConverterOptionalTypeAmount.INSTANCE.Read(stream),
            @offer: FfiConverterTypeBolt12Offer.INSTANCE.Read(stream),
            @paths: FfiConverterSequenceTypeBolt12OfferBlindedPath.INSTANCE.Read(stream),
            @signingPubkey: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Bolt12OfferDetails value) {
        return 0
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@absoluteExpiry)
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@chains)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@issuer)
            + FfiConverterOptionalTypeAmount.INSTANCE.AllocationSize(value.@minAmount)
            + FfiConverterTypeBolt12Offer.INSTANCE.AllocationSize(value.@offer)
            + FfiConverterSequenceTypeBolt12OfferBlindedPath.INSTANCE.AllocationSize(value.@paths)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@signingPubkey);
    }

    public override void Write(Bolt12OfferDetails value, BigEndianStream stream) {
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@absoluteExpiry, stream);
            FfiConverterSequenceString.INSTANCE.Write(value.@chains, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@description, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@issuer, stream);
            FfiConverterOptionalTypeAmount.INSTANCE.Write(value.@minAmount, stream);
            FfiConverterTypeBolt12Offer.INSTANCE.Write(value.@offer, stream);
            FfiConverterSequenceTypeBolt12OfferBlindedPath.INSTANCE.Write(value.@paths, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@signingPubkey, stream);
    }
}



/// <summary>
/// Details about a supported currency in the fiat rate feed
/// </summary>
public record CurrencyInfo (
    string @name, 
    uint @fractionSize, 
    uint? @spacing, 
    Symbol? @symbol, 
    Symbol? @uniqSymbol, 
    List<LocalizedName> @localizedName, 
    List<LocaleOverrides> @localeOverrides
) {
}

class FfiConverterTypeCurrencyInfo: FfiConverterRustBuffer<CurrencyInfo> {
    public static FfiConverterTypeCurrencyInfo INSTANCE = new FfiConverterTypeCurrencyInfo();

    public override CurrencyInfo Read(BigEndianStream stream) {
        return new CurrencyInfo(
            @name: FfiConverterString.INSTANCE.Read(stream),
            @fractionSize: FfiConverterUInt32.INSTANCE.Read(stream),
            @spacing: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @symbol: FfiConverterOptionalTypeSymbol.INSTANCE.Read(stream),
            @uniqSymbol: FfiConverterOptionalTypeSymbol.INSTANCE.Read(stream),
            @localizedName: FfiConverterSequenceTypeLocalizedName.INSTANCE.Read(stream),
            @localeOverrides: FfiConverterSequenceTypeLocaleOverrides.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CurrencyInfo value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@fractionSize)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@spacing)
            + FfiConverterOptionalTypeSymbol.INSTANCE.AllocationSize(value.@symbol)
            + FfiConverterOptionalTypeSymbol.INSTANCE.AllocationSize(value.@uniqSymbol)
            + FfiConverterSequenceTypeLocalizedName.INSTANCE.AllocationSize(value.@localizedName)
            + FfiConverterSequenceTypeLocaleOverrides.INSTANCE.AllocationSize(value.@localeOverrides);
    }

    public override void Write(CurrencyInfo value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@fractionSize, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@spacing, stream);
            FfiConverterOptionalTypeSymbol.INSTANCE.Write(value.@symbol, stream);
            FfiConverterOptionalTypeSymbol.INSTANCE.Write(value.@uniqSymbol, stream);
            FfiConverterSequenceTypeLocalizedName.INSTANCE.Write(value.@localizedName, stream);
            FfiConverterSequenceTypeLocaleOverrides.INSTANCE.Write(value.@localeOverrides, stream);
    }
}



/// <summary>
/// Configuration for an external input parser
/// </summary>
/// <param name="provider_id">
/// An arbitrary parser provider id
/// </param>
/// <param name="input_regex">
/// The external parser will be used when an input conforms to this regex
/// </param>
/// <param name="parser_url">
/// The URL of the parser containing a placeholder `<input>` that will be replaced with the
/// input to be parsed. The input is sanitized using percent encoding.
/// </param>
public record ExternalInputParser (
    /// <summary>
    /// An arbitrary parser provider id
    /// </summary>
    string @providerId, 
    /// <summary>
    /// The external parser will be used when an input conforms to this regex
    /// </summary>
    string @inputRegex, 
    /// <summary>
    /// The URL of the parser containing a placeholder `<input>` that will be replaced with the
    /// input to be parsed. The input is sanitized using percent encoding.
    /// </summary>
    string @parserUrl
) {
}

class FfiConverterTypeExternalInputParser: FfiConverterRustBuffer<ExternalInputParser> {
    public static FfiConverterTypeExternalInputParser INSTANCE = new FfiConverterTypeExternalInputParser();

    public override ExternalInputParser Read(BigEndianStream stream) {
        return new ExternalInputParser(
            @providerId: FfiConverterString.INSTANCE.Read(stream),
            @inputRegex: FfiConverterString.INSTANCE.Read(stream),
            @parserUrl: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ExternalInputParser value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@providerId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@inputRegex)
            + FfiConverterString.INSTANCE.AllocationSize(value.@parserUrl);
    }

    public override void Write(ExternalInputParser value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@providerId, stream);
            FfiConverterString.INSTANCE.Write(value.@inputRegex, stream);
            FfiConverterString.INSTANCE.Write(value.@parserUrl, stream);
    }
}



/// <summary>
/// Wrapper around the [`CurrencyInfo`] of a fiat currency
/// </summary>
public record FiatCurrency (
    string @id, 
    CurrencyInfo @info
) {
}

class FfiConverterTypeFiatCurrency: FfiConverterRustBuffer<FiatCurrency> {
    public static FfiConverterTypeFiatCurrency INSTANCE = new FfiConverterTypeFiatCurrency();

    public override FiatCurrency Read(BigEndianStream stream) {
        return new FiatCurrency(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @info: FfiConverterTypeCurrencyInfo.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(FiatCurrency value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterTypeCurrencyInfo.INSTANCE.AllocationSize(value.@info);
    }

    public override void Write(FiatCurrency value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterTypeCurrencyInfo.INSTANCE.Write(value.@info, stream);
    }
}



public record IncomingChange (
    Record @newState, 
    Record? @oldState
) {
}

class FfiConverterTypeIncomingChange: FfiConverterRustBuffer<IncomingChange> {
    public static FfiConverterTypeIncomingChange INSTANCE = new FfiConverterTypeIncomingChange();

    public override IncomingChange Read(BigEndianStream stream) {
        return new IncomingChange(
            @newState: FfiConverterTypeRecord.INSTANCE.Read(stream),
            @oldState: FfiConverterOptionalTypeRecord.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(IncomingChange value) {
        return 0
            + FfiConverterTypeRecord.INSTANCE.AllocationSize(value.@newState)
            + FfiConverterOptionalTypeRecord.INSTANCE.AllocationSize(value.@oldState);
    }

    public override void Write(IncomingChange value, BigEndianStream stream) {
            FfiConverterTypeRecord.INSTANCE.Write(value.@newState, stream);
            FfiConverterOptionalTypeRecord.INSTANCE.Write(value.@oldState, stream);
    }
}



public record LightningAddressDetails (
    string @address, 
    LnurlPayRequestDetails @payRequest
) {
}

class FfiConverterTypeLightningAddressDetails: FfiConverterRustBuffer<LightningAddressDetails> {
    public static FfiConverterTypeLightningAddressDetails INSTANCE = new FfiConverterTypeLightningAddressDetails();

    public override LightningAddressDetails Read(BigEndianStream stream) {
        return new LightningAddressDetails(
            @address: FfiConverterString.INSTANCE.Read(stream),
            @payRequest: FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LightningAddressDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@address)
            + FfiConverterTypeLnurlPayRequestDetails.INSTANCE.AllocationSize(value.@payRequest);
    }

    public override void Write(LightningAddressDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@address, stream);
            FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Write(value.@payRequest, stream);
    }
}



/// <summary>
/// Wrapped in a [`LnurlAuth`], this is the result of [`parse`] when given a LNURL-auth endpoint.
///
/// It represents the endpoint's parameters for the LNURL workflow.
///
/// See <https://github.com/lnurl/luds/blob/luds/04.md>
/// </summary>
/// <param name="k1">
/// Hex encoded 32 bytes of challenge
/// </param>
/// <param name="action">
/// When available, one of: register, login, link, auth
/// </param>
/// <param name="domain">
/// Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
/// auth confirmation, as per LUD-04 spec.
/// </param>
/// <param name="url">
/// Indicates the URL of the LNURL-auth service, including the query arguments. This will be
/// extended with the signed challenge and the linking key, then called in the second step of the workflow.
/// </param>
public record LnurlAuthRequestDetails (
    /// <summary>
    /// Hex encoded 32 bytes of challenge
    /// </summary>
    string @k1, 
    /// <summary>
    /// When available, one of: register, login, link, auth
    /// </summary>
    string? @action, 
    /// <summary>
    /// Indicates the domain of the LNURL-auth service, to be shown to the user when asking for
    /// auth confirmation, as per LUD-04 spec.
    /// </summary>
    string @domain, 
    /// <summary>
    /// Indicates the URL of the LNURL-auth service, including the query arguments. This will be
    /// extended with the signed challenge and the linking key, then called in the second step of the workflow.
    /// </summary>
    string @url
) {
}

class FfiConverterTypeLnurlAuthRequestDetails: FfiConverterRustBuffer<LnurlAuthRequestDetails> {
    public static FfiConverterTypeLnurlAuthRequestDetails INSTANCE = new FfiConverterTypeLnurlAuthRequestDetails();

    public override LnurlAuthRequestDetails Read(BigEndianStream stream) {
        return new LnurlAuthRequestDetails(
            @k1: FfiConverterString.INSTANCE.Read(stream),
            @action: FfiConverterOptionalString.INSTANCE.Read(stream),
            @domain: FfiConverterString.INSTANCE.Read(stream),
            @url: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlAuthRequestDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@k1)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@action)
            + FfiConverterString.INSTANCE.AllocationSize(value.@domain)
            + FfiConverterString.INSTANCE.AllocationSize(value.@url);
    }

    public override void Write(LnurlAuthRequestDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@k1, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@action, stream);
            FfiConverterString.INSTANCE.Write(value.@domain, stream);
            FfiConverterString.INSTANCE.Write(value.@url, stream);
    }
}



/// <summary>
/// Wrapped in a [`LnUrlError`], this represents a LNURL-endpoint error.
/// </summary>
public record LnurlErrorDetails (
    string @reason
) {
}

class FfiConverterTypeLnurlErrorDetails: FfiConverterRustBuffer<LnurlErrorDetails> {
    public static FfiConverterTypeLnurlErrorDetails INSTANCE = new FfiConverterTypeLnurlErrorDetails();

    public override LnurlErrorDetails Read(BigEndianStream stream) {
        return new LnurlErrorDetails(
            @reason: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlErrorDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@reason);
    }

    public override void Write(LnurlErrorDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@reason, stream);
    }
}



/// <param name="min_sendable">
/// The minimum amount, in millisats, that this LNURL-pay endpoint accepts
/// </param>
/// <param name="max_sendable">
/// The maximum amount, in millisats, that this LNURL-pay endpoint accepts
/// </param>
/// <param name="metadata_str">
/// As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
/// Use `metadata_vec()` to get the parsed items.
/// </param>
/// <param name="comment_allowed">
/// The comment length accepted by this endpoint
/// 
/// See <https://github.com/lnurl/luds/blob/luds/12.md>
/// </param>
/// <param name="domain">
/// Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
/// payment input, as per LUD-06 spec.
/// 
/// Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
/// </param>
/// <param name="address">
/// Optional lightning address if that was used to resolve the lnurl.
/// </param>
/// <param name="allows_nostr">
/// Value indicating whether the recipient supports Nostr Zaps through NIP-57.
/// 
/// See <https://github.com/nostr-protocol/nips/blob/master/57.md>
/// </param>
/// <param name="nostr_pubkey">
/// Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
/// valid BIP 340 public key in hex.
/// 
/// See <https://github.com/nostr-protocol/nips/blob/master/57.md>
/// See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
/// </param>
public record LnurlPayRequestDetails (
    string @callback, 
    /// <summary>
    /// The minimum amount, in millisats, that this LNURL-pay endpoint accepts
    /// </summary>
    ulong @minSendable, 
    /// <summary>
    /// The maximum amount, in millisats, that this LNURL-pay endpoint accepts
    /// </summary>
    ulong @maxSendable, 
    /// <summary>
    /// As per LUD-06, `metadata` is a raw string (e.g. a json representation of the inner map).
    /// Use `metadata_vec()` to get the parsed items.
    /// </summary>
    string @metadataStr, 
    /// <summary>
    /// The comment length accepted by this endpoint
    ///
    /// See <https://github.com/lnurl/luds/blob/luds/12.md>
    /// </summary>
    ushort @commentAllowed, 
    /// <summary>
    /// Indicates the domain of the LNURL-pay service, to be shown to the user when asking for
    /// payment input, as per LUD-06 spec.
    ///
    /// Note: this is not the domain of the callback, but the domain of the LNURL-pay endpoint.
    /// </summary>
    string @domain, 
    string @url, 
    /// <summary>
    /// Optional lightning address if that was used to resolve the lnurl.
    /// </summary>
    string? @address, 
    /// <summary>
    /// Value indicating whether the recipient supports Nostr Zaps through NIP-57.
    ///
    /// See <https://github.com/nostr-protocol/nips/blob/master/57.md>
    /// </summary>
    bool? @allowsNostr, 
    /// <summary>
    /// Optional recipient's lnurl provider's Nostr pubkey for NIP-57. If it exists it should be a
    /// valid BIP 340 public key in hex.
    ///
    /// See <https://github.com/nostr-protocol/nips/blob/master/57.md>
    /// See <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>
    /// </summary>
    string? @nostrPubkey
) {
}

class FfiConverterTypeLnurlPayRequestDetails: FfiConverterRustBuffer<LnurlPayRequestDetails> {
    public static FfiConverterTypeLnurlPayRequestDetails INSTANCE = new FfiConverterTypeLnurlPayRequestDetails();

    public override LnurlPayRequestDetails Read(BigEndianStream stream) {
        return new LnurlPayRequestDetails(
            @callback: FfiConverterString.INSTANCE.Read(stream),
            @minSendable: FfiConverterUInt64.INSTANCE.Read(stream),
            @maxSendable: FfiConverterUInt64.INSTANCE.Read(stream),
            @metadataStr: FfiConverterString.INSTANCE.Read(stream),
            @commentAllowed: FfiConverterUInt16.INSTANCE.Read(stream),
            @domain: FfiConverterString.INSTANCE.Read(stream),
            @url: FfiConverterString.INSTANCE.Read(stream),
            @address: FfiConverterOptionalString.INSTANCE.Read(stream),
            @allowsNostr: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @nostrPubkey: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlPayRequestDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@callback)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@minSendable)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@maxSendable)
            + FfiConverterString.INSTANCE.AllocationSize(value.@metadataStr)
            + FfiConverterUInt16.INSTANCE.AllocationSize(value.@commentAllowed)
            + FfiConverterString.INSTANCE.AllocationSize(value.@domain)
            + FfiConverterString.INSTANCE.AllocationSize(value.@url)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@address)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@allowsNostr)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@nostrPubkey);
    }

    public override void Write(LnurlPayRequestDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@callback, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@minSendable, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@maxSendable, stream);
            FfiConverterString.INSTANCE.Write(value.@metadataStr, stream);
            FfiConverterUInt16.INSTANCE.Write(value.@commentAllowed, stream);
            FfiConverterString.INSTANCE.Write(value.@domain, stream);
            FfiConverterString.INSTANCE.Write(value.@url, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@address, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@allowsNostr, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@nostrPubkey, stream);
    }
}



/// <param name="min_withdrawable">
/// The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
/// </param>
/// <param name="max_withdrawable">
/// The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
/// </param>
public record LnurlWithdrawRequestDetails (
    string @callback, 
    string @k1, 
    string @defaultDescription, 
    /// <summary>
    /// The minimum amount, in millisats, that this LNURL-withdraw endpoint accepts
    /// </summary>
    ulong @minWithdrawable, 
    /// <summary>
    /// The maximum amount, in millisats, that this LNURL-withdraw endpoint accepts
    /// </summary>
    ulong @maxWithdrawable
) {
}

class FfiConverterTypeLnurlWithdrawRequestDetails: FfiConverterRustBuffer<LnurlWithdrawRequestDetails> {
    public static FfiConverterTypeLnurlWithdrawRequestDetails INSTANCE = new FfiConverterTypeLnurlWithdrawRequestDetails();

    public override LnurlWithdrawRequestDetails Read(BigEndianStream stream) {
        return new LnurlWithdrawRequestDetails(
            @callback: FfiConverterString.INSTANCE.Read(stream),
            @k1: FfiConverterString.INSTANCE.Read(stream),
            @defaultDescription: FfiConverterString.INSTANCE.Read(stream),
            @minWithdrawable: FfiConverterUInt64.INSTANCE.Read(stream),
            @maxWithdrawable: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlWithdrawRequestDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@callback)
            + FfiConverterString.INSTANCE.AllocationSize(value.@k1)
            + FfiConverterString.INSTANCE.AllocationSize(value.@defaultDescription)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@minWithdrawable)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@maxWithdrawable);
    }

    public override void Write(LnurlWithdrawRequestDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@callback, stream);
            FfiConverterString.INSTANCE.Write(value.@k1, stream);
            FfiConverterString.INSTANCE.Write(value.@defaultDescription, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@minWithdrawable, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@maxWithdrawable, stream);
    }
}



/// <summary>
/// Locale-specific settings for the representation of a currency
/// </summary>
public record LocaleOverrides (
    string @locale, 
    uint? @spacing, 
    Symbol @symbol
) {
}

class FfiConverterTypeLocaleOverrides: FfiConverterRustBuffer<LocaleOverrides> {
    public static FfiConverterTypeLocaleOverrides INSTANCE = new FfiConverterTypeLocaleOverrides();

    public override LocaleOverrides Read(BigEndianStream stream) {
        return new LocaleOverrides(
            @locale: FfiConverterString.INSTANCE.Read(stream),
            @spacing: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @symbol: FfiConverterTypeSymbol.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LocaleOverrides value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@locale)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@spacing)
            + FfiConverterTypeSymbol.INSTANCE.AllocationSize(value.@symbol);
    }

    public override void Write(LocaleOverrides value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@locale, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@spacing, stream);
            FfiConverterTypeSymbol.INSTANCE.Write(value.@symbol, stream);
    }
}



/// <summary>
/// Localized name of a currency
/// </summary>
public record LocalizedName (
    string @locale, 
    string @name
) {
}

class FfiConverterTypeLocalizedName: FfiConverterRustBuffer<LocalizedName> {
    public static FfiConverterTypeLocalizedName INSTANCE = new FfiConverterTypeLocalizedName();

    public override LocalizedName Read(BigEndianStream stream) {
        return new LocalizedName(
            @locale: FfiConverterString.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LocalizedName value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@locale)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name);
    }

    public override void Write(LocalizedName value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@locale, stream);
            FfiConverterString.INSTANCE.Write(value.@name, stream);
    }
}



public record MessageSuccessActionData (
    string @message
) {
}

class FfiConverterTypeMessageSuccessActionData: FfiConverterRustBuffer<MessageSuccessActionData> {
    public static FfiConverterTypeMessageSuccessActionData INSTANCE = new FfiConverterTypeMessageSuccessActionData();

    public override MessageSuccessActionData Read(BigEndianStream stream) {
        return new MessageSuccessActionData(
            @message: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(MessageSuccessActionData value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@message);
    }

    public override void Write(MessageSuccessActionData value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@message, stream);
    }
}



public record OutgoingChange (
    RecordChange @change, 
    Record? @parent
) {
}

class FfiConverterTypeOutgoingChange: FfiConverterRustBuffer<OutgoingChange> {
    public static FfiConverterTypeOutgoingChange INSTANCE = new FfiConverterTypeOutgoingChange();

    public override OutgoingChange Read(BigEndianStream stream) {
        return new OutgoingChange(
            @change: FfiConverterTypeRecordChange.INSTANCE.Read(stream),
            @parent: FfiConverterOptionalTypeRecord.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(OutgoingChange value) {
        return 0
            + FfiConverterTypeRecordChange.INSTANCE.AllocationSize(value.@change)
            + FfiConverterOptionalTypeRecord.INSTANCE.AllocationSize(value.@parent);
    }

    public override void Write(OutgoingChange value, BigEndianStream stream) {
            FfiConverterTypeRecordChange.INSTANCE.Write(value.@change, stream);
            FfiConverterOptionalTypeRecord.INSTANCE.Write(value.@parent, stream);
    }
}



public record PaymentRequestSource (
    string? @bip21Uri, 
    string? @bip353Address
) {
}

class FfiConverterTypePaymentRequestSource: FfiConverterRustBuffer<PaymentRequestSource> {
    public static FfiConverterTypePaymentRequestSource INSTANCE = new FfiConverterTypePaymentRequestSource();

    public override PaymentRequestSource Read(BigEndianStream stream) {
        return new PaymentRequestSource(
            @bip21Uri: FfiConverterOptionalString.INSTANCE.Read(stream),
            @bip353Address: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PaymentRequestSource value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@bip21Uri)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@bip353Address);
    }

    public override void Write(PaymentRequestSource value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@bip21Uri, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@bip353Address, stream);
    }
}



/// <summary>
/// Denominator in an exchange rate
/// </summary>
public record Rate (
    string @coin, 
    double @value
) {
}

class FfiConverterTypeRate: FfiConverterRustBuffer<Rate> {
    public static FfiConverterTypeRate INSTANCE = new FfiConverterTypeRate();

    public override Rate Read(BigEndianStream stream) {
        return new Rate(
            @coin: FfiConverterString.INSTANCE.Read(stream),
            @value: FfiConverterDouble.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Rate value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@coin)
            + FfiConverterDouble.INSTANCE.AllocationSize(value.@value);
    }

    public override void Write(Rate value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@coin, stream);
            FfiConverterDouble.INSTANCE.Write(value.@value, stream);
    }
}



public record Record (
    RecordId @id, 
    ulong @revision, 
    string @schemaVersion, 
    Dictionary<string, string> @data
) {
}

class FfiConverterTypeRecord: FfiConverterRustBuffer<Record> {
    public static FfiConverterTypeRecord INSTANCE = new FfiConverterTypeRecord();

    public override Record Read(BigEndianStream stream) {
        return new Record(
            @id: FfiConverterTypeRecordId.INSTANCE.Read(stream),
            @revision: FfiConverterUInt64.INSTANCE.Read(stream),
            @schemaVersion: FfiConverterString.INSTANCE.Read(stream),
            @data: FfiConverterDictionaryStringString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Record value) {
        return 0
            + FfiConverterTypeRecordId.INSTANCE.AllocationSize(value.@id)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@revision)
            + FfiConverterString.INSTANCE.AllocationSize(value.@schemaVersion)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@data);
    }

    public override void Write(Record value, BigEndianStream stream) {
            FfiConverterTypeRecordId.INSTANCE.Write(value.@id, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@revision, stream);
            FfiConverterString.INSTANCE.Write(value.@schemaVersion, stream);
            FfiConverterDictionaryStringString.INSTANCE.Write(value.@data, stream);
    }
}



public record RecordChange (
    RecordId @id, 
    string @schemaVersion, 
    Dictionary<string, string> @updatedFields, 
    ulong @revision
) {
}

class FfiConverterTypeRecordChange: FfiConverterRustBuffer<RecordChange> {
    public static FfiConverterTypeRecordChange INSTANCE = new FfiConverterTypeRecordChange();

    public override RecordChange Read(BigEndianStream stream) {
        return new RecordChange(
            @id: FfiConverterTypeRecordId.INSTANCE.Read(stream),
            @schemaVersion: FfiConverterString.INSTANCE.Read(stream),
            @updatedFields: FfiConverterDictionaryStringString.INSTANCE.Read(stream),
            @revision: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RecordChange value) {
        return 0
            + FfiConverterTypeRecordId.INSTANCE.AllocationSize(value.@id)
            + FfiConverterString.INSTANCE.AllocationSize(value.@schemaVersion)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@updatedFields)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@revision);
    }

    public override void Write(RecordChange value, BigEndianStream stream) {
            FfiConverterTypeRecordId.INSTANCE.Write(value.@id, stream);
            FfiConverterString.INSTANCE.Write(value.@schemaVersion, stream);
            FfiConverterDictionaryStringString.INSTANCE.Write(value.@updatedFields, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@revision, stream);
    }
}



public record RecordId (
    string @type, 
    string @dataId
) {
}

class FfiConverterTypeRecordId: FfiConverterRustBuffer<RecordId> {
    public static FfiConverterTypeRecordId INSTANCE = new FfiConverterTypeRecordId();

    public override RecordId Read(BigEndianStream stream) {
        return new RecordId(
            @type: FfiConverterString.INSTANCE.Read(stream),
            @dataId: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RecordId value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@type)
            + FfiConverterString.INSTANCE.AllocationSize(value.@dataId);
    }

    public override void Write(RecordId value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@type, stream);
            FfiConverterString.INSTANCE.Write(value.@dataId, stream);
    }
}



public record RestResponse (
    ushort @status, 
    string @body
) {
}

class FfiConverterTypeRestResponse: FfiConverterRustBuffer<RestResponse> {
    public static FfiConverterTypeRestResponse INSTANCE = new FfiConverterTypeRestResponse();

    public override RestResponse Read(BigEndianStream stream) {
        return new RestResponse(
            @status: FfiConverterUInt16.INSTANCE.Read(stream),
            @body: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RestResponse value) {
        return 0
            + FfiConverterUInt16.INSTANCE.AllocationSize(value.@status)
            + FfiConverterString.INSTANCE.AllocationSize(value.@body);
    }

    public override void Write(RestResponse value, BigEndianStream stream) {
            FfiConverterUInt16.INSTANCE.Write(value.@status, stream);
            FfiConverterString.INSTANCE.Write(value.@body, stream);
    }
}



public record SilentPaymentAddressDetails (
    string @address, 
    BitcoinNetwork @network, 
    PaymentRequestSource @source
) {
}

class FfiConverterTypeSilentPaymentAddressDetails: FfiConverterRustBuffer<SilentPaymentAddressDetails> {
    public static FfiConverterTypeSilentPaymentAddressDetails INSTANCE = new FfiConverterTypeSilentPaymentAddressDetails();

    public override SilentPaymentAddressDetails Read(BigEndianStream stream) {
        return new SilentPaymentAddressDetails(
            @address: FfiConverterString.INSTANCE.Read(stream),
            @network: FfiConverterTypeBitcoinNetwork.INSTANCE.Read(stream),
            @source: FfiConverterTypePaymentRequestSource.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SilentPaymentAddressDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@address)
            + FfiConverterTypeBitcoinNetwork.INSTANCE.AllocationSize(value.@network)
            + FfiConverterTypePaymentRequestSource.INSTANCE.AllocationSize(value.@source);
    }

    public override void Write(SilentPaymentAddressDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@address, stream);
            FfiConverterTypeBitcoinNetwork.INSTANCE.Write(value.@network, stream);
            FfiConverterTypePaymentRequestSource.INSTANCE.Write(value.@source, stream);
    }
}



/// <param name="address">
/// The raw address string
/// </param>
/// <param name="identity_public_key">
/// The identity public key of the address owner
/// </param>
public record SparkAddressDetails (
    /// <summary>
    /// The raw address string
    /// </summary>
    string @address, 
    /// <summary>
    /// The identity public key of the address owner
    /// </summary>
    string @identityPublicKey, 
    BitcoinNetwork @network, 
    PaymentRequestSource @source
) {
}

class FfiConverterTypeSparkAddressDetails: FfiConverterRustBuffer<SparkAddressDetails> {
    public static FfiConverterTypeSparkAddressDetails INSTANCE = new FfiConverterTypeSparkAddressDetails();

    public override SparkAddressDetails Read(BigEndianStream stream) {
        return new SparkAddressDetails(
            @address: FfiConverterString.INSTANCE.Read(stream),
            @identityPublicKey: FfiConverterString.INSTANCE.Read(stream),
            @network: FfiConverterTypeBitcoinNetwork.INSTANCE.Read(stream),
            @source: FfiConverterTypePaymentRequestSource.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SparkAddressDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@address)
            + FfiConverterString.INSTANCE.AllocationSize(value.@identityPublicKey)
            + FfiConverterTypeBitcoinNetwork.INSTANCE.AllocationSize(value.@network)
            + FfiConverterTypePaymentRequestSource.INSTANCE.AllocationSize(value.@source);
    }

    public override void Write(SparkAddressDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@address, stream);
            FfiConverterString.INSTANCE.Write(value.@identityPublicKey, stream);
            FfiConverterTypeBitcoinNetwork.INSTANCE.Write(value.@network, stream);
            FfiConverterTypePaymentRequestSource.INSTANCE.Write(value.@source, stream);
    }
}



/// <param name="invoice">
/// The raw invoice string
/// </param>
/// <param name="identity_public_key">
/// The identity public key of the invoice issuer
/// </param>
/// <param name="amount">
/// Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
/// </param>
/// <param name="token_identifier">
/// The token identifier of the token payment. Absence indicates a Bitcoin payment.
/// </param>
/// <param name="expiry_time">
/// Optional expiry time. If not provided, the invoice will never expire.
/// </param>
/// <param name="description">
/// Optional description.
/// </param>
/// <param name="sender_public_key">
/// If set, the invoice may only be fulfilled by a payer with this public key.
/// </param>
public record SparkInvoiceDetails (
    /// <summary>
    /// The raw invoice string
    /// </summary>
    string @invoice, 
    /// <summary>
    /// The identity public key of the invoice issuer
    /// </summary>
    string @identityPublicKey, 
    BitcoinNetwork @network, 
    /// <summary>
    /// Optional amount denominated in sats if `token_identifier` is absent, otherwise in the token base units
    /// </summary>
    common_u128? @amount, 
    /// <summary>
    /// The token identifier of the token payment. Absence indicates a Bitcoin payment.
    /// </summary>
    string? @tokenIdentifier, 
    /// <summary>
    /// Optional expiry time. If not provided, the invoice will never expire.
    /// </summary>
    ulong? @expiryTime, 
    /// <summary>
    /// Optional description.
    /// </summary>
    string? @description, 
    /// <summary>
    /// If set, the invoice may only be fulfilled by a payer with this public key.
    /// </summary>
    string? @senderPublicKey
) {
}

class FfiConverterTypeSparkInvoiceDetails: FfiConverterRustBuffer<SparkInvoiceDetails> {
    public static FfiConverterTypeSparkInvoiceDetails INSTANCE = new FfiConverterTypeSparkInvoiceDetails();

    public override SparkInvoiceDetails Read(BigEndianStream stream) {
        return new SparkInvoiceDetails(
            @invoice: FfiConverterString.INSTANCE.Read(stream),
            @identityPublicKey: FfiConverterString.INSTANCE.Read(stream),
            @network: FfiConverterTypeBitcoinNetwork.INSTANCE.Read(stream),
            @amount: FfiConverterOptionalTypecommon_u128.INSTANCE.Read(stream),
            @tokenIdentifier: FfiConverterOptionalString.INSTANCE.Read(stream),
            @expiryTime: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @description: FfiConverterOptionalString.INSTANCE.Read(stream),
            @senderPublicKey: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SparkInvoiceDetails value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@invoice)
            + FfiConverterString.INSTANCE.AllocationSize(value.@identityPublicKey)
            + FfiConverterTypeBitcoinNetwork.INSTANCE.AllocationSize(value.@network)
            + FfiConverterOptionalTypecommon_u128.INSTANCE.AllocationSize(value.@amount)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@tokenIdentifier)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@expiryTime)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@senderPublicKey);
    }

    public override void Write(SparkInvoiceDetails value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@invoice, stream);
            FfiConverterString.INSTANCE.Write(value.@identityPublicKey, stream);
            FfiConverterTypeBitcoinNetwork.INSTANCE.Write(value.@network, stream);
            FfiConverterOptionalTypecommon_u128.INSTANCE.Write(value.@amount, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@tokenIdentifier, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@expiryTime, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@description, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@senderPublicKey, stream);
    }
}



/// <summary>
/// Settings for the symbol representation of a currency
/// </summary>
public record Symbol (
    string? @grapheme, 
    string? @template, 
    bool? @rtl, 
    uint? @position
) {
}

class FfiConverterTypeSymbol: FfiConverterRustBuffer<Symbol> {
    public static FfiConverterTypeSymbol INSTANCE = new FfiConverterTypeSymbol();

    public override Symbol Read(BigEndianStream stream) {
        return new Symbol(
            @grapheme: FfiConverterOptionalString.INSTANCE.Read(stream),
            @template: FfiConverterOptionalString.INSTANCE.Read(stream),
            @rtl: FfiConverterOptionalBoolean.INSTANCE.Read(stream),
            @position: FfiConverterOptionalUInt32.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Symbol value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@grapheme)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@template)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@rtl)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@position);
    }

    public override void Write(Symbol value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@grapheme, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@template, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@rtl, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@position, stream);
    }
}



public record UnversionedRecordChange (
    RecordId @id, 
    string @schemaVersion, 
    Dictionary<string, string> @updatedFields
) {
}

class FfiConverterTypeUnversionedRecordChange: FfiConverterRustBuffer<UnversionedRecordChange> {
    public static FfiConverterTypeUnversionedRecordChange INSTANCE = new FfiConverterTypeUnversionedRecordChange();

    public override UnversionedRecordChange Read(BigEndianStream stream) {
        return new UnversionedRecordChange(
            @id: FfiConverterTypeRecordId.INSTANCE.Read(stream),
            @schemaVersion: FfiConverterString.INSTANCE.Read(stream),
            @updatedFields: FfiConverterDictionaryStringString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(UnversionedRecordChange value) {
        return 0
            + FfiConverterTypeRecordId.INSTANCE.AllocationSize(value.@id)
            + FfiConverterString.INSTANCE.AllocationSize(value.@schemaVersion)
            + FfiConverterDictionaryStringString.INSTANCE.AllocationSize(value.@updatedFields);
    }

    public override void Write(UnversionedRecordChange value, BigEndianStream stream) {
            FfiConverterTypeRecordId.INSTANCE.Write(value.@id, stream);
            FfiConverterString.INSTANCE.Write(value.@schemaVersion, stream);
            FfiConverterDictionaryStringString.INSTANCE.Write(value.@updatedFields, stream);
    }
}



/// <param name="description">
/// Contents description, up to 144 characters
/// </param>
/// <param name="url">
/// URL of the success action
/// </param>
/// <param name="matches_callback_domain">
/// Indicates the success URL domain matches the LNURL callback domain.
/// 
/// See <https://github.com/lnurl/luds/blob/luds/09.md>
/// </param>
public record UrlSuccessActionData (
    /// <summary>
    /// Contents description, up to 144 characters
    /// </summary>
    string @description, 
    /// <summary>
    /// URL of the success action
    /// </summary>
    string @url, 
    /// <summary>
    /// Indicates the success URL domain matches the LNURL callback domain.
    ///
    /// See <https://github.com/lnurl/luds/blob/luds/09.md>
    /// </summary>
    bool @matchesCallbackDomain
) {
}

class FfiConverterTypeUrlSuccessActionData: FfiConverterRustBuffer<UrlSuccessActionData> {
    public static FfiConverterTypeUrlSuccessActionData INSTANCE = new FfiConverterTypeUrlSuccessActionData();

    public override UrlSuccessActionData Read(BigEndianStream stream) {
        return new UrlSuccessActionData(
            @description: FfiConverterString.INSTANCE.Read(stream),
            @url: FfiConverterString.INSTANCE.Read(stream),
            @matchesCallbackDomain: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(UrlSuccessActionData value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterString.INSTANCE.AllocationSize(value.@url)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@matchesCallbackDomain);
    }

    public override void Write(UrlSuccessActionData value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@description, stream);
            FfiConverterString.INSTANCE.Write(value.@url, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@matchesCallbackDomain, stream);
    }
}





/// <summary>
/// Result of decryption of [`AesSuccessActionData`] payload
/// </summary>
public record AesSuccessActionDataResult {
    
    public record Decrypted (
        AesSuccessActionDataDecrypted @data
    ) : AesSuccessActionDataResult {}
    
    public record ErrorStatus (
        string @reason
    ) : AesSuccessActionDataResult {}
    

    
}

class FfiConverterTypeAesSuccessActionDataResult : FfiConverterRustBuffer<AesSuccessActionDataResult>{
    public static FfiConverterRustBuffer<AesSuccessActionDataResult> INSTANCE = new FfiConverterTypeAesSuccessActionDataResult();

    public override AesSuccessActionDataResult Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new AesSuccessActionDataResult.Decrypted(
                    FfiConverterTypeAesSuccessActionDataDecrypted.INSTANCE.Read(stream)
                );
            case 2:
                return new AesSuccessActionDataResult.ErrorStatus(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAesSuccessActionDataResult.Read()", value));
        }
    }

    public override int AllocationSize(AesSuccessActionDataResult value) {
        switch (value) {
            case AesSuccessActionDataResult.Decrypted variant_value:
                return 4
                    + FfiConverterTypeAesSuccessActionDataDecrypted.INSTANCE.AllocationSize(variant_value.@data);
            case AesSuccessActionDataResult.ErrorStatus variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@reason);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAesSuccessActionDataResult.AllocationSize()", value));
        }
    }

    public override void Write(AesSuccessActionDataResult value, BigEndianStream stream) {
        switch (value) {
            case AesSuccessActionDataResult.Decrypted variant_value:
                stream.WriteInt(1);
                FfiConverterTypeAesSuccessActionDataDecrypted.INSTANCE.Write(variant_value.@data, stream);
                break;
            case AesSuccessActionDataResult.ErrorStatus variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@reason, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAesSuccessActionDataResult.Write()", value));
        }
    }
}







public record Amount {
    
    public record Bitcoin (
        ulong @amountMsat
    ) : Amount {}
    
    /// <summary>
    /// An amount of currency specified using ISO 4712.
    /// </summary>
    public record Currency (
        string @iso4217Code,
        ulong @fractionalAmount
    ) : Amount {}
    

    
}

class FfiConverterTypeAmount : FfiConverterRustBuffer<Amount>{
    public static FfiConverterRustBuffer<Amount> INSTANCE = new FfiConverterTypeAmount();

    public override Amount Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new Amount.Bitcoin(
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            case 2:
                return new Amount.Currency(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAmount.Read()", value));
        }
    }

    public override int AllocationSize(Amount value) {
        switch (value) {
            case Amount.Bitcoin variant_value:
                return 4
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@amountMsat);
            case Amount.Currency variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@iso4217Code)
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@fractionalAmount);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAmount.AllocationSize()", value));
        }
    }

    public override void Write(Amount value, BigEndianStream stream) {
        switch (value) {
            case Amount.Bitcoin variant_value:
                stream.WriteInt(1);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@amountMsat, stream);
                break;
            case Amount.Currency variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@iso4217Code, stream);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@fractionalAmount, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAmount.Write()", value));
        }
    }
}







public enum BitcoinNetwork: int {
    
    /// <summary>
    /// Mainnet
    /// </summary>
    Bitcoin,
    Testnet3,
    Testnet4,
    Signet,
    Regtest
}

class FfiConverterTypeBitcoinNetwork: FfiConverterRustBuffer<BitcoinNetwork> {
    public static FfiConverterTypeBitcoinNetwork INSTANCE = new FfiConverterTypeBitcoinNetwork();

    public override BitcoinNetwork Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(BitcoinNetwork), value)) {
            return (BitcoinNetwork)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeBitcoinNetwork.Read()", value));
        }
    }

    public override int AllocationSize(BitcoinNetwork value) {
        return 4;
    }

    public override void Write(BitcoinNetwork value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







public record InputType {
    
    public record BitcoinAddress (
        BitcoinAddressDetails @v1
    ) : InputType {}
    
    public record Bolt11Invoice (
        Bolt11InvoiceDetails @v1
    ) : InputType {}
    
    public record Bolt12Invoice (
        Bolt12InvoiceDetails @v1
    ) : InputType {}
    
    public record Bolt12Offer (
        Bolt12OfferDetails @v1
    ) : InputType {}
    
    public record LightningAddress (
        LightningAddressDetails @v1
    ) : InputType {}
    
    public record LnurlPay (
        LnurlPayRequestDetails @v1
    ) : InputType {}
    
    public record SilentPaymentAddress (
        SilentPaymentAddressDetails @v1
    ) : InputType {}
    
    public record LnurlAuth (
        LnurlAuthRequestDetails @v1
    ) : InputType {}
    
    public record Url (
        string @v1
    ) : InputType {}
    
    public record Bip21 (
        Bip21Details @v1
    ) : InputType {}
    
    public record Bolt12InvoiceRequest (
        Bolt12InvoiceRequestDetails @v1
    ) : InputType {}
    
    public record LnurlWithdraw (
        LnurlWithdrawRequestDetails @v1
    ) : InputType {}
    
    public record SparkAddress (
        SparkAddressDetails @v1
    ) : InputType {}
    
    public record SparkInvoice (
        SparkInvoiceDetails @v1
    ) : InputType {}
    

    
}

class FfiConverterTypeInputType : FfiConverterRustBuffer<InputType>{
    public static FfiConverterRustBuffer<InputType> INSTANCE = new FfiConverterTypeInputType();

    public override InputType Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new InputType.BitcoinAddress(
                    FfiConverterTypeBitcoinAddressDetails.INSTANCE.Read(stream)
                );
            case 2:
                return new InputType.Bolt11Invoice(
                    FfiConverterTypeBolt11InvoiceDetails.INSTANCE.Read(stream)
                );
            case 3:
                return new InputType.Bolt12Invoice(
                    FfiConverterTypeBolt12InvoiceDetails.INSTANCE.Read(stream)
                );
            case 4:
                return new InputType.Bolt12Offer(
                    FfiConverterTypeBolt12OfferDetails.INSTANCE.Read(stream)
                );
            case 5:
                return new InputType.LightningAddress(
                    FfiConverterTypeLightningAddressDetails.INSTANCE.Read(stream)
                );
            case 6:
                return new InputType.LnurlPay(
                    FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Read(stream)
                );
            case 7:
                return new InputType.SilentPaymentAddress(
                    FfiConverterTypeSilentPaymentAddressDetails.INSTANCE.Read(stream)
                );
            case 8:
                return new InputType.LnurlAuth(
                    FfiConverterTypeLnurlAuthRequestDetails.INSTANCE.Read(stream)
                );
            case 9:
                return new InputType.Url(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 10:
                return new InputType.Bip21(
                    FfiConverterTypeBip21Details.INSTANCE.Read(stream)
                );
            case 11:
                return new InputType.Bolt12InvoiceRequest(
                    FfiConverterTypeBolt12InvoiceRequestDetails.INSTANCE.Read(stream)
                );
            case 12:
                return new InputType.LnurlWithdraw(
                    FfiConverterTypeLnurlWithdrawRequestDetails.INSTANCE.Read(stream)
                );
            case 13:
                return new InputType.SparkAddress(
                    FfiConverterTypeSparkAddressDetails.INSTANCE.Read(stream)
                );
            case 14:
                return new InputType.SparkInvoice(
                    FfiConverterTypeSparkInvoiceDetails.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeInputType.Read()", value));
        }
    }

    public override int AllocationSize(InputType value) {
        switch (value) {
            case InputType.BitcoinAddress variant_value:
                return 4
                    + FfiConverterTypeBitcoinAddressDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.Bolt11Invoice variant_value:
                return 4
                    + FfiConverterTypeBolt11InvoiceDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.Bolt12Invoice variant_value:
                return 4
                    + FfiConverterTypeBolt12InvoiceDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.Bolt12Offer variant_value:
                return 4
                    + FfiConverterTypeBolt12OfferDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.LightningAddress variant_value:
                return 4
                    + FfiConverterTypeLightningAddressDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.LnurlPay variant_value:
                return 4
                    + FfiConverterTypeLnurlPayRequestDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.SilentPaymentAddress variant_value:
                return 4
                    + FfiConverterTypeSilentPaymentAddressDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.LnurlAuth variant_value:
                return 4
                    + FfiConverterTypeLnurlAuthRequestDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.Url variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.Bip21 variant_value:
                return 4
                    + FfiConverterTypeBip21Details.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.Bolt12InvoiceRequest variant_value:
                return 4
                    + FfiConverterTypeBolt12InvoiceRequestDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.LnurlWithdraw variant_value:
                return 4
                    + FfiConverterTypeLnurlWithdrawRequestDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.SparkAddress variant_value:
                return 4
                    + FfiConverterTypeSparkAddressDetails.INSTANCE.AllocationSize(variant_value.@v1);
            case InputType.SparkInvoice variant_value:
                return 4
                    + FfiConverterTypeSparkInvoiceDetails.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeInputType.AllocationSize()", value));
        }
    }

    public override void Write(InputType value, BigEndianStream stream) {
        switch (value) {
            case InputType.BitcoinAddress variant_value:
                stream.WriteInt(1);
                FfiConverterTypeBitcoinAddressDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.Bolt11Invoice variant_value:
                stream.WriteInt(2);
                FfiConverterTypeBolt11InvoiceDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.Bolt12Invoice variant_value:
                stream.WriteInt(3);
                FfiConverterTypeBolt12InvoiceDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.Bolt12Offer variant_value:
                stream.WriteInt(4);
                FfiConverterTypeBolt12OfferDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.LightningAddress variant_value:
                stream.WriteInt(5);
                FfiConverterTypeLightningAddressDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.LnurlPay variant_value:
                stream.WriteInt(6);
                FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.SilentPaymentAddress variant_value:
                stream.WriteInt(7);
                FfiConverterTypeSilentPaymentAddressDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.LnurlAuth variant_value:
                stream.WriteInt(8);
                FfiConverterTypeLnurlAuthRequestDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.Url variant_value:
                stream.WriteInt(9);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.Bip21 variant_value:
                stream.WriteInt(10);
                FfiConverterTypeBip21Details.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.Bolt12InvoiceRequest variant_value:
                stream.WriteInt(11);
                FfiConverterTypeBolt12InvoiceRequestDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.LnurlWithdraw variant_value:
                stream.WriteInt(12);
                FfiConverterTypeLnurlWithdrawRequestDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.SparkAddress variant_value:
                stream.WriteInt(13);
                FfiConverterTypeSparkAddressDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case InputType.SparkInvoice variant_value:
                stream.WriteInt(14);
                FfiConverterTypeSparkInvoiceDetails.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeInputType.Write()", value));
        }
    }
}







/// <summary>
/// Contains the result of the entire LNURL interaction, as reported by the LNURL endpoint.
///
/// * `Ok` indicates the interaction with the endpoint was valid, and the endpoint
/// - started to pay the invoice asynchronously in the case of LNURL-withdraw,
/// - verified the client signature in the case of LNURL-auth
/// * `Error` indicates a generic issue the LNURL endpoint encountered, including a freetext
/// description of the reason.
///
/// Both cases are described in LUD-03 <https://github.com/lnurl/luds/blob/luds/03.md> & LUD-04: <https://github.com/lnurl/luds/blob/luds/04.md>
/// </summary>
public record LnurlCallbackStatus {
    
    /// <summary>
    /// On-wire format is: `{"status": "OK"}`
    /// </summary>
    public record Ok: LnurlCallbackStatus {}
    
    
    /// <summary>
    /// On-wire format is: `{"status": "ERROR", "reason": "error details..."}`
    /// </summary>
    public record ErrorStatus (
        LnurlErrorDetails @errorDetails
    ) : LnurlCallbackStatus {}
    

    
}

class FfiConverterTypeLnurlCallbackStatus : FfiConverterRustBuffer<LnurlCallbackStatus>{
    public static FfiConverterRustBuffer<LnurlCallbackStatus> INSTANCE = new FfiConverterTypeLnurlCallbackStatus();

    public override LnurlCallbackStatus Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new LnurlCallbackStatus.Ok(
                );
            case 2:
                return new LnurlCallbackStatus.ErrorStatus(
                    FfiConverterTypeLnurlErrorDetails.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeLnurlCallbackStatus.Read()", value));
        }
    }

    public override int AllocationSize(LnurlCallbackStatus value) {
        switch (value) {
            case LnurlCallbackStatus.Ok variant_value:
                return 4;
            case LnurlCallbackStatus.ErrorStatus variant_value:
                return 4
                    + FfiConverterTypeLnurlErrorDetails.INSTANCE.AllocationSize(variant_value.@errorDetails);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeLnurlCallbackStatus.AllocationSize()", value));
        }
    }

    public override void Write(LnurlCallbackStatus value, BigEndianStream stream) {
        switch (value) {
            case LnurlCallbackStatus.Ok variant_value:
                stream.WriteInt(1);
                break;
            case LnurlCallbackStatus.ErrorStatus variant_value:
                stream.WriteInt(2);
                FfiConverterTypeLnurlErrorDetails.INSTANCE.Write(variant_value.@errorDetails, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeLnurlCallbackStatus.Write()", value));
        }
    }
}







public class ServiceConnectivityException: UniffiException {
    ServiceConnectivityException() : base() {}
    ServiceConnectivityException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class Builder : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Builder(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Redirect : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Redirect(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Status : ServiceConnectivityException {
        // Members
        public ushort @status;
        public string @body;

        // Constructor
        public Status(
                ushort @status, 
                string @body) : base(
                "@status" + "=" + @status+ ", " +
                "@body" + "=" + @body) {

            this.@status = @status;

            this.@body = @body;
        }
    }
    
    
    public class Timeout : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Timeout(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Request : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Request(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Connect : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Connect(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Body : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Body(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Decode : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Decode(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Json : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Json(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Other : ServiceConnectivityException {
        // Members
        public string @v1;

        // Constructor
        public Other(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    

    
}

class FfiConverterTypeServiceConnectivityError : FfiConverterRustBuffer<ServiceConnectivityException>, CallStatusErrorHandler<ServiceConnectivityException> {
    public static FfiConverterTypeServiceConnectivityError INSTANCE = new FfiConverterTypeServiceConnectivityError();

    public override ServiceConnectivityException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new ServiceConnectivityException.Builder(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new ServiceConnectivityException.Redirect(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new ServiceConnectivityException.Status(
                    FfiConverterUInt16.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new ServiceConnectivityException.Timeout(
                    FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new ServiceConnectivityException.Request(
                    FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new ServiceConnectivityException.Connect(
                    FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new ServiceConnectivityException.Body(
                    FfiConverterString.INSTANCE.Read(stream));
            case 8:
                return new ServiceConnectivityException.Decode(
                    FfiConverterString.INSTANCE.Read(stream));
            case 9:
                return new ServiceConnectivityException.Json(
                    FfiConverterString.INSTANCE.Read(stream));
            case 10:
                return new ServiceConnectivityException.Other(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeServiceConnectivityError.Read()", value));
        }
    }

    public override int AllocationSize(ServiceConnectivityException value) {
        switch (value) {

            case ServiceConnectivityException.Builder variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Redirect variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Status variant_value:
                return 4
                    + FfiConverterUInt16.INSTANCE.AllocationSize(variant_value.@status)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@body);

            case ServiceConnectivityException.Timeout variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Request variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Connect variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Body variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Decode variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Json variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ServiceConnectivityException.Other variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeServiceConnectivityError.AllocationSize()", value));
        }
    }

    public override void Write(ServiceConnectivityException value, BigEndianStream stream) {
        switch (value) {
            case ServiceConnectivityException.Builder variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Redirect variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Status variant_value:
                stream.WriteInt(3);
                FfiConverterUInt16.INSTANCE.Write(variant_value.@status, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@body, stream);
                break;
            case ServiceConnectivityException.Timeout variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Request variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Connect variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Body variant_value:
                stream.WriteInt(7);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Decode variant_value:
                stream.WriteInt(8);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Json variant_value:
                stream.WriteInt(9);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ServiceConnectivityException.Other variant_value:
                stream.WriteInt(10);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeServiceConnectivityError.Write()", value));
        }
    }
}





/// <summary>
/// Supported success action types
///
/// Receiving any other (unsupported) success action type will result in a failed parsing,
/// which will abort the LNURL-pay workflow, as per LUD-09.
/// </summary>
public record SuccessAction {
    
    /// <summary>
    /// AES type, described in LUD-10
    /// </summary>
    public record Aes (
        AesSuccessActionData @data
    ) : SuccessAction {}
    
    /// <summary>
    /// Message type, described in LUD-09
    /// </summary>
    public record Message (
        MessageSuccessActionData @data
    ) : SuccessAction {}
    
    /// <summary>
    /// URL type, described in LUD-09
    /// </summary>
    public record Url (
        UrlSuccessActionData @data
    ) : SuccessAction {}
    

    
}

class FfiConverterTypeSuccessAction : FfiConverterRustBuffer<SuccessAction>{
    public static FfiConverterRustBuffer<SuccessAction> INSTANCE = new FfiConverterTypeSuccessAction();

    public override SuccessAction Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SuccessAction.Aes(
                    FfiConverterTypeAesSuccessActionData.INSTANCE.Read(stream)
                );
            case 2:
                return new SuccessAction.Message(
                    FfiConverterTypeMessageSuccessActionData.INSTANCE.Read(stream)
                );
            case 3:
                return new SuccessAction.Url(
                    FfiConverterTypeUrlSuccessActionData.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSuccessAction.Read()", value));
        }
    }

    public override int AllocationSize(SuccessAction value) {
        switch (value) {
            case SuccessAction.Aes variant_value:
                return 4
                    + FfiConverterTypeAesSuccessActionData.INSTANCE.AllocationSize(variant_value.@data);
            case SuccessAction.Message variant_value:
                return 4
                    + FfiConverterTypeMessageSuccessActionData.INSTANCE.AllocationSize(variant_value.@data);
            case SuccessAction.Url variant_value:
                return 4
                    + FfiConverterTypeUrlSuccessActionData.INSTANCE.AllocationSize(variant_value.@data);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSuccessAction.AllocationSize()", value));
        }
    }

    public override void Write(SuccessAction value, BigEndianStream stream) {
        switch (value) {
            case SuccessAction.Aes variant_value:
                stream.WriteInt(1);
                FfiConverterTypeAesSuccessActionData.INSTANCE.Write(variant_value.@data, stream);
                break;
            case SuccessAction.Message variant_value:
                stream.WriteInt(2);
                FfiConverterTypeMessageSuccessActionData.INSTANCE.Write(variant_value.@data, stream);
                break;
            case SuccessAction.Url variant_value:
                stream.WriteInt(3);
                FfiConverterTypeUrlSuccessActionData.INSTANCE.Write(variant_value.@data, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSuccessAction.Write()", value));
        }
    }
}







/// <summary>
/// [`SuccessAction`] where contents are ready to be consumed by the caller
///
/// Contents are identical to [`SuccessAction`], except for AES where the ciphertext is decrypted.
/// </summary>
public record SuccessActionProcessed {
    
    /// <summary>
    /// See [`SuccessAction::Aes`] for received payload
    ///
    /// See [`AesSuccessActionDataDecrypted`] for decrypted payload
    /// </summary>
    public record Aes (
        AesSuccessActionDataResult @result
    ) : SuccessActionProcessed {}
    
    /// <summary>
    /// See [`SuccessAction::Message`]
    /// </summary>
    public record Message (
        MessageSuccessActionData @data
    ) : SuccessActionProcessed {}
    
    /// <summary>
    /// See [`SuccessAction::Url`]
    /// </summary>
    public record Url (
        UrlSuccessActionData @data
    ) : SuccessActionProcessed {}
    

    
}

class FfiConverterTypeSuccessActionProcessed : FfiConverterRustBuffer<SuccessActionProcessed>{
    public static FfiConverterRustBuffer<SuccessActionProcessed> INSTANCE = new FfiConverterTypeSuccessActionProcessed();

    public override SuccessActionProcessed Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SuccessActionProcessed.Aes(
                    FfiConverterTypeAesSuccessActionDataResult.INSTANCE.Read(stream)
                );
            case 2:
                return new SuccessActionProcessed.Message(
                    FfiConverterTypeMessageSuccessActionData.INSTANCE.Read(stream)
                );
            case 3:
                return new SuccessActionProcessed.Url(
                    FfiConverterTypeUrlSuccessActionData.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSuccessActionProcessed.Read()", value));
        }
    }

    public override int AllocationSize(SuccessActionProcessed value) {
        switch (value) {
            case SuccessActionProcessed.Aes variant_value:
                return 4
                    + FfiConverterTypeAesSuccessActionDataResult.INSTANCE.AllocationSize(variant_value.@result);
            case SuccessActionProcessed.Message variant_value:
                return 4
                    + FfiConverterTypeMessageSuccessActionData.INSTANCE.AllocationSize(variant_value.@data);
            case SuccessActionProcessed.Url variant_value:
                return 4
                    + FfiConverterTypeUrlSuccessActionData.INSTANCE.AllocationSize(variant_value.@data);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSuccessActionProcessed.AllocationSize()", value));
        }
    }

    public override void Write(SuccessActionProcessed value, BigEndianStream stream) {
        switch (value) {
            case SuccessActionProcessed.Aes variant_value:
                stream.WriteInt(1);
                FfiConverterTypeAesSuccessActionDataResult.INSTANCE.Write(variant_value.@result, stream);
                break;
            case SuccessActionProcessed.Message variant_value:
                stream.WriteInt(2);
                FfiConverterTypeMessageSuccessActionData.INSTANCE.Write(variant_value.@data, stream);
                break;
            case SuccessActionProcessed.Url variant_value:
                stream.WriteInt(3);
                FfiConverterTypeUrlSuccessActionData.INSTANCE.Write(variant_value.@data, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSuccessActionProcessed.Write()", value));
        }
    }
}







/// <summary>
/// Errors that can occur during storage operations
/// </summary>
public class SyncStorageException: UniffiException {
    SyncStorageException() : base() {}
    SyncStorageException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class Implementation : SyncStorageException {
        // Members
        public string @v1;

        // Constructor
        public Implementation(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    /// <summary>
    /// Database initialization error
    /// </summary>
    
    public class InitializationException : SyncStorageException {
        // Members
        public string @v1;

        // Constructor
        public InitializationException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Serialization : SyncStorageException {
        // Members
        public string @v1;

        // Constructor
        public Serialization(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    

    
}

class FfiConverterTypeSyncStorageError : FfiConverterRustBuffer<SyncStorageException>, CallStatusErrorHandler<SyncStorageException> {
    public static FfiConverterTypeSyncStorageError INSTANCE = new FfiConverterTypeSyncStorageError();

    public override SyncStorageException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SyncStorageException.Implementation(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new SyncStorageException.InitializationException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new SyncStorageException.Serialization(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSyncStorageError.Read()", value));
        }
    }

    public override int AllocationSize(SyncStorageException value) {
        switch (value) {

            case SyncStorageException.Implementation variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SyncStorageException.InitializationException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SyncStorageException.Serialization variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSyncStorageError.AllocationSize()", value));
        }
    }

    public override void Write(SyncStorageException value, BigEndianStream stream) {
        switch (value) {
            case SyncStorageException.Implementation variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SyncStorageException.InitializationException variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SyncStorageException.Serialization variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSyncStorageError.Write()", value));
        }
    }
}




class FfiConverterOptionalUInt32: FfiConverterRustBuffer<uint?> {
    public static FfiConverterOptionalUInt32 INSTANCE = new FfiConverterOptionalUInt32();

    public override uint? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(uint? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt32.INSTANCE.AllocationSize((uint)value);
        }
    }

    public override void Write(uint? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt32.INSTANCE.Write((uint)value, stream);
        }
    }
}




class FfiConverterOptionalUInt64: FfiConverterRustBuffer<ulong?> {
    public static FfiConverterOptionalUInt64 INSTANCE = new FfiConverterOptionalUInt64();

    public override ulong? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ulong? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt64.INSTANCE.AllocationSize((ulong)value);
        }
    }

    public override void Write(ulong? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt64.INSTANCE.Write((ulong)value, stream);
        }
    }
}




class FfiConverterOptionalBoolean: FfiConverterRustBuffer<bool?> {
    public static FfiConverterOptionalBoolean INSTANCE = new FfiConverterOptionalBoolean();

    public override bool? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterBoolean.INSTANCE.Read(stream);
    }

    public override int AllocationSize(bool? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterBoolean.INSTANCE.AllocationSize((bool)value);
        }
    }

    public override void Write(bool? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterBoolean.INSTANCE.Write((bool)value, stream);
        }
    }
}




class FfiConverterOptionalString: FfiConverterRustBuffer<string?> {
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}




class FfiConverterOptionalTypeOutgoingChange: FfiConverterRustBuffer<OutgoingChange?> {
    public static FfiConverterOptionalTypeOutgoingChange INSTANCE = new FfiConverterOptionalTypeOutgoingChange();

    public override OutgoingChange? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeOutgoingChange.INSTANCE.Read(stream);
    }

    public override int AllocationSize(OutgoingChange? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeOutgoingChange.INSTANCE.AllocationSize((OutgoingChange)value);
        }
    }

    public override void Write(OutgoingChange? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeOutgoingChange.INSTANCE.Write((OutgoingChange)value, stream);
        }
    }
}




class FfiConverterOptionalTypeRecord: FfiConverterRustBuffer<Record?> {
    public static FfiConverterOptionalTypeRecord INSTANCE = new FfiConverterOptionalTypeRecord();

    public override Record? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeRecord.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Record? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeRecord.INSTANCE.AllocationSize((Record)value);
        }
    }

    public override void Write(Record? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeRecord.INSTANCE.Write((Record)value, stream);
        }
    }
}




class FfiConverterOptionalTypeSymbol: FfiConverterRustBuffer<Symbol?> {
    public static FfiConverterOptionalTypeSymbol INSTANCE = new FfiConverterOptionalTypeSymbol();

    public override Symbol? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeSymbol.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Symbol? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeSymbol.INSTANCE.AllocationSize((Symbol)value);
        }
    }

    public override void Write(Symbol? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeSymbol.INSTANCE.Write((Symbol)value, stream);
        }
    }
}




class FfiConverterOptionalTypeAmount: FfiConverterRustBuffer<Amount?> {
    public static FfiConverterOptionalTypeAmount INSTANCE = new FfiConverterOptionalTypeAmount();

    public override Amount? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeAmount.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Amount? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeAmount.INSTANCE.AllocationSize((Amount)value);
        }
    }

    public override void Write(Amount? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeAmount.INSTANCE.Write((Amount)value, stream);
        }
    }
}




class FfiConverterOptionalDictionaryStringString: FfiConverterRustBuffer<Dictionary<string, string>?> {
    public static FfiConverterOptionalDictionaryStringString INSTANCE = new FfiConverterOptionalDictionaryStringString();

    public override Dictionary<string, string>? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterDictionaryStringString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Dictionary<string, string>? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterDictionaryStringString.INSTANCE.AllocationSize((Dictionary<string, string>)value);
        }
    }

    public override void Write(Dictionary<string, string>? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterDictionaryStringString.INSTANCE.Write((Dictionary<string, string>)value, stream);
        }
    }
}




class FfiConverterOptionalTypecommon_u128: FfiConverterRustBuffer<common_u128?> {
    public static FfiConverterOptionalTypecommon_u128 INSTANCE = new FfiConverterOptionalTypecommon_u128();

    public override common_u128? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypecommon_u128.INSTANCE.Read(stream);
    }

    public override int AllocationSize(common_u128? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypecommon_u128.INSTANCE.AllocationSize((common_u128)value);
        }
    }

    public override void Write(common_u128? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypecommon_u128.INSTANCE.Write((common_u128)value, stream);
        }
    }
}




class FfiConverterSequenceString: FfiConverterRustBuffer<List<string>> {
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override List<string> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<string>(length);
        var readFn = FfiConverterString.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<string> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<string> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterString.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeBip21Extra: FfiConverterRustBuffer<List<Bip21Extra>> {
    public static FfiConverterSequenceTypeBip21Extra INSTANCE = new FfiConverterSequenceTypeBip21Extra();

    public override List<Bip21Extra> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Bip21Extra>(length);
        var readFn = FfiConverterTypeBip21Extra.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Bip21Extra> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeBip21Extra.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Bip21Extra> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeBip21Extra.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeBolt11RouteHint: FfiConverterRustBuffer<List<Bolt11RouteHint>> {
    public static FfiConverterSequenceTypeBolt11RouteHint INSTANCE = new FfiConverterSequenceTypeBolt11RouteHint();

    public override List<Bolt11RouteHint> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Bolt11RouteHint>(length);
        var readFn = FfiConverterTypeBolt11RouteHint.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Bolt11RouteHint> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeBolt11RouteHint.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Bolt11RouteHint> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeBolt11RouteHint.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeBolt11RouteHintHop: FfiConverterRustBuffer<List<Bolt11RouteHintHop>> {
    public static FfiConverterSequenceTypeBolt11RouteHintHop INSTANCE = new FfiConverterSequenceTypeBolt11RouteHintHop();

    public override List<Bolt11RouteHintHop> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Bolt11RouteHintHop>(length);
        var readFn = FfiConverterTypeBolt11RouteHintHop.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Bolt11RouteHintHop> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeBolt11RouteHintHop.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Bolt11RouteHintHop> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeBolt11RouteHintHop.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeBolt12OfferBlindedPath: FfiConverterRustBuffer<List<Bolt12OfferBlindedPath>> {
    public static FfiConverterSequenceTypeBolt12OfferBlindedPath INSTANCE = new FfiConverterSequenceTypeBolt12OfferBlindedPath();

    public override List<Bolt12OfferBlindedPath> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Bolt12OfferBlindedPath>(length);
        var readFn = FfiConverterTypeBolt12OfferBlindedPath.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Bolt12OfferBlindedPath> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeBolt12OfferBlindedPath.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Bolt12OfferBlindedPath> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeBolt12OfferBlindedPath.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer<List<FiatCurrency>> {
    public static FfiConverterSequenceTypeFiatCurrency INSTANCE = new FfiConverterSequenceTypeFiatCurrency();

    public override List<FiatCurrency> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<FiatCurrency>(length);
        var readFn = FfiConverterTypeFiatCurrency.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<FiatCurrency> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeFiatCurrency.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<FiatCurrency> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeFiatCurrency.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeIncomingChange: FfiConverterRustBuffer<List<IncomingChange>> {
    public static FfiConverterSequenceTypeIncomingChange INSTANCE = new FfiConverterSequenceTypeIncomingChange();

    public override List<IncomingChange> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<IncomingChange>(length);
        var readFn = FfiConverterTypeIncomingChange.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<IncomingChange> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeIncomingChange.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<IncomingChange> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeIncomingChange.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeLocaleOverrides: FfiConverterRustBuffer<List<LocaleOverrides>> {
    public static FfiConverterSequenceTypeLocaleOverrides INSTANCE = new FfiConverterSequenceTypeLocaleOverrides();

    public override List<LocaleOverrides> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<LocaleOverrides>(length);
        var readFn = FfiConverterTypeLocaleOverrides.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<LocaleOverrides> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeLocaleOverrides.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<LocaleOverrides> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeLocaleOverrides.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeLocalizedName: FfiConverterRustBuffer<List<LocalizedName>> {
    public static FfiConverterSequenceTypeLocalizedName INSTANCE = new FfiConverterSequenceTypeLocalizedName();

    public override List<LocalizedName> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<LocalizedName>(length);
        var readFn = FfiConverterTypeLocalizedName.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<LocalizedName> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeLocalizedName.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<LocalizedName> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeLocalizedName.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeOutgoingChange: FfiConverterRustBuffer<List<OutgoingChange>> {
    public static FfiConverterSequenceTypeOutgoingChange INSTANCE = new FfiConverterSequenceTypeOutgoingChange();

    public override List<OutgoingChange> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<OutgoingChange>(length);
        var readFn = FfiConverterTypeOutgoingChange.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<OutgoingChange> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeOutgoingChange.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<OutgoingChange> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeOutgoingChange.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeRate: FfiConverterRustBuffer<List<Rate>> {
    public static FfiConverterSequenceTypeRate INSTANCE = new FfiConverterSequenceTypeRate();

    public override List<Rate> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Rate>(length);
        var readFn = FfiConverterTypeRate.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Rate> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeRate.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Rate> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeRate.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeRecord: FfiConverterRustBuffer<List<Record>> {
    public static FfiConverterSequenceTypeRecord INSTANCE = new FfiConverterSequenceTypeRecord();

    public override List<Record> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Record>(length);
        var readFn = FfiConverterTypeRecord.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Record> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeRecord.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Record> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeRecord.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeInputType: FfiConverterRustBuffer<List<InputType>> {
    public static FfiConverterSequenceTypeInputType INSTANCE = new FfiConverterSequenceTypeInputType();

    public override List<InputType> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<InputType>(length);
        var readFn = FfiConverterTypeInputType.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<InputType> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeInputType.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<InputType> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeInputType.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterDictionaryStringString: FfiConverterRustBuffer<Dictionary<string, string>> {
    public static FfiConverterDictionaryStringString INSTANCE = new FfiConverterDictionaryStringString();

    public override Dictionary<string, string> Read(BigEndianStream stream) {
        var len = stream.ReadInt();
        var result = new Dictionary<string, string>(len);
        var readerKey = FfiConverterString.INSTANCE.Read;
        var readerValue = FfiConverterString.INSTANCE.Read;
        for (int i = 0; i < len; i++) {
            var key = readerKey(stream);
            var value = readerValue(stream);
            result[key] = value;
        }

        return result;
    }

    public override int AllocationSize(Dictionary<string, string> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationKeySizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var allocationKValueSizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationKeySizeFn(item.Key) + allocationKValueSizeFn(item.Value));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, string> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerKey = FfiConverterString.INSTANCE.Write;
        var writerValue = FfiConverterString.INSTANCE.Write;
        foreach (var item in value) {
            writerKey(item.Key, stream);
            writerValue(item.Value, stream);
        }
    }
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */







[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
delegate void UniFfiFutureCallback(IntPtr continuationHandle, byte pollResult);

internal static class _UniFFIAsync {
    internal const byte UNIFFI_RUST_FUTURE_POLL_READY = 0;
    // internal const byte UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1;

    internal static ConcurrentHandleMap<TaskCompletionSource<byte>> _async_handle_map = new ConcurrentHandleMap<TaskCompletionSource<byte>>();
    public static ConcurrentHandleMap<CancellationTokenSource> _foreign_futures_map = new ConcurrentHandleMap<CancellationTokenSource>();

    // FFI type for Rust future continuations
    internal class UniffiRustFutureContinuationCallback
    {
        public static UniFfiFutureCallback callback = Callback;

        public static void Callback(IntPtr continuationHandle, byte pollResult)
        {
            if (_async_handle_map.Remove((ulong)continuationHandle.ToInt64(), out TaskCompletionSource<byte> task))
            {
                task.SetResult(pollResult);
            }
            else 
            {
                throw new InternalException($"Unable to find continuation handle: {continuationHandle}");
            }
        }
    }

    public class UniffiForeignFutureFreeCallback
    {
        public static _UniFFILib.UniffiForeignFutureFree callback = Callback;

        public static void Callback(ulong handle)
        {
            if (_foreign_futures_map.Remove(handle, out CancellationTokenSource task))
            {
                task.Cancel();
            }
            else
            {
                throw new InternalException($"Unable to find cancellation token: {handle}");
            }
        }
    }

    public delegate F CompleteFuncDelegate<F>(IntPtr ptr, ref UniffiRustCallStatus status);

    public delegate void CompleteActionDelegate(IntPtr ptr, ref UniffiRustCallStatus status);

    private static async Task PollFuture(IntPtr rustFuture, Action<IntPtr, IntPtr, IntPtr> pollFunc)
    {
        byte pollResult;
        do 
        {
            var tcs = new TaskCompletionSource<byte>(TaskCreationOptions.RunContinuationsAsynchronously);
            IntPtr callback = Marshal.GetFunctionPointerForDelegate(UniffiRustFutureContinuationCallback.callback);
            ulong mapEntry = _async_handle_map.Insert(tcs);
            pollFunc(rustFuture, callback, (IntPtr)mapEntry);
            pollResult = await tcs.Task;
        }
        while(pollResult != UNIFFI_RUST_FUTURE_POLL_READY);
    }

    public static async Task<T> UniffiRustCallAsync<T, F, E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteFuncDelegate<F> completeFunc,
        Action<IntPtr> freeFunc,
        Func<F, T> liftFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
        try {
            await PollFuture(rustFuture, pollFunc);
            var result = _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));
            return liftFunc(result);
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }

    public static async Task UniffiRustCallAsync<E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteActionDelegate completeFunc,
        Action<IntPtr> freeFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
         try {
            await PollFuture(rustFuture, pollFunc);
            _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));

        }
        finally
        {
            freeFunc(rustFuture);
        }
    }
}
#pragma warning restore 8625
public static class BreezSdkCommonMethods {
}

