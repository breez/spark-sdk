// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.2+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using Breez.Sdk.Spark.Common;
namespace Breez.Sdk.Spark;
using FfiConverterTypeu128 = FfiConverterString;
using u128 = String;



// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer {
    public ulong capacity;
    public ulong len;
    public IntPtr data;

    public static RustBuffer Alloc(int size) {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            var buffer = _UniFFILib.ffi_breez_sdk_spark_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
            if (buffer.data == IntPtr.Zero) {
                throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
            }
            return buffer;
        });
    }

    public static void Free(RustBuffer buffer) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.ffi_breez_sdk_spark_rustbuffer_free(buffer, ref status);
        });
    }

    public static BigEndianStream MemoryStream(IntPtr data, long length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
            );
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    Convert.ToInt64(capacity),
                    Convert.ToInt64(capacity),
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes {
    public int length;
    public IntPtr data;
}


// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType> {
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value) {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToUInt64(stream.Position);
            return rbuf;
        } catch {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf) {
        var stream = rbuf.AsStream();
        try {
           var item = Read(stream);
           if (stream.HasRemaining()) {
               throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
           }
           return item;
        } finally {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType>: FfiConverter<CsType, RustBuffer> {
    public override CsType Lift(RustBuffer value) {
        return LiftFromRustBuffer(value);
    }
    public override RustBuffer Lower(CsType value) {
        return LowerIntoRustBuffer(value);
    }
}


// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct UniffiRustCallStatus {
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess() {
        return code == 0;
    }

    public bool IsError() {
        return code == 1;
    }

    public bool IsPanic() {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
public class UniffiException: System.Exception {
    public UniffiException(): base() {}
    public UniffiException(string message): base(message) {}
}

public class UndeclaredErrorException: UniffiException {
    public UndeclaredErrorException(string message): base(message) {}
}

public class PanicException: UniffiException {
    public PanicException(string message): base(message) {}
}

public class AllocationException: UniffiException {
    public AllocationException(string message): base(message) {}
}

public class InternalException: UniffiException {
    public InternalException(string message): base(message) {}
}

public class InvalidEnumException: InternalException {
    public InvalidEnumException(string message): base(message) {
    }
}

public class UniffiContractVersionException: UniffiException {
    public UniffiContractVersionException(string message): base(message) {
    }
}

public class UniffiContractChecksumException: UniffiException {
    public UniffiContractChecksumException(string message): base(message) {
    }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E> where E: System.Exception {
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler: CallStatusErrorHandler<UniffiException> {
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf) {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers {
    public delegate void RustCallAction(ref UniffiRustCallStatus status);
    public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
        where E: UniffiException
    {
        var status = new UniffiRustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess()) {
            return return_value;
        } else if (status.IsError()) {
            throw errorHandler.Lift(status.error_buf);
        } else if (status.IsPanic()) {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0) {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            } else {
                throw new PanicException("Rust panic");
            }
        } else {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
        where E: UniffiException
    {
        _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback) {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback) {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            callback(ref status);
            return 0;
        });
    }
}

static class FFIObjectUtil {
    public static void DisposeAll(params Object?[] list) {
        foreach (var obj in list) {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
   private static void Dispose(Object? obj) {
         if (obj == null) {
             return;
         }

         if (obj is IDisposable disposable) {
             disposable.Dispose();
             return;
         }

         var objType = obj.GetType();
         var typeCode = Type.GetTypeCode(objType);
         if (typeCode != TypeCode.Object) {
             return;
         }

         var genericArguments = objType.GetGenericArguments();
         if (genericArguments.Length == 0) {
             return;
         }

         if (obj is System.Collections.IDictionary objDictionary) {
            //This extra code tests to not call "Dispose" for a Dictionary<something, double>()
            //for all keys as "double" and alike doesn't support interface "IDisposable"
             var valuesType = objType.GetGenericArguments()[1];
             var elementValuesTypeCode = Type.GetTypeCode(valuesType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in objDictionary.Values) {
                 Dispose(value);
             }
         }
         else if (obj is System.Collections.IEnumerable listValues) {
            //This extra code tests to not call "Dispose" for a List<int>()
            //for all keys as "int" and alike doesn't support interface "IDisposable"
             var valuesType = objType.GetGenericArguments()[0];
             var elementValuesTypeCode = Type.GetTypeCode(valuesType);
             if (elementValuesTypeCode != TypeCode.Object) {
                 return;
             }
             foreach (var value in listValues) {
                 Dispose(value);
             }
         }
     }
}


// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException: System.Exception {
    public StreamUnderflowException() {
    }
}

static class BigEndianStreamExtensions
{
    public static void WriteInt32(this Stream stream, int value, int bytesToWrite = 4)
    {
#if DOTNET_8_0_OR_GREATER
        Span<byte> buffer = stackalloc byte[bytesToWrite];
#else
        byte[] buffer = new byte[bytesToWrite];
#endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static void WriteInt64(this Stream stream, long value)
    {
        int bytesToWrite = 8;
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToWrite];
 #else
         byte[] buffer = new byte[bytesToWrite];
 #endif
        var posByte = bytesToWrite;
        while (posByte != 0)
        {
            posByte--;
            buffer[posByte] = (byte)(value);
            value >>= 8;
        }

#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public static uint ReadUint32(this Stream stream, int bytesToRead = 4) {
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        uint result = 0;
        uint digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static ulong ReadUInt64(this Stream stream) {
        int bytesToRead = 8;
        CheckRemaining(stream, bytesToRead);
#if DOTNET_8_0_OR_GREATER
         Span<byte> buffer = stackalloc byte[bytesToRead];
         stream.Read(buffer);
#else
        byte[] buffer = new byte[bytesToRead];
        stream.Read(buffer, 0, bytesToRead);
#endif
        ulong result = 0;
        ulong digitMultiplier = 1;
        int posByte = bytesToRead;
        while (posByte != 0)
        {
            posByte--;
            result |= buffer[posByte]*digitMultiplier;
            digitMultiplier <<= 8;
        }

        return result;
    }

    public static void CheckRemaining(this Stream stream, int length) {
        if (stream.Length - stream.Position < length) {
            throw new StreamUnderflowException();
        }
    }
}

class BigEndianStream {
    Stream stream;
    public BigEndianStream(Stream stream) {
        this.stream = stream;
    }

    public bool HasRemaining() {
        return (stream.Length - Position) > 0;
    }

    public long Position {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] buffer) {
#if DOTNET_8_0_OR_GREATER
        stream.Write(buffer);
#else
        stream.Write(buffer, 0, buffer.Length);
#endif
    }

    public void WriteByte(byte value) => stream.WriteInt32(value, bytesToWrite: 1);
    public void WriteSByte(sbyte value) => stream.WriteInt32(value, bytesToWrite: 1);

    public void WriteUShort(ushort value) => stream.WriteInt32(value, bytesToWrite: 2);
    public void WriteShort(short value) => stream.WriteInt32(value, bytesToWrite: 2);

    public void WriteUInt(uint value) => stream.WriteInt32((int)value);
    public void WriteInt(int value) => stream.WriteInt32(value);

    public void WriteULong(ulong value) => stream.WriteInt64((long)value);
    public void WriteLong(long value) => stream.WriteInt64(value);

    public void WriteFloat(float value) {
        unsafe {
            WriteInt(*((int*)&value));
        }
    }
    public void WriteDouble(double value) => stream.WriteInt64(BitConverter.DoubleToInt64Bits(value));

    public byte[] ReadBytes(int length) {
        stream.CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte() => (byte)stream.ReadUint32(bytesToRead: 1);
    public ushort ReadUShort() => (ushort)stream.ReadUint32(bytesToRead: 2);
    public uint ReadUInt() => (uint)stream.ReadUint32(bytesToRead: 4);
    public ulong ReadULong() => stream.ReadUInt64();

    public sbyte ReadSByte() => (sbyte)ReadByte();
    public short ReadShort() => (short)ReadUShort();
    public int ReadInt() => (int)ReadUInt();

    public float ReadFloat() {
        unsafe {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong() => (long)ReadULong();
    public double ReadDouble() => BitConverter.Int64BitsToDouble(ReadLong());
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail that will be called internally by the public API.
static class _UniFFILib {
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiRustFutureContinuationCallback(
        ulong @data,sbyte @pollResult
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureFree(
        ulong @handle
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceFree(
        ulong @handle
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFuture
    {
        public ulong @handle;
        public IntPtr @free;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU8
    {
        public byte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI8
    {
        public sbyte @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI8(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI8 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU16
    {
        public ushort @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI16
    {
        public short @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI16(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI16 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU32
    {
        public uint @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI32
    {
        public int @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructU64
    {
        public ulong @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteU64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructU64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructI64
    {
        public long @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteI64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructI64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF32
    {
        public float @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF32(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF32 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructF64
    {
        public double @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteF64(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructF64 @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructPointer
    {
        public IntPtr @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompletePointer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructPointer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructRustBuffer
    {
        public RustBuffer @returnValue;
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteRustBuffer(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructRustBuffer @result
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiForeignFutureStructVoid
    {
        public UniffiRustCallStatus @callStatus;
    }
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiForeignFutureCompleteVoid(
        ulong @callbackData,_UniFFILib.UniffiForeignFutureStructVoid @result
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceEventListenerMethod0(
        ulong @uniffiHandle,RustBuffer @event,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceLoggerMethod0(
        ulong @uniffiHandle,RustBuffer @l,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceBitcoinChainServiceMethod0(
        ulong @uniffiHandle,RustBuffer @address,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceBitcoinChainServiceMethod1(
        ulong @uniffiHandle,RustBuffer @txid,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceBitcoinChainServiceMethod2(
        ulong @uniffiHandle,RustBuffer @txid,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceBitcoinChainServiceMethod3(
        ulong @uniffiHandle,RustBuffer @tx,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfacePaymentObserverMethod0(
        ulong @uniffiHandle,RustBuffer @payments,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod0(
        ulong @uniffiHandle,RustBuffer @key,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod1(
        ulong @uniffiHandle,RustBuffer @key,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod2(
        ulong @uniffiHandle,RustBuffer @key,RustBuffer @value,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod3(
        ulong @uniffiHandle,RustBuffer @request,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod4(
        ulong @uniffiHandle,RustBuffer @payment,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod5(
        ulong @uniffiHandle,RustBuffer @paymentId,RustBuffer @metadata,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod6(
        ulong @uniffiHandle,RustBuffer @id,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod7(
        ulong @uniffiHandle,RustBuffer @invoice,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod8(
        ulong @uniffiHandle,RustBuffer @txid,uint @vout,ulong @amountSats,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod9(
        ulong @uniffiHandle,RustBuffer @txid,uint @vout,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod10(
        ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void UniffiCallbackInterfaceStorageMethod11(
        ulong @uniffiHandle,RustBuffer @txid,uint @vout,RustBuffer @payload,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn
    );
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceEventListener
    {
        public IntPtr @onEvent;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceLogger
    {
        public IntPtr @log;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceBitcoinChainService
    {
        public IntPtr @getAddressUtxos;
        public IntPtr @getTransactionStatus;
        public IntPtr @getTransactionHex;
        public IntPtr @broadcastTransaction;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfacePaymentObserver
    {
        public IntPtr @beforeSend;
        public IntPtr @uniffiFree;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct UniffiVTableCallbackInterfaceStorage
    {
        public IntPtr @deleteCachedItem;
        public IntPtr @getCachedItem;
        public IntPtr @setCachedItem;
        public IntPtr @listPayments;
        public IntPtr @insertPayment;
        public IntPtr @setPaymentMetadata;
        public IntPtr @getPaymentById;
        public IntPtr @getPaymentByInvoice;
        public IntPtr @addDeposit;
        public IntPtr @deleteDeposit;
        public IntPtr @listDeposits;
        public IntPtr @updateDeposit;
        public IntPtr @uniffiFree;
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    static _UniFFILib() {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();
        
        UniffiCallbackInterfaceBitcoinChainService.Register();
        UniffiCallbackInterfacePaymentObserver.Register();
        UniffiCallbackInterfaceStorage.Register();
        UniffiCallbackInterfaceEventListener.Register();
        UniffiCallbackInterfaceLogger.Register();
        }

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfaceBitcoinChainService*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(IntPtr @ptr,RustBuffer @address
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(IntPtr @ptr,RustBuffer @txid
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(IntPtr @ptr,RustBuffer @txid
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(IntPtr @ptr,RustBuffer @tx
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_clone_breezsdk(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_free_breezsdk(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(IntPtr @ptr,ulong @listener
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(IntPtr @ptr,RustBuffer @req
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_parse(IntPtr @ptr,RustBuffer @input
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(IntPtr @ptr,RustBuffer @id
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_breezsdk_wait_for_payment(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_clone_paymentobserver(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_free_paymentobserver(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfacePaymentObserver*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(IntPtr @ptr,RustBuffer @payments
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_clone_sdkbuilder(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_free_sdkbuilder(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(RustBuffer @config,RustBuffer @seed,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(IntPtr @ptr,IntPtr @chainService
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(IntPtr @ptr,RustBuffer @storageDir
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(IntPtr @ptr,IntPtr @fiatService
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(IntPtr @ptr,RustBuffer @keySetType,sbyte @useAddressIndex,RustBuffer @accountNumber
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(IntPtr @ptr,IntPtr @lnurlClient
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(IntPtr @ptr,IntPtr @paymentObserver
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(IntPtr @ptr,IntPtr @storage
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(IntPtr @ptr,RustBuffer @url,RustBuffer @credentials
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(IntPtr @ptr,IntPtr @storage
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_clone_storage(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_free_storage(IntPtr @ptr,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfaceStorage*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(IntPtr @ptr,RustBuffer @key
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(IntPtr @ptr,RustBuffer @key
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(IntPtr @ptr,RustBuffer @key,RustBuffer @value
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_list_payments(IntPtr @ptr,RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_insert_payment(IntPtr @ptr,RustBuffer @payment
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(IntPtr @ptr,RustBuffer @paymentId,RustBuffer @metadata
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(IntPtr @ptr,RustBuffer @id
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(IntPtr @ptr,RustBuffer @invoice
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_add_deposit(IntPtr @ptr,RustBuffer @txid,uint @vout,ulong @amountSats
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(IntPtr @ptr,RustBuffer @txid,uint @vout
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_list_deposits(IntPtr @ptr
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_method_storage_update_deposit(IntPtr @ptr,RustBuffer @txid,uint @vout,RustBuffer @payload
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfaceEventListener*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(IntPtr /*_UniFFILib.UniffiVTableCallbackInterfaceLogger*/ @vtable
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr uniffi_breez_sdk_spark_fn_func_connect(RustBuffer @request
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer uniffi_breez_sdk_spark_fn_func_default_config(RustBuffer @network,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void uniffi_breez_sdk_spark_fn_func_init_logging(RustBuffer @logDir,RustBuffer @appLogger,RustBuffer @logFilter,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_spark_rustbuffer_alloc(ulong @size,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_spark_rustbuffer_from_bytes(ForeignBytes @bytes,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rustbuffer_free(RustBuffer @buf,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_spark_rustbuffer_reserve(RustBuffer @buf,ulong @additional,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_u8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_u8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_u8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern byte ffi_breez_sdk_spark_rust_future_complete_u8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_i8(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_i8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_i8(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern sbyte ffi_breez_sdk_spark_rust_future_complete_i8(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_u16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_u16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_u16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort ffi_breez_sdk_spark_rust_future_complete_u16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_i16(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_i16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_i16(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern short ffi_breez_sdk_spark_rust_future_complete_i16(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_u32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_u32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_u32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_breez_sdk_spark_rust_future_complete_u32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_i32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_i32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_i32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern int ffi_breez_sdk_spark_rust_future_complete_i32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_u64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_u64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_u64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ulong ffi_breez_sdk_spark_rust_future_complete_u64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_i64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_i64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_i64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern long ffi_breez_sdk_spark_rust_future_complete_i64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_f32(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_f32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_f32(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern float ffi_breez_sdk_spark_rust_future_complete_f32(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_f64(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_f64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_f64(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern double ffi_breez_sdk_spark_rust_future_complete_f64(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_pointer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_pointer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_pointer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern IntPtr ffi_breez_sdk_spark_rust_future_complete_pointer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_rust_buffer(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_rust_buffer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_rust_buffer(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern RustBuffer ffi_breez_sdk_spark_rust_future_complete_rust_buffer(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_poll_void(IntPtr @handle,IntPtr @callback,IntPtr @callbackData
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_cancel_void(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_free_void(IntPtr @handle
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern void ffi_breez_sdk_spark_rust_future_complete_void(IntPtr @handle,ref UniffiRustCallStatus _uniffi_out_err
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_func_connect(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_func_default_config(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_func_init_logging(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_parse(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_list_payments(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_insert_payment(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_add_deposit(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_list_deposits(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_storage_update_deposit(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern ushort uniffi_breez_sdk_spark_checksum_method_logger_log(
    );

    [DllImport("breez_sdk_spark_bindings", CallingConvention = CallingConvention.Cdecl)]
    public static extern uint ffi_breez_sdk_spark_uniffi_contract_version(
    );

    

    static void uniffiCheckContractApiVersion() {
        var scaffolding_contract_version = _UniFFILib.ffi_breez_sdk_spark_uniffi_contract_version();
        if (26 != scaffolding_contract_version) {
            throw new UniffiContractVersionException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`");
        }
    }

    static void uniffiCheckApiChecksums() {
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_func_connect();
            if (checksum != 40345) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_func_connect` checksum `40345`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_func_default_config();
            if (checksum != 62194) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_func_default_config` checksum `62194`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_func_init_logging();
            if (checksum != 8518) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_func_init_logging` checksum `8518`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos();
            if (checksum != 20959) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_address_utxos` checksum `20959`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status();
            if (checksum != 23018) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_status` checksum `23018`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex();
            if (checksum != 59376) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_get_transaction_hex` checksum `59376`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction();
            if (checksum != 65179) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_bitcoinchainservice_broadcast_transaction` checksum `65179`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener();
            if (checksum != 37737) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_add_event_listener` checksum `37737`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available();
            if (checksum != 31624) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_check_lightning_address_available` checksum `31624`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message();
            if (checksum != 4385) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_check_message` checksum `4385`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit();
            if (checksum != 43529) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_claim_deposit` checksum `43529`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address();
            if (checksum != 44132) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_delete_lightning_address` checksum `44132`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect();
            if (checksum != 330) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_disconnect` checksum `330`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info();
            if (checksum != 6771) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_get_info` checksum `6771`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address();
            if (checksum != 36552) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_get_lightning_address` checksum `36552`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment();
            if (checksum != 11540) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_get_payment` checksum `11540`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata();
            if (checksum != 40125) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_get_tokens_metadata` checksum `40125`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies();
            if (checksum != 63366) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_currencies` checksum `63366`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates();
            if (checksum != 5904) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_list_fiat_rates` checksum `5904`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments();
            if (checksum != 16156) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_list_payments` checksum `16156`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits();
            if (checksum != 22486) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_list_unclaimed_deposits` checksum `22486`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay();
            if (checksum != 10147) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_pay` checksum `10147`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw();
            if (checksum != 45652) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_lnurl_withdraw` checksum `45652`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_parse();
            if (checksum != 195) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_parse` checksum `195`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay();
            if (checksum != 37691) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_lnurl_pay` checksum `37691`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment();
            if (checksum != 34185) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_prepare_send_payment` checksum `34185`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment();
            if (checksum != 36984) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_receive_payment` checksum `36984`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit();
            if (checksum != 33646) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_refund_deposit` checksum `33646`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address();
            if (checksum != 530) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_register_lightning_address` checksum `530`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener();
            if (checksum != 41066) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_remove_event_listener` checksum `41066`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment();
            if (checksum != 54349) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_send_payment` checksum `54349`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message();
            if (checksum != 57563) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_sign_message` checksum `57563`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet();
            if (checksum != 30368) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_sync_wallet` checksum `30368`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment();
            if (checksum != 64922) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_breezsdk_wait_for_payment` checksum `64922`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send();
            if (checksum != 30686) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_paymentobserver_before_send` checksum `30686`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build();
            if (checksum != 8126) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_build` checksum `8126`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service();
            if (checksum != 2848) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_chain_service` checksum `2848`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage();
            if (checksum != 14543) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_default_storage` checksum `14543`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service();
            if (checksum != 41113) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_fiat_service` checksum `41113`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set();
            if (checksum != 42926) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_key_set` checksum `42926`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client();
            if (checksum != 61720) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_lnurl_client` checksum `61720`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer();
            if (checksum != 21617) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_payment_observer` checksum `21617`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage();
            if (checksum != 22382) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_real_time_sync_storage` checksum `22382`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service();
            if (checksum != 56288) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_rest_chain_service` checksum `56288`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage();
            if (checksum != 59400) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_sdkbuilder_with_storage` checksum `59400`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item();
            if (checksum != 6883) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_delete_cached_item` checksum `6883`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item();
            if (checksum != 30248) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_get_cached_item` checksum `30248`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item();
            if (checksum != 7970) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_set_cached_item` checksum `7970`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_list_payments();
            if (checksum != 19728) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_list_payments` checksum `19728`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_insert_payment();
            if (checksum != 28075) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_insert_payment` checksum `28075`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata();
            if (checksum != 45500) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_set_payment_metadata` checksum `45500`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id();
            if (checksum != 35394) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_id` checksum `35394`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice();
            if (checksum != 57075) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_get_payment_by_invoice` checksum `57075`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_add_deposit();
            if (checksum != 60240) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_add_deposit` checksum `60240`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit();
            if (checksum != 60586) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_delete_deposit` checksum `60586`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_list_deposits();
            if (checksum != 54118) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_list_deposits` checksum `54118`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_storage_update_deposit();
            if (checksum != 39803) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_storage_update_deposit` checksum `39803`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new();
            if (checksum != 65435) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_constructor_sdkbuilder_new` checksum `65435`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event();
            if (checksum != 24807) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_eventlistener_on_event` checksum `24807`, library returned `{checksum}`");
            }
        }
        {
            var checksum = _UniFFILib.uniffi_breez_sdk_spark_checksum_method_logger_log();
            if (checksum != 11839) {
                throw new UniffiContractChecksumException($"Breez.Sdk.Spark.Bindings: uniffi bindings expected function `uniffi_breez_sdk_spark_checksum_method_logger_log` checksum `11839`, library returned `{checksum}`");
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt32: FfiConverter<uint, uint> {
    public static FfiConverterUInt32 INSTANCE = new FfiConverterUInt32();

    public override uint Lift(uint value) {
        return value;
    }

    public override uint Read(BigEndianStream stream) {
        return stream.ReadUInt();
    }

    public override uint Lower(uint value) {
        return value;
    }

    public override int AllocationSize(uint value) {
        return 4;
    }

    public override void Write(uint value, BigEndianStream stream) {
        stream.WriteUInt(value);
    }
}



class FfiConverterUInt64: FfiConverter<ulong, ulong> {
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value) {
        return value;
    }

    public override ulong Read(BigEndianStream stream) {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value) {
        return value;
    }

    public override int AllocationSize(ulong value) {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream) {
        stream.WriteULong(value);
    }
}



class FfiConverterBoolean: FfiConverter<bool, sbyte> {
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value) {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream) {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value) {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value) {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream) {
        stream.WriteSByte(Lower(value));
    }
}



class FfiConverterString: FfiConverter<string, RustBuffer> {
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value) {
        try {
            var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
            return System.Text.Encoding.UTF8.GetString(bytes);
        } finally {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value) {
        const int sizeForLength = 4;
        var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream) {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}




class FfiConverterByteArray: FfiConverterRustBuffer<byte[]> {
    public static FfiConverterByteArray INSTANCE = new FfiConverterByteArray();

    public override byte[] Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        return stream.ReadBytes(length);
    }

    public override int AllocationSize(byte[] value) {
        return 4 + value.Length;
    }

    public override void Write(byte[] value, BigEndianStream stream) {
        stream.WriteInt(value.Length);
        stream.WriteBytes(value);
    }
}



public interface BitcoinChainService {
    /// <exception cref="ChainServiceException"></exception>
    Task<List<Utxo>> GetAddressUtxos(string @address);
    /// <exception cref="ChainServiceException"></exception>
    Task<TxStatus> GetTransactionStatus(string @txid);
    /// <exception cref="ChainServiceException"></exception>
    Task<string> GetTransactionHex(string @txid);
    /// <exception cref="ChainServiceException"></exception>
    Task BroadcastTransaction(string @tx);
}
public class BitcoinChainServiceImpl : BitcoinChainService, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public BitcoinChainServiceImpl(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~BitcoinChainServiceImpl() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_spark_fn_free_bitcoinchainservice(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_clone_bitcoinchainservice(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <exception cref="ChainServiceException"></exception>
    public async Task<List<Utxo>> GetAddressUtxos(string @address) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_address_utxos(thisPtr, FfiConverterString.INSTANCE.Lower(@address));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeUtxo.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeChainServiceError.INSTANCE
    );
    }
    
    /// <exception cref="ChainServiceException"></exception>
    public async Task<TxStatus> GetTransactionStatus(string @txid) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_status(thisPtr, FfiConverterString.INSTANCE.Lower(@txid));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeTxStatus.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeChainServiceError.INSTANCE
    );
    }
    
    /// <exception cref="ChainServiceException"></exception>
    public async Task<string> GetTransactionHex(string @txid) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_get_transaction_hex(thisPtr, FfiConverterString.INSTANCE.Lower(@txid));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterString.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeChainServiceError.INSTANCE
    );
    }
    
    /// <exception cref="ChainServiceException"></exception>
    public async Task BroadcastTransaction(string @tx) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_bitcoinchainservice_broadcast_transaction(thisPtr, FfiConverterString.INSTANCE.Lower(@tx));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeChainServiceError.INSTANCE
    );
    }
    

    
}
class UniffiCallbackInterfaceBitcoinChainService {
    static void GetAddressUtxos(ulong @uniffiHandle,RustBuffer @address,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeBitcoinChainService.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetAddressUtxos(
                    FfiConverterString.INSTANCE.Lift(@address))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterSequenceTypeUtxo.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ChainServiceException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeChainServiceError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetTransactionStatus(ulong @uniffiHandle,RustBuffer @txid,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeBitcoinChainService.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetTransactionStatus(
                    FfiConverterString.INSTANCE.Lift(@txid))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterTypeTxStatus.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ChainServiceException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeChainServiceError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetTransactionHex(ulong @uniffiHandle,RustBuffer @txid,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeBitcoinChainService.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetTransactionHex(
                    FfiConverterString.INSTANCE.Lift(@txid))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterString.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ChainServiceException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeChainServiceError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void BroadcastTransaction(ulong @uniffiHandle,RustBuffer @tx,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeBitcoinChainService.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.BroadcastTransaction(
                    FfiConverterString.INSTANCE.Lift(@tx))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (ChainServiceException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeChainServiceError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeBitcoinChainService.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod0(GetAddressUtxos);
    static _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod1(GetTransactionStatus);
    static _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod2 _m2 = new _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod2(GetTransactionHex);
    static _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod3 _m3 = new _UniFFILib.UniffiCallbackInterfaceBitcoinChainServiceMethod3(BroadcastTransaction);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfaceBitcoinChainService _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceBitcoinChainService {
            @getAddressUtxos = Marshal.GetFunctionPointerForDelegate(_m0),
            @getTransactionStatus = Marshal.GetFunctionPointerForDelegate(_m1),
            @getTransactionHex = Marshal.GetFunctionPointerForDelegate(_m2),
            @broadcastTransaction = Marshal.GetFunctionPointerForDelegate(_m3),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_spark_fn_init_callback_vtable_bitcoinchainservice(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}

class ConcurrentHandleMap<T> where T: notnull {
    Dictionary<ulong, T> map = new Dictionary<ulong, T>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj) {
        lock (lock_) {
            currentHandle += 1;
            map[currentHandle] = obj;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result) {
        lock (lock_) {
            #pragma warning disable 8601 // Possible null reference assignment
            return map.TryGetValue(handle, out result);
            #pragma warning restore 8601
        }
    }

    public T Get(ulong handle) {
        if (TryGet(handle, out var result)) {
            return result;
        } else {
            throw new InternalException("ConcurrentHandleMap: Invalid handle");
        }
    }

    public bool Remove(ulong handle) {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result) {
        lock (lock_) {
            // Possible null reference assignment
            #pragma warning disable 8601
            if (map.TryGetValue(handle, out result)) {
            #pragma warning restore 8601
                map.Remove(handle);
                return true;
            } else {
                return false;
            }
        }
    }
}
static class UniffiCallbackResponseStatus {
    public static sbyte SUCCESS = 0;
    public static sbyte ERROR = 1;
    public static sbyte UNEXPECTED_ERROR = 2;
}

class FfiConverterTypeBitcoinChainService: FfiConverter<BitcoinChainService, IntPtr> {
    public ConcurrentHandleMap<BitcoinChainService> handleMap = new ConcurrentHandleMap<BitcoinChainService>();
    
    public static FfiConverterTypeBitcoinChainService INSTANCE = new FfiConverterTypeBitcoinChainService();


    public override IntPtr Lower(BitcoinChainService value) {
        return (IntPtr)handleMap.Insert(value);
    }

    public override BitcoinChainService Lift(IntPtr value) {
        return new BitcoinChainServiceImpl(value);
    }

    public override BitcoinChainService Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(BitcoinChainService value) {
        return 8;
    }

    public override void Write(BitcoinChainService value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
/// with request/response objects and comprehensive error handling.
/// </summary>
public interface IBreezSdk {
    /// <summary>
    /// Registers a listener to receive SDK events
    ///
    /// # Arguments
    ///
    /// * `listener` - An implementation of the `EventListener` trait
    ///
    /// # Returns
    ///
    /// A unique identifier for the listener, which can be used to remove it later
    /// </summary>
    Task<string> AddEventListener(EventListener @listener);
    /// <exception cref="SdkException"></exception>
    Task<bool> CheckLightningAddressAvailable(CheckLightningAddressRequest @req);
    /// <summary>
    /// Verifies a message signature against the provided public key. The message
    /// is SHA256 hashed before verification. The signature can be hex encoded
    /// in either DER or compact format.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<CheckMessageResponse> CheckMessage(CheckMessageRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<ClaimDepositResponse> ClaimDeposit(ClaimDepositRequest @request);
    /// <exception cref="SdkException"></exception>
    Task DeleteLightningAddress();
    /// <summary>
    /// Stops the SDK's background tasks
    ///
    /// This method stops the background tasks started by the `start()` method.
    /// It should be called before your application terminates to ensure proper cleanup.
    ///
    /// # Returns
    ///
    /// Result containing either success or an `SdkError` if the background task couldn't be stopped
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task Disconnect();
    /// <summary>
    /// Returns the balance of the wallet in satoshis
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<GetInfoResponse> GetInfo(GetInfoRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<LightningAddressInfo?> GetLightningAddress();
    /// <exception cref="SdkException"></exception>
    Task<GetPaymentResponse> GetPayment(GetPaymentRequest @request);
    /// <summary>
    /// Returns the metadata for the given token identifiers.
    ///
    /// Results are not guaranteed to be in the same order as the input token identifiers.
    ///
    /// If the metadata is not found locally in cache, it will be queried from
    /// the Spark network and then cached.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<GetTokensMetadataResponse> GetTokensMetadata(GetTokensMetadataRequest @request);
    /// <summary>
    /// List fiat currencies for which there is a known exchange rate,
    /// sorted by the canonical name of the currency.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<ListFiatCurrenciesResponse> ListFiatCurrencies();
    /// <summary>
    /// List the latest rates of fiat currencies, sorted by name.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<ListFiatRatesResponse> ListFiatRates();
    /// <summary>
    /// Lists payments from the storage with pagination
    ///
    /// This method provides direct access to the payment history stored in the database.
    /// It returns payments in reverse chronological order (newest first).
    ///
    /// # Arguments
    ///
    /// * `request` - Contains pagination parameters (offset and limit)
    ///
    /// # Returns
    ///
    /// * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
    /// * `Err(SdkError)` - If there was an error accessing the storage

    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<ListPaymentsResponse> ListPayments(ListPaymentsRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<ListUnclaimedDepositsResponse> ListUnclaimedDeposits(ListUnclaimedDepositsRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<LnurlPayResponse> LnurlPay(LnurlPayRequest @request);
    /// <summary>
    /// Performs an LNURL withdraw operation for the amount of satoshis to
    /// withdraw and the LNURL withdraw request details. The LNURL withdraw request
    /// details can be obtained from calling [`BreezSdk::parse`].
    ///
    /// The method generates a Lightning invoice for the withdraw amount, stores
    /// the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
    /// invoice.
    ///
    /// If the `completion_timeout_secs` parameter is provided and greater than 0, the
    /// method will wait for the payment to be completed within that period. If the
    /// withdraw is completed within the timeout, the `payment` field in the response
    /// will be set with the payment details. If the `completion_timeout_secs`
    /// parameter is not provided or set to 0, the method will not wait for the payment
    /// to be completed. If the withdraw is not completed within the
    /// timeout, the `payment` field will be empty.
    ///
    /// # Arguments
    ///
    /// * `request` - The LNURL withdraw request
    ///
    /// # Returns
    ///
    /// Result containing either:
    /// * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
    /// * `SdkError` - If there was an error during the withdraw process
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<LnurlWithdrawResponse> LnurlWithdraw(LnurlWithdrawRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<InputType> Parse(string @input);
    /// <exception cref="SdkException"></exception>
    Task<PrepareLnurlPayResponse> PrepareLnurlPay(PrepareLnurlPayRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<PrepareSendPaymentResponse> PrepareSendPayment(PrepareSendPaymentRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<ReceivePaymentResponse> ReceivePayment(ReceivePaymentRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<RefundDepositResponse> RefundDeposit(RefundDepositRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<LightningAddressInfo> RegisterLightningAddress(RegisterLightningAddressRequest @request);
    /// <summary>
    /// Removes a previously registered event listener
    ///
    /// # Arguments
    ///
    /// * `id` - The listener ID returned from `add_event_listener`
    ///
    /// # Returns
    ///
    /// `true` if the listener was found and removed, `false` otherwise
    /// </summary>
    Task<bool> RemoveEventListener(string @id);
    /// <exception cref="SdkException"></exception>
    Task<SendPaymentResponse> SendPayment(SendPaymentRequest @request);
    /// <summary>
    /// Signs a message with the wallet's identity key. The message is SHA256
    /// hashed before signing. The returned signature will be hex encoded in
    /// DER format by default, or compact format if specified.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<SignMessageResponse> SignMessage(SignMessageRequest @request);
    /// <summary>
    /// Synchronizes the wallet with the Spark network
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<SyncWalletResponse> SyncWallet(SyncWalletRequest @request);
    /// <exception cref="SdkException"></exception>
    Task<WaitForPaymentResponse> WaitForPayment(WaitForPaymentRequest @request);
}
/// <summary>
/// `BreezSDK` is a wrapper around `SparkSDK` that provides a more structured API
/// with request/response objects and comprehensive error handling.
/// </summary>
public class BreezSdk : IBreezSdk, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public BreezSdk(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~BreezSdk() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_spark_fn_free_breezsdk(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_clone_breezsdk(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Registers a listener to receive SDK events
    ///
    /// # Arguments
    ///
    /// * `listener` - An implementation of the `EventListener` trait
    ///
    /// # Returns
    ///
    /// A unique identifier for the listener, which can be used to remove it later
    /// </summary>
    public async Task<string> AddEventListener(EventListener @listener) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_add_event_listener(thisPtr, FfiConverterTypeEventListener.INSTANCE.Lower(@listener));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterString.INSTANCE.Lift(result),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<bool> CheckLightningAddressAvailable(CheckLightningAddressRequest @req) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_lightning_address_available(thisPtr, FfiConverterTypeCheckLightningAddressRequest.INSTANCE.Lower(@req));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_i8(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_i8(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_i8(future),
        // Lift
        (result) => FfiConverterBoolean.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Verifies a message signature against the provided public key. The message
    /// is SHA256 hashed before verification. The signature can be hex encoded
    /// in either DER or compact format.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<CheckMessageResponse> CheckMessage(CheckMessageRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_check_message(thisPtr, FfiConverterTypeCheckMessageRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeCheckMessageResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<ClaimDepositResponse> ClaimDeposit(ClaimDepositRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_claim_deposit(thisPtr, FfiConverterTypeClaimDepositRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeClaimDepositResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task DeleteLightningAddress() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_delete_lightning_address(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Stops the SDK's background tasks
    ///
    /// This method stops the background tasks started by the `start()` method.
    /// It should be called before your application terminates to ensure proper cleanup.
    ///
    /// # Returns
    ///
    /// Result containing either success or an `SdkError` if the background task couldn't be stopped
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task Disconnect() {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_disconnect(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Returns the balance of the wallet in satoshis
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<GetInfoResponse> GetInfo(GetInfoRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_info(thisPtr, FfiConverterTypeGetInfoRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeGetInfoResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<LightningAddressInfo?> GetLightningAddress() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_lightning_address(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterOptionalTypeLightningAddressInfo.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<GetPaymentResponse> GetPayment(GetPaymentRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_payment(thisPtr, FfiConverterTypeGetPaymentRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeGetPaymentResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Returns the metadata for the given token identifiers.
    ///
    /// Results are not guaranteed to be in the same order as the input token identifiers.
    ///
    /// If the metadata is not found locally in cache, it will be queried from
    /// the Spark network and then cached.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<GetTokensMetadataResponse> GetTokensMetadata(GetTokensMetadataRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_get_tokens_metadata(thisPtr, FfiConverterTypeGetTokensMetadataRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeGetTokensMetadataResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// List fiat currencies for which there is a known exchange rate,
    /// sorted by the canonical name of the currency.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<ListFiatCurrenciesResponse> ListFiatCurrencies() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_currencies(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeListFiatCurrenciesResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// List the latest rates of fiat currencies, sorted by name.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<ListFiatRatesResponse> ListFiatRates() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_fiat_rates(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeListFiatRatesResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Lists payments from the storage with pagination
    ///
    /// This method provides direct access to the payment history stored in the database.
    /// It returns payments in reverse chronological order (newest first).
    ///
    /// # Arguments
    ///
    /// * `request` - Contains pagination parameters (offset and limit)
    ///
    /// # Returns
    ///
    /// * `Ok(ListPaymentsResponse)` - Contains the list of payments if successful
    /// * `Err(SdkError)` - If there was an error accessing the storage

    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<ListPaymentsResponse> ListPayments(ListPaymentsRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_payments(thisPtr, FfiConverterTypeListPaymentsRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeListPaymentsResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<ListUnclaimedDepositsResponse> ListUnclaimedDeposits(ListUnclaimedDepositsRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_list_unclaimed_deposits(thisPtr, FfiConverterTypeListUnclaimedDepositsRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeListUnclaimedDepositsResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<LnurlPayResponse> LnurlPay(LnurlPayRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_pay(thisPtr, FfiConverterTypeLnurlPayRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeLnurlPayResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Performs an LNURL withdraw operation for the amount of satoshis to
    /// withdraw and the LNURL withdraw request details. The LNURL withdraw request
    /// details can be obtained from calling [`BreezSdk::parse`].
    ///
    /// The method generates a Lightning invoice for the withdraw amount, stores
    /// the LNURL withdraw metadata, and performs the LNURL withdraw using  the generated
    /// invoice.
    ///
    /// If the `completion_timeout_secs` parameter is provided and greater than 0, the
    /// method will wait for the payment to be completed within that period. If the
    /// withdraw is completed within the timeout, the `payment` field in the response
    /// will be set with the payment details. If the `completion_timeout_secs`
    /// parameter is not provided or set to 0, the method will not wait for the payment
    /// to be completed. If the withdraw is not completed within the
    /// timeout, the `payment` field will be empty.
    ///
    /// # Arguments
    ///
    /// * `request` - The LNURL withdraw request
    ///
    /// # Returns
    ///
    /// Result containing either:
    /// * `LnurlWithdrawResponse` - The payment details if the withdraw request was successful
    /// * `SdkError` - If there was an error during the withdraw process
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<LnurlWithdrawResponse> LnurlWithdraw(LnurlWithdrawRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_lnurl_withdraw(thisPtr, FfiConverterTypeLnurlWithdrawRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeLnurlWithdrawResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<InputType> Parse(string @input) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_parse(thisPtr, FfiConverterString.INSTANCE.Lower(@input));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeInputType.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<PrepareLnurlPayResponse> PrepareLnurlPay(PrepareLnurlPayRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_lnurl_pay(thisPtr, FfiConverterTypePrepareLnurlPayRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypePrepareLnurlPayResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<PrepareSendPaymentResponse> PrepareSendPayment(PrepareSendPaymentRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_prepare_send_payment(thisPtr, FfiConverterTypePrepareSendPaymentRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypePrepareSendPaymentResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<ReceivePaymentResponse> ReceivePayment(ReceivePaymentRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_receive_payment(thisPtr, FfiConverterTypeReceivePaymentRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeReceivePaymentResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<RefundDepositResponse> RefundDeposit(RefundDepositRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_refund_deposit(thisPtr, FfiConverterTypeRefundDepositRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeRefundDepositResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<LightningAddressInfo> RegisterLightningAddress(RegisterLightningAddressRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_register_lightning_address(thisPtr, FfiConverterTypeRegisterLightningAddressRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeLightningAddressInfo.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Removes a previously registered event listener
    ///
    /// # Arguments
    ///
    /// * `id` - The listener ID returned from `add_event_listener`
    ///
    /// # Returns
    ///
    /// `true` if the listener was found and removed, `false` otherwise
    /// </summary>
    public async Task<bool> RemoveEventListener(string @id) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_remove_event_listener(thisPtr, FfiConverterString.INSTANCE.Lower(@id));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_i8(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_i8(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_i8(future),
        // Lift
        (result) => FfiConverterBoolean.INSTANCE.Lift(result),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<SendPaymentResponse> SendPayment(SendPaymentRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_send_payment(thisPtr, FfiConverterTypeSendPaymentRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeSendPaymentResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Signs a message with the wallet's identity key. The message is SHA256
    /// hashed before signing. The returned signature will be hex encoded in
    /// DER format by default, or compact format if specified.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<SignMessageResponse> SignMessage(SignMessageRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_sign_message(thisPtr, FfiConverterTypeSignMessageRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeSignMessageResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Synchronizes the wallet with the Spark network
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<SyncWalletResponse> SyncWallet(SyncWalletRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_sync_wallet(thisPtr, FfiConverterTypeSyncWalletRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeSyncWalletResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <exception cref="SdkException"></exception>
    public async Task<WaitForPaymentResponse> WaitForPayment(WaitForPaymentRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_breezsdk_wait_for_payment(thisPtr, FfiConverterTypeWaitForPaymentRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypeWaitForPaymentResponse.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    

    
}
class FfiConverterTypeBreezSdk: FfiConverter<BreezSdk, IntPtr> {
    public static FfiConverterTypeBreezSdk INSTANCE = new FfiConverterTypeBreezSdk();


    public override IntPtr Lower(BreezSdk value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override BreezSdk Lift(IntPtr value) {
        return new BreezSdk(value);
    }

    public override BreezSdk Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(BreezSdk value) {
        return 8;
    }

    public override void Write(BreezSdk value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
/// If the implementation returns an error, the payment is cancelled.
/// </summary>
public interface PaymentObserver {
    /// <summary>
    /// Called before Lightning, Spark or onchain Bitcoin payments are made
    /// </summary>
    /// <exception cref="PaymentObserverException"></exception>
    Task BeforeSend(List<ProvisionalPayment> @payments);
}
/// <summary>
/// This interface is used to observe outgoing payments before Lightning, Spark and onchain Bitcoin payments.
/// If the implementation returns an error, the payment is cancelled.
/// </summary>
public class PaymentObserverImpl : PaymentObserver, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public PaymentObserverImpl(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~PaymentObserverImpl() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_spark_fn_free_paymentobserver(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_clone_paymentobserver(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Called before Lightning, Spark or onchain Bitcoin payments are made
    /// </summary>
    /// <exception cref="PaymentObserverException"></exception>
    public async Task BeforeSend(List<ProvisionalPayment> @payments) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_paymentobserver_before_send(thisPtr, FfiConverterSequenceTypeProvisionalPayment.INSTANCE.Lower(@payments));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypePaymentObserverError.INSTANCE
    );
    }
    

    
}
class UniffiCallbackInterfacePaymentObserver {
    static void BeforeSend(ulong @uniffiHandle,RustBuffer @payments,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypePaymentObserver.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.BeforeSend(
                    FfiConverterSequenceTypeProvisionalPayment.INSTANCE.Lift(@payments))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (PaymentObserverException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypePaymentObserverError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypePaymentObserver.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfacePaymentObserverMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfacePaymentObserverMethod0(BeforeSend);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfacePaymentObserver _vtable = new _UniFFILib.UniffiVTableCallbackInterfacePaymentObserver {
            @beforeSend = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_spark_fn_init_callback_vtable_paymentobserver(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}




class FfiConverterTypePaymentObserver: FfiConverter<PaymentObserver, IntPtr> {
    public ConcurrentHandleMap<PaymentObserver> handleMap = new ConcurrentHandleMap<PaymentObserver>();
    
    public static FfiConverterTypePaymentObserver INSTANCE = new FfiConverterTypePaymentObserver();


    public override IntPtr Lower(PaymentObserver value) {
        return (IntPtr)handleMap.Insert(value);
    }

    public override PaymentObserver Lift(IntPtr value) {
        return new PaymentObserverImpl(value);
    }

    public override PaymentObserver Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(PaymentObserver value) {
        return 8;
    }

    public override void Write(PaymentObserver value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Builder for creating `BreezSdk` instances with customizable components.
/// </summary>
public interface ISdkBuilder {
    /// <summary>
    /// Builds the `BreezSdk` instance with the configured components.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    Task<BreezSdk> Build();
    /// <summary>
    /// Sets the chain service to be used by the SDK.
    /// Arguments:
    /// - `chain_service`: The chain service to be used.
    /// </summary>
    Task WithChainService(BitcoinChainService @chainService);
    /// <summary>
    /// Sets the root storage directory to initialize the default storage with.
    /// This initializes both storage and real-time sync storage with the
    /// default implementations.
    /// Arguments:
    /// - `storage_dir`: The data directory for storage.
    /// </summary>
    Task WithDefaultStorage(string @storageDir);
    /// <summary>
    /// Sets the fiat service to be used by the SDK.
    /// Arguments:
    /// - `fiat_service`: The fiat service to be used.
    /// </summary>
    Task WithFiatService(FiatService @fiatService);
    /// <summary>
    /// Sets the key set type to be used by the SDK.
    /// Arguments:
    /// - `key_set_type`: The key set type which determines the derivation path.
    /// - `use_address_index`: Controls the structure of the BIP derivation path.
    /// </summary>
    Task WithKeySet(KeySetType @keySetType, bool @useAddressIndex, uint? @accountNumber);
    Task WithLnurlClient(RestClient @lnurlClient);
    /// <summary>
    /// Sets the payment observer to be used by the SDK.
    /// Arguments:
    /// - `payment_observer`: The payment observer to be used.
    /// </summary>
    Task WithPaymentObserver(PaymentObserver @paymentObserver);
    /// <summary>
    /// Sets the real-time sync storage implementation to be used by the SDK.
    /// Arguments:
    /// - `storage`: The sync storage implementation to be used.
    /// </summary>
    Task WithRealTimeSyncStorage(SyncStorage @storage);
    /// <summary>
    /// Sets the REST chain service to be used by the SDK.
    /// Arguments:
    /// - `url`: The base URL of the REST API.
    /// - `credentials`: Optional credentials for basic authentication.
    /// </summary>
    Task WithRestChainService(string @url, Credentials? @credentials);
    /// <summary>
    /// Sets the storage implementation to be used by the SDK.
    /// Arguments:
    /// - `storage`: The storage implementation to be used.
    /// </summary>
    Task WithStorage(Storage @storage);
}
/// <summary>
/// Builder for creating `BreezSdk` instances with customizable components.
/// </summary>
public class SdkBuilder : ISdkBuilder, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public SdkBuilder(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~SdkBuilder() {
        Destroy();
    }
    /// <summary>
    /// Creates a new `SdkBuilder` with the provided configuration.
    /// Arguments:
    /// - `config`: The configuration to be used.
    /// - `seed`: The seed for wallet generation.
    /// </summary>
    public SdkBuilder(Config @config, Seed @seed) :
        this(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_breez_sdk_spark_fn_constructor_sdkbuilder_new(FfiConverterTypeConfig.INSTANCE.Lower(@config), FfiConverterTypeSeed.INSTANCE.Lower(@seed), ref _status)
)) {}

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_spark_fn_free_sdkbuilder(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_clone_sdkbuilder(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <summary>
    /// Builds the `BreezSdk` instance with the configured components.
    /// </summary>
    /// <exception cref="SdkException"></exception>
    public async Task<BreezSdk> Build() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_build(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeBreezSdk.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
    }
    
    /// <summary>
    /// Sets the chain service to be used by the SDK.
    /// Arguments:
    /// - `chain_service`: The chain service to be used.
    /// </summary>
    public async Task WithChainService(BitcoinChainService @chainService) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_chain_service(thisPtr, FfiConverterTypeBitcoinChainService.INSTANCE.Lower(@chainService));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Sets the root storage directory to initialize the default storage with.
    /// This initializes both storage and real-time sync storage with the
    /// default implementations.
    /// Arguments:
    /// - `storage_dir`: The data directory for storage.
    /// </summary>
    public async Task WithDefaultStorage(string @storageDir) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_default_storage(thisPtr, FfiConverterString.INSTANCE.Lower(@storageDir));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Sets the fiat service to be used by the SDK.
    /// Arguments:
    /// - `fiat_service`: The fiat service to be used.
    /// </summary>
    public async Task WithFiatService(FiatService @fiatService) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_fiat_service(thisPtr, FfiConverterTypeFiatService.INSTANCE.Lower(@fiatService));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Sets the key set type to be used by the SDK.
    /// Arguments:
    /// - `key_set_type`: The key set type which determines the derivation path.
    /// - `use_address_index`: Controls the structure of the BIP derivation path.
    /// </summary>
    public async Task WithKeySet(KeySetType @keySetType, bool @useAddressIndex, uint? @accountNumber) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_key_set(thisPtr, FfiConverterTypeKeySetType.INSTANCE.Lower(@keySetType), FfiConverterBoolean.INSTANCE.Lower(@useAddressIndex), FfiConverterOptionalUInt32.INSTANCE.Lower(@accountNumber));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    public async Task WithLnurlClient(RestClient @lnurlClient) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_lnurl_client(thisPtr, FfiConverterTypeRestClient.INSTANCE.Lower(@lnurlClient));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Sets the payment observer to be used by the SDK.
    /// Arguments:
    /// - `payment_observer`: The payment observer to be used.
    /// </summary>
    public async Task WithPaymentObserver(PaymentObserver @paymentObserver) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_payment_observer(thisPtr, FfiConverterTypePaymentObserver.INSTANCE.Lower(@paymentObserver));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Sets the real-time sync storage implementation to be used by the SDK.
    /// Arguments:
    /// - `storage`: The sync storage implementation to be used.
    /// </summary>
    public async Task WithRealTimeSyncStorage(SyncStorage @storage) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_real_time_sync_storage(thisPtr, FfiConverterTypeSyncStorage.INSTANCE.Lower(@storage));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Sets the REST chain service to be used by the SDK.
    /// Arguments:
    /// - `url`: The base URL of the REST API.
    /// - `credentials`: Optional credentials for basic authentication.
    /// </summary>
    public async Task WithRestChainService(string @url, Credentials? @credentials) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_rest_chain_service(thisPtr, FfiConverterString.INSTANCE.Lower(@url), FfiConverterOptionalTypeCredentials.INSTANCE.Lower(@credentials));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    
    /// <summary>
    /// Sets the storage implementation to be used by the SDK.
    /// Arguments:
    /// - `storage`: The storage implementation to be used.
    /// </summary>
    public async Task WithStorage(Storage @storage) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_sdkbuilder_with_storage(thisPtr, FfiConverterTypeStorage.INSTANCE.Lower(@storage));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        NullCallStatusErrorHandler.INSTANCE
        
    );
    }
    

    
}
class FfiConverterTypeSdkBuilder: FfiConverter<SdkBuilder, IntPtr> {
    public static FfiConverterTypeSdkBuilder INSTANCE = new FfiConverterTypeSdkBuilder();


    public override IntPtr Lower(SdkBuilder value) {
        return value.CallWithPointer(thisPtr => thisPtr);
    }

    public override SdkBuilder Lift(IntPtr value) {
        return new SdkBuilder(value);
    }

    public override SdkBuilder Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(SdkBuilder value) {
        return 8;
    }

    public override void Write(SdkBuilder value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



/// <summary>
/// Trait for persistent storage
/// </summary>
public interface Storage {
    /// <exception cref="StorageException"></exception>
    Task DeleteCachedItem(string @key);
    /// <exception cref="StorageException"></exception>
    Task<string?> GetCachedItem(string @key);
    /// <exception cref="StorageException"></exception>
    Task SetCachedItem(string @key, string @value);
    /// <summary>
    /// Lists payments with optional filters and pagination
    ///
    /// # Arguments
    ///
    /// * `list_payments_request` - The request to list payments
    ///
    /// # Returns
    ///
    /// A vector of payments or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task<List<Payment>> ListPayments(ListPaymentsRequest @request);
    /// <summary>
    /// Inserts a payment into storage
    ///
    /// # Arguments
    ///
    /// * `payment` - The payment to insert
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task InsertPayment(Payment @payment);
    /// <summary>
    /// Inserts payment metadata into storage
    ///
    /// # Arguments
    ///
    /// * `payment_id` - The ID of the payment
    /// * `metadata` - The metadata to insert
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task SetPaymentMetadata(string @paymentId, PaymentMetadata @metadata);
    /// <summary>
    /// Gets a payment by its ID
    /// # Arguments
    ///
    /// * `id` - The ID of the payment to retrieve
    ///
    /// # Returns
    ///
    /// The payment if found or None if not found
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task<Payment> GetPaymentById(string @id);
    /// <summary>
    /// Gets a payment by its invoice
    /// # Arguments
    ///
    /// * `invoice` - The invoice of the payment to retrieve
    /// # Returns
    ///
    /// The payment if found or None if not found
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task<Payment?> GetPaymentByInvoice(string @invoice);
    /// <summary>
    /// Add a deposit to storage
    /// # Arguments
    ///
    /// * `txid` - The transaction ID of the deposit
    /// * `vout` - The output index of the deposit
    /// * `amount_sats` - The amount of the deposit in sats
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task AddDeposit(string @txid, uint @vout, ulong @amountSats);
    /// <summary>
    /// Removes an unclaimed deposit from storage
    /// # Arguments
    ///
    /// * `txid` - The transaction ID of the deposit
    /// * `vout` - The output index of the deposit
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task DeleteDeposit(string @txid, uint @vout);
    /// <summary>
    /// Lists all unclaimed deposits from storage
    /// # Returns
    ///
    /// A vector of `DepositInfo` or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task<List<DepositInfo>> ListDeposits();
    /// <summary>
    /// Updates or inserts unclaimed deposit details
    /// # Arguments
    ///
    /// * `txid` - The transaction ID of the deposit
    /// * `vout` - The output index of the deposit
    /// * `payload` - The payload for the update
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    Task UpdateDeposit(string @txid, uint @vout, UpdateDepositPayload @payload);
}
/// <summary>
/// Trait for persistent storage
/// </summary>
public class StorageImpl : Storage, IDisposable {
    protected IntPtr pointer;
    private int _wasDestroyed = 0;
    private long _callCounter = 1;

    public StorageImpl(IntPtr pointer) {
        this.pointer = pointer;
    }

    ~StorageImpl() {
        Destroy();
    }

    protected void FreeRustArcPtr() {
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            _UniFFILib.uniffi_breez_sdk_spark_fn_free_storage(this.pointer, ref status);
        });
    }

    protected IntPtr CloneRustArcPtr() {
        return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_clone_storage(this.pointer, ref status);
        });
    }

    public void Destroy()
    {
        // Only allow a single call to this method.
        if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
        {
            // This decrement always matches the initial count of 1 given at creation time.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }
    }

    public void Dispose()
    {
        Destroy();
        GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
    }

    private void IncrementCallCounter() 
    {
        // Check and increment the call counter, to keep the object alive.
        // This needs a compare-and-set retry loop in case of concurrent updates.
        long count;
        do
        {
            count = Interlocked.Read(ref _callCounter);
            if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
            if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

        } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
    }

    private void DecrementCallCounter() 
    {
        // This decrement always matches the increment we performed above.
        if (Interlocked.Decrement(ref _callCounter) == 0) {
            FreeRustArcPtr();
        }
    }

    internal void CallWithPointer(Action<IntPtr> action)
    {
        IncrementCallCounter();
        try {
            action(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    internal T CallWithPointer<T>(Func<IntPtr, T> func)
    {   
        IncrementCallCounter();
        try {
            return func(CloneRustArcPtr());
        }
        finally {
            DecrementCallCounter();
        }
    }

    
    /// <exception cref="StorageException"></exception>
    public async Task DeleteCachedItem(string @key) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_delete_cached_item(thisPtr, FfiConverterString.INSTANCE.Lower(@key));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <exception cref="StorageException"></exception>
    public async Task<string?> GetCachedItem(string @key) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_get_cached_item(thisPtr, FfiConverterString.INSTANCE.Lower(@key));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterOptionalString.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <exception cref="StorageException"></exception>
    public async Task SetCachedItem(string @key, string @value) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_set_cached_item(thisPtr, FfiConverterString.INSTANCE.Lower(@key), FfiConverterString.INSTANCE.Lower(@value));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Lists payments with optional filters and pagination
    ///
    /// # Arguments
    ///
    /// * `list_payments_request` - The request to list payments
    ///
    /// # Returns
    ///
    /// A vector of payments or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task<List<Payment>> ListPayments(ListPaymentsRequest @request) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_list_payments(thisPtr, FfiConverterTypeListPaymentsRequest.INSTANCE.Lower(@request));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypePayment.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Inserts a payment into storage
    ///
    /// # Arguments
    ///
    /// * `payment` - The payment to insert
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task InsertPayment(Payment @payment) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_insert_payment(thisPtr, FfiConverterTypePayment.INSTANCE.Lower(@payment));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Inserts payment metadata into storage
    ///
    /// # Arguments
    ///
    /// * `payment_id` - The ID of the payment
    /// * `metadata` - The metadata to insert
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task SetPaymentMetadata(string @paymentId, PaymentMetadata @metadata) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_set_payment_metadata(thisPtr, FfiConverterString.INSTANCE.Lower(@paymentId), FfiConverterTypePaymentMetadata.INSTANCE.Lower(@metadata));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Gets a payment by its ID
    /// # Arguments
    ///
    /// * `id` - The ID of the payment to retrieve
    ///
    /// # Returns
    ///
    /// The payment if found or None if not found
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task<Payment> GetPaymentById(string @id) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_id(thisPtr, FfiConverterString.INSTANCE.Lower(@id));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterTypePayment.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Gets a payment by its invoice
    /// # Arguments
    ///
    /// * `invoice` - The invoice of the payment to retrieve
    /// # Returns
    ///
    /// The payment if found or None if not found
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task<Payment?> GetPaymentByInvoice(string @invoice) {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_get_payment_by_invoice(thisPtr, FfiConverterString.INSTANCE.Lower(@invoice));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterOptionalTypePayment.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Add a deposit to storage
    /// # Arguments
    ///
    /// * `txid` - The transaction ID of the deposit
    /// * `vout` - The output index of the deposit
    /// * `amount_sats` - The amount of the deposit in sats
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task AddDeposit(string @txid, uint @vout, ulong @amountSats) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_add_deposit(thisPtr, FfiConverterString.INSTANCE.Lower(@txid), FfiConverterUInt32.INSTANCE.Lower(@vout), FfiConverterUInt64.INSTANCE.Lower(@amountSats));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Removes an unclaimed deposit from storage
    /// # Arguments
    ///
    /// * `txid` - The transaction ID of the deposit
    /// * `vout` - The output index of the deposit
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task DeleteDeposit(string @txid, uint @vout) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_delete_deposit(thisPtr, FfiConverterString.INSTANCE.Lower(@txid), FfiConverterUInt32.INSTANCE.Lower(@vout));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Lists all unclaimed deposits from storage
    /// # Returns
    ///
    /// A vector of `DepositInfo` or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task<List<DepositInfo>> ListDeposits() {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_list_deposits(thisPtr);
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_rust_buffer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_rust_buffer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_rust_buffer(future),
        // Lift
        (result) => FfiConverterSequenceTypeDepositInfo.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    
    /// <summary>
    /// Updates or inserts unclaimed deposit details
    /// # Arguments
    ///
    /// * `txid` - The transaction ID of the deposit
    /// * `vout` - The output index of the deposit
    /// * `payload` - The payload for the update
    ///
    /// # Returns
    ///
    /// Success or a `StorageError`
    /// </summary>
    /// <exception cref="StorageException"></exception>
    public async Task UpdateDeposit(string @txid, uint @vout, UpdateDepositPayload @payload) {await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        CallWithPointer(thisPtr => {
            return _UniFFILib.uniffi_breez_sdk_spark_fn_method_storage_update_deposit(thisPtr, FfiConverterString.INSTANCE.Lower(@txid), FfiConverterUInt32.INSTANCE.Lower(@vout), FfiConverterTypeUpdateDepositPayload.INSTANCE.Lower(@payload));
        }),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_void(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {_UniFFILib.ffi_breez_sdk_spark_rust_future_complete_void(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_void(future),
        // Error
        FfiConverterTypeStorageError.INSTANCE
    );
    }
    

    
}
class UniffiCallbackInterfaceStorage {
    static void DeleteCachedItem(ulong @uniffiHandle,RustBuffer @key,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.DeleteCachedItem(
                    FfiConverterString.INSTANCE.Lift(@key))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetCachedItem(ulong @uniffiHandle,RustBuffer @key,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetCachedItem(
                    FfiConverterString.INSTANCE.Lift(@key))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterOptionalString.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void SetCachedItem(ulong @uniffiHandle,RustBuffer @key,RustBuffer @value,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.SetCachedItem(
                    FfiConverterString.INSTANCE.Lift(@key), 
                    FfiConverterString.INSTANCE.Lift(@value))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void ListPayments(ulong @uniffiHandle,RustBuffer @request,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.ListPayments(
                    FfiConverterTypeListPaymentsRequest.INSTANCE.Lift(@request))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterSequenceTypePayment.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void InsertPayment(ulong @uniffiHandle,RustBuffer @payment,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.InsertPayment(
                    FfiConverterTypePayment.INSTANCE.Lift(@payment))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void SetPaymentMetadata(ulong @uniffiHandle,RustBuffer @paymentId,RustBuffer @metadata,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.SetPaymentMetadata(
                    FfiConverterString.INSTANCE.Lift(@paymentId), 
                    FfiConverterTypePaymentMetadata.INSTANCE.Lift(@metadata))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetPaymentById(ulong @uniffiHandle,RustBuffer @id,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetPaymentById(
                    FfiConverterString.INSTANCE.Lift(@id))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterTypePayment.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void GetPaymentByInvoice(ulong @uniffiHandle,RustBuffer @invoice,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.GetPaymentByInvoice(
                    FfiConverterString.INSTANCE.Lift(@invoice))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterOptionalTypePayment.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void AddDeposit(ulong @uniffiHandle,RustBuffer @txid,uint @vout,ulong @amountSats,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.AddDeposit(
                    FfiConverterString.INSTANCE.Lift(@txid), 
                    FfiConverterUInt32.INSTANCE.Lift(@vout), 
                    FfiConverterUInt64.INSTANCE.Lift(@amountSats))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void DeleteDeposit(ulong @uniffiHandle,RustBuffer @txid,uint @vout,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.DeleteDeposit(
                    FfiConverterString.INSTANCE.Lift(@txid), 
                    FfiConverterUInt32.INSTANCE.Lift(@vout))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void ListDeposits(ulong @uniffiHandle,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructRustBuffer();
                ret.@callStatus = new UniffiRustCallStatus();
                try {
                var result =

                await uniffiObject.ListDeposits()
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;
                ret.@returnValue = FfiConverterSequenceTypeDepositInfo.INSTANCE.Lower(result);

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteRustBuffer>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }
    static void UpdateDeposit(ulong @uniffiHandle,RustBuffer @txid,uint @vout,RustBuffer @payload,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeStorage.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();
                try {

                await uniffiObject.UpdateDeposit(
                    FfiConverterString.INSTANCE.Lift(@txid), 
                    FfiConverterUInt32.INSTANCE.Lift(@vout), 
                    FfiConverterTypeUpdateDepositPayload.INSTANCE.Lift(@payload))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;
                } catch (StorageException e) {
                    ret.@callStatus.code = UniffiCallbackResponseStatus.ERROR;
                    ret.@callStatus.error_buf = FfiConverterTypeStorageError.INSTANCE.Lower(e);
                } catch (System.Exception e){
                    ret.@callStatus.code = UniffiCallbackResponseStatus.UNEXPECTED_ERROR;
                    try {
                        ret.@callStatus.error_buf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch {
                    }
                }

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeStorage.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod0(DeleteCachedItem);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod1(GetCachedItem);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod2 _m2 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod2(SetCachedItem);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod3 _m3 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod3(ListPayments);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod4 _m4 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod4(InsertPayment);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod5 _m5 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod5(SetPaymentMetadata);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod6 _m6 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod6(GetPaymentById);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod7 _m7 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod7(GetPaymentByInvoice);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod8 _m8 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod8(AddDeposit);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod9 _m9 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod9(DeleteDeposit);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod10 _m10 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod10(ListDeposits);
    static _UniFFILib.UniffiCallbackInterfaceStorageMethod11 _m11 = new _UniFFILib.UniffiCallbackInterfaceStorageMethod11(UpdateDeposit);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfaceStorage _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceStorage {
            @deleteCachedItem = Marshal.GetFunctionPointerForDelegate(_m0),
            @getCachedItem = Marshal.GetFunctionPointerForDelegate(_m1),
            @setCachedItem = Marshal.GetFunctionPointerForDelegate(_m2),
            @listPayments = Marshal.GetFunctionPointerForDelegate(_m3),
            @insertPayment = Marshal.GetFunctionPointerForDelegate(_m4),
            @setPaymentMetadata = Marshal.GetFunctionPointerForDelegate(_m5),
            @getPaymentById = Marshal.GetFunctionPointerForDelegate(_m6),
            @getPaymentByInvoice = Marshal.GetFunctionPointerForDelegate(_m7),
            @addDeposit = Marshal.GetFunctionPointerForDelegate(_m8),
            @deleteDeposit = Marshal.GetFunctionPointerForDelegate(_m9),
            @listDeposits = Marshal.GetFunctionPointerForDelegate(_m10),
            @updateDeposit = Marshal.GetFunctionPointerForDelegate(_m11),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_spark_fn_init_callback_vtable_storage(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}




class FfiConverterTypeStorage: FfiConverter<Storage, IntPtr> {
    public ConcurrentHandleMap<Storage> handleMap = new ConcurrentHandleMap<Storage>();
    
    public static FfiConverterTypeStorage INSTANCE = new FfiConverterTypeStorage();


    public override IntPtr Lower(Storage value) {
        return (IntPtr)handleMap.Insert(value);
    }

    public override Storage Lift(IntPtr value) {
        return new StorageImpl(value);
    }

    public override Storage Read(BigEndianStream stream) {
        return Lift(new IntPtr(stream.ReadLong()));
    }

    public override int AllocationSize(Storage value) {
        return 8;
    }

    public override void Write(Storage value, BigEndianStream stream) {
        stream.WriteLong(Lower(value).ToInt64());
    }
}



public record CheckLightningAddressRequest (
    string @username
) {
}

class FfiConverterTypeCheckLightningAddressRequest: FfiConverterRustBuffer<CheckLightningAddressRequest> {
    public static FfiConverterTypeCheckLightningAddressRequest INSTANCE = new FfiConverterTypeCheckLightningAddressRequest();

    public override CheckLightningAddressRequest Read(BigEndianStream stream) {
        return new CheckLightningAddressRequest(
            @username: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CheckLightningAddressRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@username);
    }

    public override void Write(CheckLightningAddressRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@username, stream);
    }
}



/// <param name="message">
/// The message that was signed
/// </param>
/// <param name="pubkey">
/// The public key that signed the message
/// </param>
/// <param name="signature">
/// The DER or compact hex encoded signature
/// </param>
public record CheckMessageRequest (
    /// <summary>
    /// The message that was signed
    /// </summary>
    string @message, 
    /// <summary>
    /// The public key that signed the message
    /// </summary>
    string @pubkey, 
    /// <summary>
    /// The DER or compact hex encoded signature
    /// </summary>
    string @signature
) {
}

class FfiConverterTypeCheckMessageRequest: FfiConverterRustBuffer<CheckMessageRequest> {
    public static FfiConverterTypeCheckMessageRequest INSTANCE = new FfiConverterTypeCheckMessageRequest();

    public override CheckMessageRequest Read(BigEndianStream stream) {
        return new CheckMessageRequest(
            @message: FfiConverterString.INSTANCE.Read(stream),
            @pubkey: FfiConverterString.INSTANCE.Read(stream),
            @signature: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CheckMessageRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@message)
            + FfiConverterString.INSTANCE.AllocationSize(value.@pubkey)
            + FfiConverterString.INSTANCE.AllocationSize(value.@signature);
    }

    public override void Write(CheckMessageRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@message, stream);
            FfiConverterString.INSTANCE.Write(value.@pubkey, stream);
            FfiConverterString.INSTANCE.Write(value.@signature, stream);
    }
}



public record CheckMessageResponse (
    bool @isValid
) {
}

class FfiConverterTypeCheckMessageResponse: FfiConverterRustBuffer<CheckMessageResponse> {
    public static FfiConverterTypeCheckMessageResponse INSTANCE = new FfiConverterTypeCheckMessageResponse();

    public override CheckMessageResponse Read(BigEndianStream stream) {
        return new CheckMessageResponse(
            @isValid: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(CheckMessageResponse value) {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isValid);
    }

    public override void Write(CheckMessageResponse value, BigEndianStream stream) {
            FfiConverterBoolean.INSTANCE.Write(value.@isValid, stream);
    }
}



public record ClaimDepositRequest (
    string @txid, 
    uint @vout, 
    Fee? @maxFee = null
) {
}

class FfiConverterTypeClaimDepositRequest: FfiConverterRustBuffer<ClaimDepositRequest> {
    public static FfiConverterTypeClaimDepositRequest INSTANCE = new FfiConverterTypeClaimDepositRequest();

    public override ClaimDepositRequest Read(BigEndianStream stream) {
        return new ClaimDepositRequest(
            @txid: FfiConverterString.INSTANCE.Read(stream),
            @vout: FfiConverterUInt32.INSTANCE.Read(stream),
            @maxFee: FfiConverterOptionalTypeFee.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ClaimDepositRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@txid)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@vout)
            + FfiConverterOptionalTypeFee.INSTANCE.AllocationSize(value.@maxFee);
    }

    public override void Write(ClaimDepositRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@txid, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@vout, stream);
            FfiConverterOptionalTypeFee.INSTANCE.Write(value.@maxFee, stream);
    }
}



public record ClaimDepositResponse (
    Payment @payment
) {
}

class FfiConverterTypeClaimDepositResponse: FfiConverterRustBuffer<ClaimDepositResponse> {
    public static FfiConverterTypeClaimDepositResponse INSTANCE = new FfiConverterTypeClaimDepositResponse();

    public override ClaimDepositResponse Read(BigEndianStream stream) {
        return new ClaimDepositResponse(
            @payment: FfiConverterTypePayment.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ClaimDepositResponse value) {
        return 0
            + FfiConverterTypePayment.INSTANCE.AllocationSize(value.@payment);
    }

    public override void Write(ClaimDepositResponse value, BigEndianStream stream) {
            FfiConverterTypePayment.INSTANCE.Write(value.@payment, stream);
    }
}



/// <param name="lnurl_domain">
/// The domain used for receiving through lnurl-pay and lightning address.
/// </param>
/// <param name="prefer_spark_over_lightning">
/// When this is set to `true` we will prefer to use spark payments over
/// lightning when sending and receiving. This has the benefit of lower fees
/// but is at the cost of privacy.
/// </param>
/// <param name="external_input_parsers">
/// A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
/// is not recognized. See [`ExternalInputParser`] for more details on how to configure
/// external parsing.
/// </param>
/// <param name="use_default_external_input_parsers">
/// The SDK includes some default external input parsers
/// ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
/// Set this to false in order to prevent their use.
/// </param>
/// <param name="real_time_sync_server_url">
/// Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
/// </param>
public record Config (
    string? @apiKey, 
    Network @network, 
    uint @syncIntervalSecs, 
    Fee? @maxDepositClaimFee, 
    /// <summary>
    /// The domain used for receiving through lnurl-pay and lightning address.
    /// </summary>
    string? @lnurlDomain, 
    /// <summary>
    /// When this is set to `true` we will prefer to use spark payments over
    /// lightning when sending and receiving. This has the benefit of lower fees
    /// but is at the cost of privacy.
    /// </summary>
    bool @preferSparkOverLightning, 
    /// <summary>
    /// A set of external input parsers that are used by [`BreezSdk::parse`](crate::sdk::BreezSdk::parse) when the input
    /// is not recognized. See [`ExternalInputParser`] for more details on how to configure
    /// external parsing.
    /// </summary>
    List<ExternalInputParser>? @externalInputParsers, 
    /// <summary>
    /// The SDK includes some default external input parsers
    /// ([`DEFAULT_EXTERNAL_INPUT_PARSERS`]).
    /// Set this to false in order to prevent their use.
    /// </summary>
    bool @useDefaultExternalInputParsers, 
    /// <summary>
    /// Url to use for the real-time sync server. Defaults to the Breez real-time sync server.
    /// </summary>
    string? @realTimeSyncServerUrl
) {
}

class FfiConverterTypeConfig: FfiConverterRustBuffer<Config> {
    public static FfiConverterTypeConfig INSTANCE = new FfiConverterTypeConfig();

    public override Config Read(BigEndianStream stream) {
        return new Config(
            @apiKey: FfiConverterOptionalString.INSTANCE.Read(stream),
            @network: FfiConverterTypeNetwork.INSTANCE.Read(stream),
            @syncIntervalSecs: FfiConverterUInt32.INSTANCE.Read(stream),
            @maxDepositClaimFee: FfiConverterOptionalTypeFee.INSTANCE.Read(stream),
            @lnurlDomain: FfiConverterOptionalString.INSTANCE.Read(stream),
            @preferSparkOverLightning: FfiConverterBoolean.INSTANCE.Read(stream),
            @externalInputParsers: FfiConverterOptionalSequenceTypeExternalInputParser.INSTANCE.Read(stream),
            @useDefaultExternalInputParsers: FfiConverterBoolean.INSTANCE.Read(stream),
            @realTimeSyncServerUrl: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Config value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@apiKey)
            + FfiConverterTypeNetwork.INSTANCE.AllocationSize(value.@network)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@syncIntervalSecs)
            + FfiConverterOptionalTypeFee.INSTANCE.AllocationSize(value.@maxDepositClaimFee)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@lnurlDomain)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@preferSparkOverLightning)
            + FfiConverterOptionalSequenceTypeExternalInputParser.INSTANCE.AllocationSize(value.@externalInputParsers)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@useDefaultExternalInputParsers)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@realTimeSyncServerUrl);
    }

    public override void Write(Config value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@apiKey, stream);
            FfiConverterTypeNetwork.INSTANCE.Write(value.@network, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@syncIntervalSecs, stream);
            FfiConverterOptionalTypeFee.INSTANCE.Write(value.@maxDepositClaimFee, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@lnurlDomain, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@preferSparkOverLightning, stream);
            FfiConverterOptionalSequenceTypeExternalInputParser.INSTANCE.Write(value.@externalInputParsers, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@useDefaultExternalInputParsers, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@realTimeSyncServerUrl, stream);
    }
}



public record ConnectRequest (
    Config @config, 
    Seed @seed, 
    string @storageDir
) {
}

class FfiConverterTypeConnectRequest: FfiConverterRustBuffer<ConnectRequest> {
    public static FfiConverterTypeConnectRequest INSTANCE = new FfiConverterTypeConnectRequest();

    public override ConnectRequest Read(BigEndianStream stream) {
        return new ConnectRequest(
            @config: FfiConverterTypeConfig.INSTANCE.Read(stream),
            @seed: FfiConverterTypeSeed.INSTANCE.Read(stream),
            @storageDir: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ConnectRequest value) {
        return 0
            + FfiConverterTypeConfig.INSTANCE.AllocationSize(value.@config)
            + FfiConverterTypeSeed.INSTANCE.AllocationSize(value.@seed)
            + FfiConverterString.INSTANCE.AllocationSize(value.@storageDir);
    }

    public override void Write(ConnectRequest value, BigEndianStream stream) {
            FfiConverterTypeConfig.INSTANCE.Write(value.@config, stream);
            FfiConverterTypeSeed.INSTANCE.Write(value.@seed, stream);
            FfiConverterString.INSTANCE.Write(value.@storageDir, stream);
    }
}



public record Credentials (
    string @username, 
    string @password
) {
}

class FfiConverterTypeCredentials: FfiConverterRustBuffer<Credentials> {
    public static FfiConverterTypeCredentials INSTANCE = new FfiConverterTypeCredentials();

    public override Credentials Read(BigEndianStream stream) {
        return new Credentials(
            @username: FfiConverterString.INSTANCE.Read(stream),
            @password: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Credentials value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@username)
            + FfiConverterString.INSTANCE.AllocationSize(value.@password);
    }

    public override void Write(Credentials value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@username, stream);
            FfiConverterString.INSTANCE.Write(value.@password, stream);
    }
}



public record DepositInfo (
    string @txid, 
    uint @vout, 
    ulong @amountSats, 
    string? @refundTx, 
    string? @refundTxId, 
    DepositClaimError? @claimError
) {
}

class FfiConverterTypeDepositInfo: FfiConverterRustBuffer<DepositInfo> {
    public static FfiConverterTypeDepositInfo INSTANCE = new FfiConverterTypeDepositInfo();

    public override DepositInfo Read(BigEndianStream stream) {
        return new DepositInfo(
            @txid: FfiConverterString.INSTANCE.Read(stream),
            @vout: FfiConverterUInt32.INSTANCE.Read(stream),
            @amountSats: FfiConverterUInt64.INSTANCE.Read(stream),
            @refundTx: FfiConverterOptionalString.INSTANCE.Read(stream),
            @refundTxId: FfiConverterOptionalString.INSTANCE.Read(stream),
            @claimError: FfiConverterOptionalTypeDepositClaimError.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(DepositInfo value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@txid)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@vout)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@amountSats)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@refundTx)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@refundTxId)
            + FfiConverterOptionalTypeDepositClaimError.INSTANCE.AllocationSize(value.@claimError);
    }

    public override void Write(DepositInfo value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@txid, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@vout, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@amountSats, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@refundTx, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@refundTxId, stream);
            FfiConverterOptionalTypeDepositClaimError.INSTANCE.Write(value.@claimError, stream);
    }
}



/// <summary>
/// Request to get the balance of the wallet
/// </summary>
public record GetInfoRequest (
    bool? @ensureSynced
) {
}

class FfiConverterTypeGetInfoRequest: FfiConverterRustBuffer<GetInfoRequest> {
    public static FfiConverterTypeGetInfoRequest INSTANCE = new FfiConverterTypeGetInfoRequest();

    public override GetInfoRequest Read(BigEndianStream stream) {
        return new GetInfoRequest(
            @ensureSynced: FfiConverterOptionalBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(GetInfoRequest value) {
        return 0
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@ensureSynced);
    }

    public override void Write(GetInfoRequest value, BigEndianStream stream) {
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@ensureSynced, stream);
    }
}



/// <summary>
/// Response containing the balance of the wallet
/// </summary>
/// <param name="balance_sats">
/// The balance in satoshis
/// </param>
/// <param name="token_balances">
/// The balances of the tokens in the wallet keyed by the token identifier
/// </param>
public record GetInfoResponse (
    /// <summary>
    /// The balance in satoshis
    /// </summary>
    ulong @balanceSats, 
    /// <summary>
    /// The balances of the tokens in the wallet keyed by the token identifier
    /// </summary>
    Dictionary<string, TokenBalance> @tokenBalances
) {
}

class FfiConverterTypeGetInfoResponse: FfiConverterRustBuffer<GetInfoResponse> {
    public static FfiConverterTypeGetInfoResponse INSTANCE = new FfiConverterTypeGetInfoResponse();

    public override GetInfoResponse Read(BigEndianStream stream) {
        return new GetInfoResponse(
            @balanceSats: FfiConverterUInt64.INSTANCE.Read(stream),
            @tokenBalances: FfiConverterDictionaryStringTypeTokenBalance.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(GetInfoResponse value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@balanceSats)
            + FfiConverterDictionaryStringTypeTokenBalance.INSTANCE.AllocationSize(value.@tokenBalances);
    }

    public override void Write(GetInfoResponse value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@balanceSats, stream);
            FfiConverterDictionaryStringTypeTokenBalance.INSTANCE.Write(value.@tokenBalances, stream);
    }
}



public record GetPaymentRequest (
    string @paymentId
) {
}

class FfiConverterTypeGetPaymentRequest: FfiConverterRustBuffer<GetPaymentRequest> {
    public static FfiConverterTypeGetPaymentRequest INSTANCE = new FfiConverterTypeGetPaymentRequest();

    public override GetPaymentRequest Read(BigEndianStream stream) {
        return new GetPaymentRequest(
            @paymentId: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(GetPaymentRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@paymentId);
    }

    public override void Write(GetPaymentRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@paymentId, stream);
    }
}



public record GetPaymentResponse (
    Payment @payment
) {
}

class FfiConverterTypeGetPaymentResponse: FfiConverterRustBuffer<GetPaymentResponse> {
    public static FfiConverterTypeGetPaymentResponse INSTANCE = new FfiConverterTypeGetPaymentResponse();

    public override GetPaymentResponse Read(BigEndianStream stream) {
        return new GetPaymentResponse(
            @payment: FfiConverterTypePayment.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(GetPaymentResponse value) {
        return 0
            + FfiConverterTypePayment.INSTANCE.AllocationSize(value.@payment);
    }

    public override void Write(GetPaymentResponse value, BigEndianStream stream) {
            FfiConverterTypePayment.INSTANCE.Write(value.@payment, stream);
    }
}



public record GetTokensMetadataRequest (
    List<string> @tokenIdentifiers
) {
}

class FfiConverterTypeGetTokensMetadataRequest: FfiConverterRustBuffer<GetTokensMetadataRequest> {
    public static FfiConverterTypeGetTokensMetadataRequest INSTANCE = new FfiConverterTypeGetTokensMetadataRequest();

    public override GetTokensMetadataRequest Read(BigEndianStream stream) {
        return new GetTokensMetadataRequest(
            @tokenIdentifiers: FfiConverterSequenceString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(GetTokensMetadataRequest value) {
        return 0
            + FfiConverterSequenceString.INSTANCE.AllocationSize(value.@tokenIdentifiers);
    }

    public override void Write(GetTokensMetadataRequest value, BigEndianStream stream) {
            FfiConverterSequenceString.INSTANCE.Write(value.@tokenIdentifiers, stream);
    }
}



public record GetTokensMetadataResponse (
    List<TokenMetadata> @tokensMetadata
) {
}

class FfiConverterTypeGetTokensMetadataResponse: FfiConverterRustBuffer<GetTokensMetadataResponse> {
    public static FfiConverterTypeGetTokensMetadataResponse INSTANCE = new FfiConverterTypeGetTokensMetadataResponse();

    public override GetTokensMetadataResponse Read(BigEndianStream stream) {
        return new GetTokensMetadataResponse(
            @tokensMetadata: FfiConverterSequenceTypeTokenMetadata.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(GetTokensMetadataResponse value) {
        return 0
            + FfiConverterSequenceTypeTokenMetadata.INSTANCE.AllocationSize(value.@tokensMetadata);
    }

    public override void Write(GetTokensMetadataResponse value, BigEndianStream stream) {
            FfiConverterSequenceTypeTokenMetadata.INSTANCE.Write(value.@tokensMetadata, stream);
    }
}



public record LightningAddressInfo (
    string @description, 
    string @lightningAddress, 
    string @lnurl, 
    string @username
) {
}

class FfiConverterTypeLightningAddressInfo: FfiConverterRustBuffer<LightningAddressInfo> {
    public static FfiConverterTypeLightningAddressInfo INSTANCE = new FfiConverterTypeLightningAddressInfo();

    public override LightningAddressInfo Read(BigEndianStream stream) {
        return new LightningAddressInfo(
            @description: FfiConverterString.INSTANCE.Read(stream),
            @lightningAddress: FfiConverterString.INSTANCE.Read(stream),
            @lnurl: FfiConverterString.INSTANCE.Read(stream),
            @username: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LightningAddressInfo value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterString.INSTANCE.AllocationSize(value.@lightningAddress)
            + FfiConverterString.INSTANCE.AllocationSize(value.@lnurl)
            + FfiConverterString.INSTANCE.AllocationSize(value.@username);
    }

    public override void Write(LightningAddressInfo value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@description, stream);
            FfiConverterString.INSTANCE.Write(value.@lightningAddress, stream);
            FfiConverterString.INSTANCE.Write(value.@lnurl, stream);
            FfiConverterString.INSTANCE.Write(value.@username, stream);
    }
}



/// <summary>
/// Response from listing fiat currencies
/// </summary>
/// <param name="currencies">
/// The list of fiat currencies
/// </param>
public record ListFiatCurrenciesResponse (
    /// <summary>
    /// The list of fiat currencies
    /// </summary>
    List<FiatCurrency> @currencies
) {
}

class FfiConverterTypeListFiatCurrenciesResponse: FfiConverterRustBuffer<ListFiatCurrenciesResponse> {
    public static FfiConverterTypeListFiatCurrenciesResponse INSTANCE = new FfiConverterTypeListFiatCurrenciesResponse();

    public override ListFiatCurrenciesResponse Read(BigEndianStream stream) {
        return new ListFiatCurrenciesResponse(
            @currencies: FfiConverterSequenceTypeFiatCurrency.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ListFiatCurrenciesResponse value) {
        return 0
            + FfiConverterSequenceTypeFiatCurrency.INSTANCE.AllocationSize(value.@currencies);
    }

    public override void Write(ListFiatCurrenciesResponse value, BigEndianStream stream) {
            FfiConverterSequenceTypeFiatCurrency.INSTANCE.Write(value.@currencies, stream);
    }
}



/// <summary>
/// Response from listing fiat rates
/// </summary>
/// <param name="rates">
/// The list of fiat rates
/// </param>
public record ListFiatRatesResponse (
    /// <summary>
    /// The list of fiat rates
    /// </summary>
    List<Rate> @rates
) {
}

class FfiConverterTypeListFiatRatesResponse: FfiConverterRustBuffer<ListFiatRatesResponse> {
    public static FfiConverterTypeListFiatRatesResponse INSTANCE = new FfiConverterTypeListFiatRatesResponse();

    public override ListFiatRatesResponse Read(BigEndianStream stream) {
        return new ListFiatRatesResponse(
            @rates: FfiConverterSequenceTypeRate.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ListFiatRatesResponse value) {
        return 0
            + FfiConverterSequenceTypeRate.INSTANCE.AllocationSize(value.@rates);
    }

    public override void Write(ListFiatRatesResponse value, BigEndianStream stream) {
            FfiConverterSequenceTypeRate.INSTANCE.Write(value.@rates, stream);
    }
}



/// <summary>
/// Request to list payments with optional filters and pagination
/// </summary>
/// <param name="from_timestamp">
/// Only include payments created after this timestamp (inclusive)
/// </param>
/// <param name="to_timestamp">
/// Only include payments created before this timestamp (exclusive)
/// </param>
/// <param name="offset">
/// Number of records to skip
/// </param>
/// <param name="limit">
/// Maximum number of records to return
/// </param>
public record ListPaymentsRequest (
    List<PaymentType>? @typeFilter = null, 
    List<PaymentStatus>? @statusFilter = null, 
    AssetFilter? @assetFilter = null, 
    /// <summary>
    /// Only include payments created after this timestamp (inclusive)
    /// </summary>
    ulong? @fromTimestamp = null, 
    /// <summary>
    /// Only include payments created before this timestamp (exclusive)
    /// </summary>
    ulong? @toTimestamp = null, 
    /// <summary>
    /// Number of records to skip
    /// </summary>
    uint? @offset = null, 
    /// <summary>
    /// Maximum number of records to return
    /// </summary>
    uint? @limit = null, 
    bool? @sortAscending = null
) {
}

class FfiConverterTypeListPaymentsRequest: FfiConverterRustBuffer<ListPaymentsRequest> {
    public static FfiConverterTypeListPaymentsRequest INSTANCE = new FfiConverterTypeListPaymentsRequest();

    public override ListPaymentsRequest Read(BigEndianStream stream) {
        return new ListPaymentsRequest(
            @typeFilter: FfiConverterOptionalSequenceTypePaymentType.INSTANCE.Read(stream),
            @statusFilter: FfiConverterOptionalSequenceTypePaymentStatus.INSTANCE.Read(stream),
            @assetFilter: FfiConverterOptionalTypeAssetFilter.INSTANCE.Read(stream),
            @fromTimestamp: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @toTimestamp: FfiConverterOptionalUInt64.INSTANCE.Read(stream),
            @offset: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @limit: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @sortAscending: FfiConverterOptionalBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ListPaymentsRequest value) {
        return 0
            + FfiConverterOptionalSequenceTypePaymentType.INSTANCE.AllocationSize(value.@typeFilter)
            + FfiConverterOptionalSequenceTypePaymentStatus.INSTANCE.AllocationSize(value.@statusFilter)
            + FfiConverterOptionalTypeAssetFilter.INSTANCE.AllocationSize(value.@assetFilter)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@fromTimestamp)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@toTimestamp)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@offset)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@limit)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@sortAscending);
    }

    public override void Write(ListPaymentsRequest value, BigEndianStream stream) {
            FfiConverterOptionalSequenceTypePaymentType.INSTANCE.Write(value.@typeFilter, stream);
            FfiConverterOptionalSequenceTypePaymentStatus.INSTANCE.Write(value.@statusFilter, stream);
            FfiConverterOptionalTypeAssetFilter.INSTANCE.Write(value.@assetFilter, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@fromTimestamp, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@toTimestamp, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@offset, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@limit, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@sortAscending, stream);
    }
}



/// <summary>
/// Response from listing payments
/// </summary>
/// <param name="payments">
/// The list of payments
/// </param>
public record ListPaymentsResponse (
    /// <summary>
    /// The list of payments
    /// </summary>
    List<Payment> @payments
) {
}

class FfiConverterTypeListPaymentsResponse: FfiConverterRustBuffer<ListPaymentsResponse> {
    public static FfiConverterTypeListPaymentsResponse INSTANCE = new FfiConverterTypeListPaymentsResponse();

    public override ListPaymentsResponse Read(BigEndianStream stream) {
        return new ListPaymentsResponse(
            @payments: FfiConverterSequenceTypePayment.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ListPaymentsResponse value) {
        return 0
            + FfiConverterSequenceTypePayment.INSTANCE.AllocationSize(value.@payments);
    }

    public override void Write(ListPaymentsResponse value, BigEndianStream stream) {
            FfiConverterSequenceTypePayment.INSTANCE.Write(value.@payments, stream);
    }
}



public record ListUnclaimedDepositsRequest (
) {
}

class FfiConverterTypeListUnclaimedDepositsRequest: FfiConverterRustBuffer<ListUnclaimedDepositsRequest> {
    public static FfiConverterTypeListUnclaimedDepositsRequest INSTANCE = new FfiConverterTypeListUnclaimedDepositsRequest();

    public override ListUnclaimedDepositsRequest Read(BigEndianStream stream) {
        return new ListUnclaimedDepositsRequest(
        );
    }

    public override int AllocationSize(ListUnclaimedDepositsRequest value) {
        return 0;
    }

    public override void Write(ListUnclaimedDepositsRequest value, BigEndianStream stream) {
    }
}



public record ListUnclaimedDepositsResponse (
    List<DepositInfo> @deposits
) {
}

class FfiConverterTypeListUnclaimedDepositsResponse: FfiConverterRustBuffer<ListUnclaimedDepositsResponse> {
    public static FfiConverterTypeListUnclaimedDepositsResponse INSTANCE = new FfiConverterTypeListUnclaimedDepositsResponse();

    public override ListUnclaimedDepositsResponse Read(BigEndianStream stream) {
        return new ListUnclaimedDepositsResponse(
            @deposits: FfiConverterSequenceTypeDepositInfo.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ListUnclaimedDepositsResponse value) {
        return 0
            + FfiConverterSequenceTypeDepositInfo.INSTANCE.AllocationSize(value.@deposits);
    }

    public override void Write(ListUnclaimedDepositsResponse value, BigEndianStream stream) {
            FfiConverterSequenceTypeDepositInfo.INSTANCE.Write(value.@deposits, stream);
    }
}



/// <summary>
/// Represents the payment LNURL info
/// </summary>
public record LnurlPayInfo (
    string? @lnAddress, 
    string? @comment, 
    string? @domain, 
    string? @metadata, 
    SuccessActionProcessed? @processedSuccessAction, 
    SuccessAction? @rawSuccessAction
) {
}

class FfiConverterTypeLnurlPayInfo: FfiConverterRustBuffer<LnurlPayInfo> {
    public static FfiConverterTypeLnurlPayInfo INSTANCE = new FfiConverterTypeLnurlPayInfo();

    public override LnurlPayInfo Read(BigEndianStream stream) {
        return new LnurlPayInfo(
            @lnAddress: FfiConverterOptionalString.INSTANCE.Read(stream),
            @comment: FfiConverterOptionalString.INSTANCE.Read(stream),
            @domain: FfiConverterOptionalString.INSTANCE.Read(stream),
            @metadata: FfiConverterOptionalString.INSTANCE.Read(stream),
            @processedSuccessAction: FfiConverterOptionalTypeSuccessActionProcessed.INSTANCE.Read(stream),
            @rawSuccessAction: FfiConverterOptionalTypeSuccessAction.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlPayInfo value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@lnAddress)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@comment)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@domain)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@metadata)
            + FfiConverterOptionalTypeSuccessActionProcessed.INSTANCE.AllocationSize(value.@processedSuccessAction)
            + FfiConverterOptionalTypeSuccessAction.INSTANCE.AllocationSize(value.@rawSuccessAction);
    }

    public override void Write(LnurlPayInfo value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@lnAddress, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@comment, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@domain, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@metadata, stream);
            FfiConverterOptionalTypeSuccessActionProcessed.INSTANCE.Write(value.@processedSuccessAction, stream);
            FfiConverterOptionalTypeSuccessAction.INSTANCE.Write(value.@rawSuccessAction, stream);
    }
}



public record LnurlPayRequest (
    PrepareLnurlPayResponse @prepareResponse
) {
}

class FfiConverterTypeLnurlPayRequest: FfiConverterRustBuffer<LnurlPayRequest> {
    public static FfiConverterTypeLnurlPayRequest INSTANCE = new FfiConverterTypeLnurlPayRequest();

    public override LnurlPayRequest Read(BigEndianStream stream) {
        return new LnurlPayRequest(
            @prepareResponse: FfiConverterTypePrepareLnurlPayResponse.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlPayRequest value) {
        return 0
            + FfiConverterTypePrepareLnurlPayResponse.INSTANCE.AllocationSize(value.@prepareResponse);
    }

    public override void Write(LnurlPayRequest value, BigEndianStream stream) {
            FfiConverterTypePrepareLnurlPayResponse.INSTANCE.Write(value.@prepareResponse, stream);
    }
}



public record LnurlPayResponse (
    Payment @payment, 
    SuccessActionProcessed? @successAction
) {
}

class FfiConverterTypeLnurlPayResponse: FfiConverterRustBuffer<LnurlPayResponse> {
    public static FfiConverterTypeLnurlPayResponse INSTANCE = new FfiConverterTypeLnurlPayResponse();

    public override LnurlPayResponse Read(BigEndianStream stream) {
        return new LnurlPayResponse(
            @payment: FfiConverterTypePayment.INSTANCE.Read(stream),
            @successAction: FfiConverterOptionalTypeSuccessActionProcessed.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlPayResponse value) {
        return 0
            + FfiConverterTypePayment.INSTANCE.AllocationSize(value.@payment)
            + FfiConverterOptionalTypeSuccessActionProcessed.INSTANCE.AllocationSize(value.@successAction);
    }

    public override void Write(LnurlPayResponse value, BigEndianStream stream) {
            FfiConverterTypePayment.INSTANCE.Write(value.@payment, stream);
            FfiConverterOptionalTypeSuccessActionProcessed.INSTANCE.Write(value.@successAction, stream);
    }
}



/// <summary>
/// Represents the withdraw LNURL info
/// </summary>
public record LnurlWithdrawInfo (
    string @withdrawUrl
) {
}

class FfiConverterTypeLnurlWithdrawInfo: FfiConverterRustBuffer<LnurlWithdrawInfo> {
    public static FfiConverterTypeLnurlWithdrawInfo INSTANCE = new FfiConverterTypeLnurlWithdrawInfo();

    public override LnurlWithdrawInfo Read(BigEndianStream stream) {
        return new LnurlWithdrawInfo(
            @withdrawUrl: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlWithdrawInfo value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@withdrawUrl);
    }

    public override void Write(LnurlWithdrawInfo value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@withdrawUrl, stream);
    }
}



/// <param name="amount_sats">
/// The amount to withdraw in satoshis
/// Must be within the min and max withdrawable limits
/// </param>
/// <param name="completion_timeout_secs">
/// If set, the function will return the payment if it is still pending after this
/// number of seconds. If unset, the function will return immediately after
/// initiating the LNURL withdraw.
/// </param>
public record LnurlWithdrawRequest (
    /// <summary>
    /// The amount to withdraw in satoshis
    /// Must be within the min and max withdrawable limits
    /// </summary>
    ulong @amountSats, 
    LnurlWithdrawRequestDetails @withdrawRequest, 
    /// <summary>
    /// If set, the function will return the payment if it is still pending after this
    /// number of seconds. If unset, the function will return immediately after
    /// initiating the LNURL withdraw.
    /// </summary>
    uint? @completionTimeoutSecs = null
) {
}

class FfiConverterTypeLnurlWithdrawRequest: FfiConverterRustBuffer<LnurlWithdrawRequest> {
    public static FfiConverterTypeLnurlWithdrawRequest INSTANCE = new FfiConverterTypeLnurlWithdrawRequest();

    public override LnurlWithdrawRequest Read(BigEndianStream stream) {
        return new LnurlWithdrawRequest(
            @amountSats: FfiConverterUInt64.INSTANCE.Read(stream),
            @withdrawRequest: FfiConverterTypeLnurlWithdrawRequestDetails.INSTANCE.Read(stream),
            @completionTimeoutSecs: FfiConverterOptionalUInt32.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlWithdrawRequest value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@amountSats)
            + FfiConverterTypeLnurlWithdrawRequestDetails.INSTANCE.AllocationSize(value.@withdrawRequest)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@completionTimeoutSecs);
    }

    public override void Write(LnurlWithdrawRequest value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@amountSats, stream);
            FfiConverterTypeLnurlWithdrawRequestDetails.INSTANCE.Write(value.@withdrawRequest, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@completionTimeoutSecs, stream);
    }
}



/// <param name="payment_request">
/// The Lightning invoice generated for the LNURL withdraw
/// </param>
public record LnurlWithdrawResponse (
    /// <summary>
    /// The Lightning invoice generated for the LNURL withdraw
    /// </summary>
    string @paymentRequest, 
    Payment? @payment
) {
}

class FfiConverterTypeLnurlWithdrawResponse: FfiConverterRustBuffer<LnurlWithdrawResponse> {
    public static FfiConverterTypeLnurlWithdrawResponse INSTANCE = new FfiConverterTypeLnurlWithdrawResponse();

    public override LnurlWithdrawResponse Read(BigEndianStream stream) {
        return new LnurlWithdrawResponse(
            @paymentRequest: FfiConverterString.INSTANCE.Read(stream),
            @payment: FfiConverterOptionalTypePayment.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LnurlWithdrawResponse value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@paymentRequest)
            + FfiConverterOptionalTypePayment.INSTANCE.AllocationSize(value.@payment);
    }

    public override void Write(LnurlWithdrawResponse value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@paymentRequest, stream);
            FfiConverterOptionalTypePayment.INSTANCE.Write(value.@payment, stream);
    }
}



public record LogEntry (
    string @line, 
    string @level
) {
}

class FfiConverterTypeLogEntry: FfiConverterRustBuffer<LogEntry> {
    public static FfiConverterTypeLogEntry INSTANCE = new FfiConverterTypeLogEntry();

    public override LogEntry Read(BigEndianStream stream) {
        return new LogEntry(
            @line: FfiConverterString.INSTANCE.Read(stream),
            @level: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(LogEntry value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@line)
            + FfiConverterString.INSTANCE.AllocationSize(value.@level);
    }

    public override void Write(LogEntry value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@line, stream);
            FfiConverterString.INSTANCE.Write(value.@level, stream);
    }
}



/// <summary>
/// Represents a payment (sent or received)
/// </summary>
/// <param name="id">
/// Unique identifier for the payment
/// </param>
/// <param name="payment_type">
/// Type of payment (send or receive)
/// </param>
/// <param name="status">
/// Status of the payment
/// </param>
/// <param name="amount">
/// Amount in satoshis or token base units
/// </param>
/// <param name="fees">
/// Fee paid in satoshis or token base units
/// </param>
/// <param name="timestamp">
/// Timestamp of when the payment was created
/// </param>
/// <param name="method">
/// Method of payment. Sometimes the payment details is empty so this field
/// is used to determine the payment method.
/// </param>
/// <param name="details">
/// Details of the payment
/// </param>
public record Payment (
    /// <summary>
    /// Unique identifier for the payment
    /// </summary>
    string @id, 
    /// <summary>
    /// Type of payment (send or receive)
    /// </summary>
    PaymentType @paymentType, 
    /// <summary>
    /// Status of the payment
    /// </summary>
    PaymentStatus @status, 
    /// <summary>
    /// Amount in satoshis or token base units
    /// </summary>
    u128 @amount, 
    /// <summary>
    /// Fee paid in satoshis or token base units
    /// </summary>
    u128 @fees, 
    /// <summary>
    /// Timestamp of when the payment was created
    /// </summary>
    ulong @timestamp, 
    /// <summary>
    /// Method of payment. Sometimes the payment details is empty so this field
    /// is used to determine the payment method.
    /// </summary>
    PaymentMethod @method, 
    /// <summary>
    /// Details of the payment
    /// </summary>
    PaymentDetails? @details
) {
}

class FfiConverterTypePayment: FfiConverterRustBuffer<Payment> {
    public static FfiConverterTypePayment INSTANCE = new FfiConverterTypePayment();

    public override Payment Read(BigEndianStream stream) {
        return new Payment(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @paymentType: FfiConverterTypePaymentType.INSTANCE.Read(stream),
            @status: FfiConverterTypePaymentStatus.INSTANCE.Read(stream),
            @amount: FfiConverterTypeu128.INSTANCE.Read(stream),
            @fees: FfiConverterTypeu128.INSTANCE.Read(stream),
            @timestamp: FfiConverterUInt64.INSTANCE.Read(stream),
            @method: FfiConverterTypePaymentMethod.INSTANCE.Read(stream),
            @details: FfiConverterOptionalTypePaymentDetails.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Payment value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterTypePaymentType.INSTANCE.AllocationSize(value.@paymentType)
            + FfiConverterTypePaymentStatus.INSTANCE.AllocationSize(value.@status)
            + FfiConverterTypeu128.INSTANCE.AllocationSize(value.@amount)
            + FfiConverterTypeu128.INSTANCE.AllocationSize(value.@fees)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@timestamp)
            + FfiConverterTypePaymentMethod.INSTANCE.AllocationSize(value.@method)
            + FfiConverterOptionalTypePaymentDetails.INSTANCE.AllocationSize(value.@details);
    }

    public override void Write(Payment value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterTypePaymentType.INSTANCE.Write(value.@paymentType, stream);
            FfiConverterTypePaymentStatus.INSTANCE.Write(value.@status, stream);
            FfiConverterTypeu128.INSTANCE.Write(value.@amount, stream);
            FfiConverterTypeu128.INSTANCE.Write(value.@fees, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@timestamp, stream);
            FfiConverterTypePaymentMethod.INSTANCE.Write(value.@method, stream);
            FfiConverterOptionalTypePaymentDetails.INSTANCE.Write(value.@details, stream);
    }
}



/// <summary>
/// Metadata associated with a payment that cannot be extracted from the Spark operator.
/// </summary>
public record PaymentMetadata (
    LnurlPayInfo? @lnurlPayInfo, 
    LnurlWithdrawInfo? @lnurlWithdrawInfo, 
    string? @lnurlDescription
) {
}

class FfiConverterTypePaymentMetadata: FfiConverterRustBuffer<PaymentMetadata> {
    public static FfiConverterTypePaymentMetadata INSTANCE = new FfiConverterTypePaymentMetadata();

    public override PaymentMetadata Read(BigEndianStream stream) {
        return new PaymentMetadata(
            @lnurlPayInfo: FfiConverterOptionalTypeLnurlPayInfo.INSTANCE.Read(stream),
            @lnurlWithdrawInfo: FfiConverterOptionalTypeLnurlWithdrawInfo.INSTANCE.Read(stream),
            @lnurlDescription: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PaymentMetadata value) {
        return 0
            + FfiConverterOptionalTypeLnurlPayInfo.INSTANCE.AllocationSize(value.@lnurlPayInfo)
            + FfiConverterOptionalTypeLnurlWithdrawInfo.INSTANCE.AllocationSize(value.@lnurlWithdrawInfo)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@lnurlDescription);
    }

    public override void Write(PaymentMetadata value, BigEndianStream stream) {
            FfiConverterOptionalTypeLnurlPayInfo.INSTANCE.Write(value.@lnurlPayInfo, stream);
            FfiConverterOptionalTypeLnurlWithdrawInfo.INSTANCE.Write(value.@lnurlWithdrawInfo, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@lnurlDescription, stream);
    }
}



public record PrepareLnurlPayRequest (
    ulong @amountSats, 
    LnurlPayRequestDetails @payRequest, 
    string? @comment = null, 
    bool? @validateSuccessActionUrl = null
) {
}

class FfiConverterTypePrepareLnurlPayRequest: FfiConverterRustBuffer<PrepareLnurlPayRequest> {
    public static FfiConverterTypePrepareLnurlPayRequest INSTANCE = new FfiConverterTypePrepareLnurlPayRequest();

    public override PrepareLnurlPayRequest Read(BigEndianStream stream) {
        return new PrepareLnurlPayRequest(
            @amountSats: FfiConverterUInt64.INSTANCE.Read(stream),
            @payRequest: FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Read(stream),
            @comment: FfiConverterOptionalString.INSTANCE.Read(stream),
            @validateSuccessActionUrl: FfiConverterOptionalBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PrepareLnurlPayRequest value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@amountSats)
            + FfiConverterTypeLnurlPayRequestDetails.INSTANCE.AllocationSize(value.@payRequest)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@comment)
            + FfiConverterOptionalBoolean.INSTANCE.AllocationSize(value.@validateSuccessActionUrl);
    }

    public override void Write(PrepareLnurlPayRequest value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@amountSats, stream);
            FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Write(value.@payRequest, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@comment, stream);
            FfiConverterOptionalBoolean.INSTANCE.Write(value.@validateSuccessActionUrl, stream);
    }
}



public record PrepareLnurlPayResponse (
    ulong @amountSats, 
    string? @comment, 
    LnurlPayRequestDetails @payRequest, 
    ulong @feeSats, 
    Bolt11InvoiceDetails @invoiceDetails, 
    SuccessAction? @successAction
) {
}

class FfiConverterTypePrepareLnurlPayResponse: FfiConverterRustBuffer<PrepareLnurlPayResponse> {
    public static FfiConverterTypePrepareLnurlPayResponse INSTANCE = new FfiConverterTypePrepareLnurlPayResponse();

    public override PrepareLnurlPayResponse Read(BigEndianStream stream) {
        return new PrepareLnurlPayResponse(
            @amountSats: FfiConverterUInt64.INSTANCE.Read(stream),
            @comment: FfiConverterOptionalString.INSTANCE.Read(stream),
            @payRequest: FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Read(stream),
            @feeSats: FfiConverterUInt64.INSTANCE.Read(stream),
            @invoiceDetails: FfiConverterTypeBolt11InvoiceDetails.INSTANCE.Read(stream),
            @successAction: FfiConverterOptionalTypeSuccessAction.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PrepareLnurlPayResponse value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@amountSats)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@comment)
            + FfiConverterTypeLnurlPayRequestDetails.INSTANCE.AllocationSize(value.@payRequest)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@feeSats)
            + FfiConverterTypeBolt11InvoiceDetails.INSTANCE.AllocationSize(value.@invoiceDetails)
            + FfiConverterOptionalTypeSuccessAction.INSTANCE.AllocationSize(value.@successAction);
    }

    public override void Write(PrepareLnurlPayResponse value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@amountSats, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@comment, stream);
            FfiConverterTypeLnurlPayRequestDetails.INSTANCE.Write(value.@payRequest, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@feeSats, stream);
            FfiConverterTypeBolt11InvoiceDetails.INSTANCE.Write(value.@invoiceDetails, stream);
            FfiConverterOptionalTypeSuccessAction.INSTANCE.Write(value.@successAction, stream);
    }
}



/// <param name="amount">
/// Amount to send. By default is denominated in sats.
/// If a token identifier is provided, the amount will be denominated in the token base units.
/// </param>
/// <param name="token_identifier">
/// If provided, the payment will be for a token
/// May only be provided if the payment request is a spark address
/// </param>
public record PrepareSendPaymentRequest (
    string @paymentRequest, 
    /// <summary>
    /// Amount to send. By default is denominated in sats.
    /// If a token identifier is provided, the amount will be denominated in the token base units.
    /// </summary>
    u128? @amount = null, 
    /// <summary>
    /// If provided, the payment will be for a token
    /// May only be provided if the payment request is a spark address
    /// </summary>
    string? @tokenIdentifier = null
) {
}

class FfiConverterTypePrepareSendPaymentRequest: FfiConverterRustBuffer<PrepareSendPaymentRequest> {
    public static FfiConverterTypePrepareSendPaymentRequest INSTANCE = new FfiConverterTypePrepareSendPaymentRequest();

    public override PrepareSendPaymentRequest Read(BigEndianStream stream) {
        return new PrepareSendPaymentRequest(
            @paymentRequest: FfiConverterString.INSTANCE.Read(stream),
            @amount: FfiConverterOptionalTypeu128.INSTANCE.Read(stream),
            @tokenIdentifier: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PrepareSendPaymentRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@paymentRequest)
            + FfiConverterOptionalTypeu128.INSTANCE.AllocationSize(value.@amount)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@tokenIdentifier);
    }

    public override void Write(PrepareSendPaymentRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@paymentRequest, stream);
            FfiConverterOptionalTypeu128.INSTANCE.Write(value.@amount, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@tokenIdentifier, stream);
    }
}



/// <param name="amount">
/// Amount to send. By default is denominated in sats.
/// If a token identifier is provided, the amount will be denominated in the token base units.
/// </param>
/// <param name="token_identifier">
/// The presence of this field indicates that the payment is for a token
/// If empty, it is a Bitcoin payment
/// </param>
public record PrepareSendPaymentResponse (
    SendPaymentMethod @paymentMethod, 
    /// <summary>
    /// Amount to send. By default is denominated in sats.
    /// If a token identifier is provided, the amount will be denominated in the token base units.
    /// </summary>
    u128 @amount, 
    /// <summary>
    /// The presence of this field indicates that the payment is for a token
    /// If empty, it is a Bitcoin payment
    /// </summary>
    string? @tokenIdentifier
) {
}

class FfiConverterTypePrepareSendPaymentResponse: FfiConverterRustBuffer<PrepareSendPaymentResponse> {
    public static FfiConverterTypePrepareSendPaymentResponse INSTANCE = new FfiConverterTypePrepareSendPaymentResponse();

    public override PrepareSendPaymentResponse Read(BigEndianStream stream) {
        return new PrepareSendPaymentResponse(
            @paymentMethod: FfiConverterTypeSendPaymentMethod.INSTANCE.Read(stream),
            @amount: FfiConverterTypeu128.INSTANCE.Read(stream),
            @tokenIdentifier: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(PrepareSendPaymentResponse value) {
        return 0
            + FfiConverterTypeSendPaymentMethod.INSTANCE.AllocationSize(value.@paymentMethod)
            + FfiConverterTypeu128.INSTANCE.AllocationSize(value.@amount)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@tokenIdentifier);
    }

    public override void Write(PrepareSendPaymentResponse value, BigEndianStream stream) {
            FfiConverterTypeSendPaymentMethod.INSTANCE.Write(value.@paymentMethod, stream);
            FfiConverterTypeu128.INSTANCE.Write(value.@amount, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@tokenIdentifier, stream);
    }
}



/// <param name="payment_id">
/// Unique identifier for the payment
/// </param>
/// <param name="amount">
/// Amount in satoshis or token base units
/// </param>
/// <param name="details">
/// Details of the payment
/// </param>
public record ProvisionalPayment (
    /// <summary>
    /// Unique identifier for the payment
    /// </summary>
    string @paymentId, 
    /// <summary>
    /// Amount in satoshis or token base units
    /// </summary>
    u128 @amount, 
    /// <summary>
    /// Details of the payment
    /// </summary>
    ProvisionalPaymentDetails @details
) {
}

class FfiConverterTypeProvisionalPayment: FfiConverterRustBuffer<ProvisionalPayment> {
    public static FfiConverterTypeProvisionalPayment INSTANCE = new FfiConverterTypeProvisionalPayment();

    public override ProvisionalPayment Read(BigEndianStream stream) {
        return new ProvisionalPayment(
            @paymentId: FfiConverterString.INSTANCE.Read(stream),
            @amount: FfiConverterTypeu128.INSTANCE.Read(stream),
            @details: FfiConverterTypeProvisionalPaymentDetails.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ProvisionalPayment value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@paymentId)
            + FfiConverterTypeu128.INSTANCE.AllocationSize(value.@amount)
            + FfiConverterTypeProvisionalPaymentDetails.INSTANCE.AllocationSize(value.@details);
    }

    public override void Write(ProvisionalPayment value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@paymentId, stream);
            FfiConverterTypeu128.INSTANCE.Write(value.@amount, stream);
            FfiConverterTypeProvisionalPaymentDetails.INSTANCE.Write(value.@details, stream);
    }
}



public record ReceivePaymentRequest (
    ReceivePaymentMethod @paymentMethod
) {
}

class FfiConverterTypeReceivePaymentRequest: FfiConverterRustBuffer<ReceivePaymentRequest> {
    public static FfiConverterTypeReceivePaymentRequest INSTANCE = new FfiConverterTypeReceivePaymentRequest();

    public override ReceivePaymentRequest Read(BigEndianStream stream) {
        return new ReceivePaymentRequest(
            @paymentMethod: FfiConverterTypeReceivePaymentMethod.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ReceivePaymentRequest value) {
        return 0
            + FfiConverterTypeReceivePaymentMethod.INSTANCE.AllocationSize(value.@paymentMethod);
    }

    public override void Write(ReceivePaymentRequest value, BigEndianStream stream) {
            FfiConverterTypeReceivePaymentMethod.INSTANCE.Write(value.@paymentMethod, stream);
    }
}



/// <param name="fee">
/// Fee to pay to receive the payment
/// Denominated in sats or token base units
/// </param>
public record ReceivePaymentResponse (
    string @paymentRequest, 
    /// <summary>
    /// Fee to pay to receive the payment
    /// Denominated in sats or token base units
    /// </summary>
    u128 @fee
) {
}

class FfiConverterTypeReceivePaymentResponse: FfiConverterRustBuffer<ReceivePaymentResponse> {
    public static FfiConverterTypeReceivePaymentResponse INSTANCE = new FfiConverterTypeReceivePaymentResponse();

    public override ReceivePaymentResponse Read(BigEndianStream stream) {
        return new ReceivePaymentResponse(
            @paymentRequest: FfiConverterString.INSTANCE.Read(stream),
            @fee: FfiConverterTypeu128.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(ReceivePaymentResponse value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@paymentRequest)
            + FfiConverterTypeu128.INSTANCE.AllocationSize(value.@fee);
    }

    public override void Write(ReceivePaymentResponse value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@paymentRequest, stream);
            FfiConverterTypeu128.INSTANCE.Write(value.@fee, stream);
    }
}



public record RefundDepositRequest (
    string @txid, 
    uint @vout, 
    string @destinationAddress, 
    Fee @fee
) {
}

class FfiConverterTypeRefundDepositRequest: FfiConverterRustBuffer<RefundDepositRequest> {
    public static FfiConverterTypeRefundDepositRequest INSTANCE = new FfiConverterTypeRefundDepositRequest();

    public override RefundDepositRequest Read(BigEndianStream stream) {
        return new RefundDepositRequest(
            @txid: FfiConverterString.INSTANCE.Read(stream),
            @vout: FfiConverterUInt32.INSTANCE.Read(stream),
            @destinationAddress: FfiConverterString.INSTANCE.Read(stream),
            @fee: FfiConverterTypeFee.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RefundDepositRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@txid)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@vout)
            + FfiConverterString.INSTANCE.AllocationSize(value.@destinationAddress)
            + FfiConverterTypeFee.INSTANCE.AllocationSize(value.@fee);
    }

    public override void Write(RefundDepositRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@txid, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@vout, stream);
            FfiConverterString.INSTANCE.Write(value.@destinationAddress, stream);
            FfiConverterTypeFee.INSTANCE.Write(value.@fee, stream);
    }
}



public record RefundDepositResponse (
    string @txId, 
    string @txHex
) {
}

class FfiConverterTypeRefundDepositResponse: FfiConverterRustBuffer<RefundDepositResponse> {
    public static FfiConverterTypeRefundDepositResponse INSTANCE = new FfiConverterTypeRefundDepositResponse();

    public override RefundDepositResponse Read(BigEndianStream stream) {
        return new RefundDepositResponse(
            @txId: FfiConverterString.INSTANCE.Read(stream),
            @txHex: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RefundDepositResponse value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@txId)
            + FfiConverterString.INSTANCE.AllocationSize(value.@txHex);
    }

    public override void Write(RefundDepositResponse value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@txId, stream);
            FfiConverterString.INSTANCE.Write(value.@txHex, stream);
    }
}



public record RegisterLightningAddressRequest (
    string @username, 
    string? @description = null
) {
}

class FfiConverterTypeRegisterLightningAddressRequest: FfiConverterRustBuffer<RegisterLightningAddressRequest> {
    public static FfiConverterTypeRegisterLightningAddressRequest INSTANCE = new FfiConverterTypeRegisterLightningAddressRequest();

    public override RegisterLightningAddressRequest Read(BigEndianStream stream) {
        return new RegisterLightningAddressRequest(
            @username: FfiConverterString.INSTANCE.Read(stream),
            @description: FfiConverterOptionalString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(RegisterLightningAddressRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@username)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@description);
    }

    public override void Write(RegisterLightningAddressRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@username, stream);
            FfiConverterOptionalString.INSTANCE.Write(value.@description, stream);
    }
}



public record SendOnchainFeeQuote (
    string @id, 
    ulong @expiresAt, 
    SendOnchainSpeedFeeQuote @speedFast, 
    SendOnchainSpeedFeeQuote @speedMedium, 
    SendOnchainSpeedFeeQuote @speedSlow
) {
}

class FfiConverterTypeSendOnchainFeeQuote: FfiConverterRustBuffer<SendOnchainFeeQuote> {
    public static FfiConverterTypeSendOnchainFeeQuote INSTANCE = new FfiConverterTypeSendOnchainFeeQuote();

    public override SendOnchainFeeQuote Read(BigEndianStream stream) {
        return new SendOnchainFeeQuote(
            @id: FfiConverterString.INSTANCE.Read(stream),
            @expiresAt: FfiConverterUInt64.INSTANCE.Read(stream),
            @speedFast: FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.Read(stream),
            @speedMedium: FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.Read(stream),
            @speedSlow: FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SendOnchainFeeQuote value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@id)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@expiresAt)
            + FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.AllocationSize(value.@speedFast)
            + FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.AllocationSize(value.@speedMedium)
            + FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.AllocationSize(value.@speedSlow);
    }

    public override void Write(SendOnchainFeeQuote value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@id, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@expiresAt, stream);
            FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.Write(value.@speedFast, stream);
            FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.Write(value.@speedMedium, stream);
            FfiConverterTypeSendOnchainSpeedFeeQuote.INSTANCE.Write(value.@speedSlow, stream);
    }
}



public record SendOnchainSpeedFeeQuote (
    ulong @userFeeSat, 
    ulong @l1BroadcastFeeSat
) {
}

class FfiConverterTypeSendOnchainSpeedFeeQuote: FfiConverterRustBuffer<SendOnchainSpeedFeeQuote> {
    public static FfiConverterTypeSendOnchainSpeedFeeQuote INSTANCE = new FfiConverterTypeSendOnchainSpeedFeeQuote();

    public override SendOnchainSpeedFeeQuote Read(BigEndianStream stream) {
        return new SendOnchainSpeedFeeQuote(
            @userFeeSat: FfiConverterUInt64.INSTANCE.Read(stream),
            @l1BroadcastFeeSat: FfiConverterUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SendOnchainSpeedFeeQuote value) {
        return 0
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@userFeeSat)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@l1BroadcastFeeSat);
    }

    public override void Write(SendOnchainSpeedFeeQuote value, BigEndianStream stream) {
            FfiConverterUInt64.INSTANCE.Write(value.@userFeeSat, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@l1BroadcastFeeSat, stream);
    }
}



public record SendPaymentRequest (
    PrepareSendPaymentResponse @prepareResponse, 
    SendPaymentOptions? @options = null
) {
}

class FfiConverterTypeSendPaymentRequest: FfiConverterRustBuffer<SendPaymentRequest> {
    public static FfiConverterTypeSendPaymentRequest INSTANCE = new FfiConverterTypeSendPaymentRequest();

    public override SendPaymentRequest Read(BigEndianStream stream) {
        return new SendPaymentRequest(
            @prepareResponse: FfiConverterTypePrepareSendPaymentResponse.INSTANCE.Read(stream),
            @options: FfiConverterOptionalTypeSendPaymentOptions.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SendPaymentRequest value) {
        return 0
            + FfiConverterTypePrepareSendPaymentResponse.INSTANCE.AllocationSize(value.@prepareResponse)
            + FfiConverterOptionalTypeSendPaymentOptions.INSTANCE.AllocationSize(value.@options);
    }

    public override void Write(SendPaymentRequest value, BigEndianStream stream) {
            FfiConverterTypePrepareSendPaymentResponse.INSTANCE.Write(value.@prepareResponse, stream);
            FfiConverterOptionalTypeSendPaymentOptions.INSTANCE.Write(value.@options, stream);
    }
}



public record SendPaymentResponse (
    Payment @payment
) {
}

class FfiConverterTypeSendPaymentResponse: FfiConverterRustBuffer<SendPaymentResponse> {
    public static FfiConverterTypeSendPaymentResponse INSTANCE = new FfiConverterTypeSendPaymentResponse();

    public override SendPaymentResponse Read(BigEndianStream stream) {
        return new SendPaymentResponse(
            @payment: FfiConverterTypePayment.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SendPaymentResponse value) {
        return 0
            + FfiConverterTypePayment.INSTANCE.AllocationSize(value.@payment);
    }

    public override void Write(SendPaymentResponse value, BigEndianStream stream) {
            FfiConverterTypePayment.INSTANCE.Write(value.@payment, stream);
    }
}



/// <param name="compact">
/// If true, the signature will be encoded in compact format instead of DER format
/// </param>
public record SignMessageRequest (
    string @message, 
    /// <summary>
    /// If true, the signature will be encoded in compact format instead of DER format
    /// </summary>
    bool @compact
) {
}

class FfiConverterTypeSignMessageRequest: FfiConverterRustBuffer<SignMessageRequest> {
    public static FfiConverterTypeSignMessageRequest INSTANCE = new FfiConverterTypeSignMessageRequest();

    public override SignMessageRequest Read(BigEndianStream stream) {
        return new SignMessageRequest(
            @message: FfiConverterString.INSTANCE.Read(stream),
            @compact: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SignMessageRequest value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@message)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@compact);
    }

    public override void Write(SignMessageRequest value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@message, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@compact, stream);
    }
}



/// <param name="signature">
/// The DER or compact hex encoded signature
/// </param>
public record SignMessageResponse (
    string @pubkey, 
    /// <summary>
    /// The DER or compact hex encoded signature
    /// </summary>
    string @signature
) {
}

class FfiConverterTypeSignMessageResponse: FfiConverterRustBuffer<SignMessageResponse> {
    public static FfiConverterTypeSignMessageResponse INSTANCE = new FfiConverterTypeSignMessageResponse();

    public override SignMessageResponse Read(BigEndianStream stream) {
        return new SignMessageResponse(
            @pubkey: FfiConverterString.INSTANCE.Read(stream),
            @signature: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SignMessageResponse value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@pubkey)
            + FfiConverterString.INSTANCE.AllocationSize(value.@signature);
    }

    public override void Write(SignMessageResponse value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@pubkey, stream);
            FfiConverterString.INSTANCE.Write(value.@signature, stream);
    }
}



/// <param name="description">
/// Represents the spark invoice description
/// </param>
/// <param name="invoice">
/// The raw spark invoice string
/// </param>
public record SparkInvoicePaymentDetails (
    /// <summary>
    /// Represents the spark invoice description
    /// </summary>
    string? @description, 
    /// <summary>
    /// The raw spark invoice string
    /// </summary>
    string @invoice
) {
}

class FfiConverterTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer<SparkInvoicePaymentDetails> {
    public static FfiConverterTypeSparkInvoicePaymentDetails INSTANCE = new FfiConverterTypeSparkInvoicePaymentDetails();

    public override SparkInvoicePaymentDetails Read(BigEndianStream stream) {
        return new SparkInvoicePaymentDetails(
            @description: FfiConverterOptionalString.INSTANCE.Read(stream),
            @invoice: FfiConverterString.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SparkInvoicePaymentDetails value) {
        return 0
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@description)
            + FfiConverterString.INSTANCE.AllocationSize(value.@invoice);
    }

    public override void Write(SparkInvoicePaymentDetails value, BigEndianStream stream) {
            FfiConverterOptionalString.INSTANCE.Write(value.@description, stream);
            FfiConverterString.INSTANCE.Write(value.@invoice, stream);
    }
}



/// <summary>
/// Request to sync the wallet with the Spark network
/// </summary>
public record SyncWalletRequest (
) {
}

class FfiConverterTypeSyncWalletRequest: FfiConverterRustBuffer<SyncWalletRequest> {
    public static FfiConverterTypeSyncWalletRequest INSTANCE = new FfiConverterTypeSyncWalletRequest();

    public override SyncWalletRequest Read(BigEndianStream stream) {
        return new SyncWalletRequest(
        );
    }

    public override int AllocationSize(SyncWalletRequest value) {
        return 0;
    }

    public override void Write(SyncWalletRequest value, BigEndianStream stream) {
    }
}



/// <summary>
/// Response from synchronizing the wallet
/// </summary>
public record SyncWalletResponse (
) {
}

class FfiConverterTypeSyncWalletResponse: FfiConverterRustBuffer<SyncWalletResponse> {
    public static FfiConverterTypeSyncWalletResponse INSTANCE = new FfiConverterTypeSyncWalletResponse();

    public override SyncWalletResponse Read(BigEndianStream stream) {
        return new SyncWalletResponse(
        );
    }

    public override int AllocationSize(SyncWalletResponse value) {
        return 0;
    }

    public override void Write(SyncWalletResponse value, BigEndianStream stream) {
    }
}



public record TokenBalance (
    u128 @balance, 
    TokenMetadata @tokenMetadata
) {
}

class FfiConverterTypeTokenBalance: FfiConverterRustBuffer<TokenBalance> {
    public static FfiConverterTypeTokenBalance INSTANCE = new FfiConverterTypeTokenBalance();

    public override TokenBalance Read(BigEndianStream stream) {
        return new TokenBalance(
            @balance: FfiConverterTypeu128.INSTANCE.Read(stream),
            @tokenMetadata: FfiConverterTypeTokenMetadata.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenBalance value) {
        return 0
            + FfiConverterTypeu128.INSTANCE.AllocationSize(value.@balance)
            + FfiConverterTypeTokenMetadata.INSTANCE.AllocationSize(value.@tokenMetadata);
    }

    public override void Write(TokenBalance value, BigEndianStream stream) {
            FfiConverterTypeu128.INSTANCE.Write(value.@balance, stream);
            FfiConverterTypeTokenMetadata.INSTANCE.Write(value.@tokenMetadata, stream);
    }
}



/// <param name="issuer_public_key">
/// Hex representation of the issuer public key
/// </param>
/// <param name="decimals">
/// Number of decimals the token uses
/// </param>
public record TokenMetadata (
    string @identifier, 
    /// <summary>
    /// Hex representation of the issuer public key
    /// </summary>
    string @issuerPublicKey, 
    string @name, 
    string @ticker, 
    /// <summary>
    /// Number of decimals the token uses
    /// </summary>
    uint @decimals, 
    u128 @maxSupply, 
    bool @isFreezable
) {
}

class FfiConverterTypeTokenMetadata: FfiConverterRustBuffer<TokenMetadata> {
    public static FfiConverterTypeTokenMetadata INSTANCE = new FfiConverterTypeTokenMetadata();

    public override TokenMetadata Read(BigEndianStream stream) {
        return new TokenMetadata(
            @identifier: FfiConverterString.INSTANCE.Read(stream),
            @issuerPublicKey: FfiConverterString.INSTANCE.Read(stream),
            @name: FfiConverterString.INSTANCE.Read(stream),
            @ticker: FfiConverterString.INSTANCE.Read(stream),
            @decimals: FfiConverterUInt32.INSTANCE.Read(stream),
            @maxSupply: FfiConverterTypeu128.INSTANCE.Read(stream),
            @isFreezable: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TokenMetadata value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@identifier)
            + FfiConverterString.INSTANCE.AllocationSize(value.@issuerPublicKey)
            + FfiConverterString.INSTANCE.AllocationSize(value.@name)
            + FfiConverterString.INSTANCE.AllocationSize(value.@ticker)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@decimals)
            + FfiConverterTypeu128.INSTANCE.AllocationSize(value.@maxSupply)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@isFreezable);
    }

    public override void Write(TokenMetadata value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@identifier, stream);
            FfiConverterString.INSTANCE.Write(value.@issuerPublicKey, stream);
            FfiConverterString.INSTANCE.Write(value.@name, stream);
            FfiConverterString.INSTANCE.Write(value.@ticker, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@decimals, stream);
            FfiConverterTypeu128.INSTANCE.Write(value.@maxSupply, stream);
            FfiConverterBoolean.INSTANCE.Write(value.@isFreezable, stream);
    }
}



public record TxStatus (
    bool @confirmed, 
    uint? @blockHeight, 
    ulong? @blockTime
) {
}

class FfiConverterTypeTxStatus: FfiConverterRustBuffer<TxStatus> {
    public static FfiConverterTypeTxStatus INSTANCE = new FfiConverterTypeTxStatus();

    public override TxStatus Read(BigEndianStream stream) {
        return new TxStatus(
            @confirmed: FfiConverterBoolean.INSTANCE.Read(stream),
            @blockHeight: FfiConverterOptionalUInt32.INSTANCE.Read(stream),
            @blockTime: FfiConverterOptionalUInt64.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(TxStatus value) {
        return 0
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@confirmed)
            + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(value.@blockHeight)
            + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(value.@blockTime);
    }

    public override void Write(TxStatus value, BigEndianStream stream) {
            FfiConverterBoolean.INSTANCE.Write(value.@confirmed, stream);
            FfiConverterOptionalUInt32.INSTANCE.Write(value.@blockHeight, stream);
            FfiConverterOptionalUInt64.INSTANCE.Write(value.@blockTime, stream);
    }
}



public record Utxo (
    string @txid, 
    uint @vout, 
    ulong @value, 
    TxStatus @status
) {
}

class FfiConverterTypeUtxo: FfiConverterRustBuffer<Utxo> {
    public static FfiConverterTypeUtxo INSTANCE = new FfiConverterTypeUtxo();

    public override Utxo Read(BigEndianStream stream) {
        return new Utxo(
            @txid: FfiConverterString.INSTANCE.Read(stream),
            @vout: FfiConverterUInt32.INSTANCE.Read(stream),
            @value: FfiConverterUInt64.INSTANCE.Read(stream),
            @status: FfiConverterTypeTxStatus.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(Utxo value) {
        return 0
            + FfiConverterString.INSTANCE.AllocationSize(value.@txid)
            + FfiConverterUInt32.INSTANCE.AllocationSize(value.@vout)
            + FfiConverterUInt64.INSTANCE.AllocationSize(value.@value)
            + FfiConverterTypeTxStatus.INSTANCE.AllocationSize(value.@status);
    }

    public override void Write(Utxo value, BigEndianStream stream) {
            FfiConverterString.INSTANCE.Write(value.@txid, stream);
            FfiConverterUInt32.INSTANCE.Write(value.@vout, stream);
            FfiConverterUInt64.INSTANCE.Write(value.@value, stream);
            FfiConverterTypeTxStatus.INSTANCE.Write(value.@status, stream);
    }
}



public record WaitForPaymentRequest (
    WaitForPaymentIdentifier @identifier
) {
}

class FfiConverterTypeWaitForPaymentRequest: FfiConverterRustBuffer<WaitForPaymentRequest> {
    public static FfiConverterTypeWaitForPaymentRequest INSTANCE = new FfiConverterTypeWaitForPaymentRequest();

    public override WaitForPaymentRequest Read(BigEndianStream stream) {
        return new WaitForPaymentRequest(
            @identifier: FfiConverterTypeWaitForPaymentIdentifier.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(WaitForPaymentRequest value) {
        return 0
            + FfiConverterTypeWaitForPaymentIdentifier.INSTANCE.AllocationSize(value.@identifier);
    }

    public override void Write(WaitForPaymentRequest value, BigEndianStream stream) {
            FfiConverterTypeWaitForPaymentIdentifier.INSTANCE.Write(value.@identifier, stream);
    }
}



public record WaitForPaymentResponse (
    Payment @payment
) {
}

class FfiConverterTypeWaitForPaymentResponse: FfiConverterRustBuffer<WaitForPaymentResponse> {
    public static FfiConverterTypeWaitForPaymentResponse INSTANCE = new FfiConverterTypeWaitForPaymentResponse();

    public override WaitForPaymentResponse Read(BigEndianStream stream) {
        return new WaitForPaymentResponse(
            @payment: FfiConverterTypePayment.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(WaitForPaymentResponse value) {
        return 0
            + FfiConverterTypePayment.INSTANCE.AllocationSize(value.@payment);
    }

    public override void Write(WaitForPaymentResponse value, BigEndianStream stream) {
            FfiConverterTypePayment.INSTANCE.Write(value.@payment, stream);
    }
}





/// <summary>
/// A field of [`ListPaymentsRequest`] when listing payments filtered by asset
/// </summary>
public record AssetFilter {
    
    public record Bitcoin: AssetFilter {}
    
    
    public record Token (
        string? @tokenIdentifier
    ) : AssetFilter {}
    

    
}

class FfiConverterTypeAssetFilter : FfiConverterRustBuffer<AssetFilter>{
    public static FfiConverterRustBuffer<AssetFilter> INSTANCE = new FfiConverterTypeAssetFilter();

    public override AssetFilter Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new AssetFilter.Bitcoin(
                );
            case 2:
                return new AssetFilter.Token(
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAssetFilter.Read()", value));
        }
    }

    public override int AllocationSize(AssetFilter value) {
        switch (value) {
            case AssetFilter.Bitcoin variant_value:
                return 4;
            case AssetFilter.Token variant_value:
                return 4
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@tokenIdentifier);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAssetFilter.AllocationSize()", value));
        }
    }

    public override void Write(AssetFilter value, BigEndianStream stream) {
        switch (value) {
            case AssetFilter.Bitcoin variant_value:
                stream.WriteInt(1);
                break;
            case AssetFilter.Token variant_value:
                stream.WriteInt(2);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@tokenIdentifier, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeAssetFilter.Write()", value));
        }
    }
}







public class ChainServiceException: UniffiException {
    ChainServiceException() : base() {}
    ChainServiceException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class InvalidAddress : ChainServiceException {
        // Members
        public string @v1;

        // Constructor
        public InvalidAddress(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class ServiceConnectivity : ChainServiceException {
        // Members
        public string @v1;

        // Constructor
        public ServiceConnectivity(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Generic : ChainServiceException {
        // Members
        public string @v1;

        // Constructor
        public Generic(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    

    
}

class FfiConverterTypeChainServiceError : FfiConverterRustBuffer<ChainServiceException>, CallStatusErrorHandler<ChainServiceException> {
    public static FfiConverterTypeChainServiceError INSTANCE = new FfiConverterTypeChainServiceError();

    public override ChainServiceException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new ChainServiceException.InvalidAddress(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new ChainServiceException.ServiceConnectivity(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new ChainServiceException.Generic(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeChainServiceError.Read()", value));
        }
    }

    public override int AllocationSize(ChainServiceException value) {
        switch (value) {

            case ChainServiceException.InvalidAddress variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ChainServiceException.ServiceConnectivity variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case ChainServiceException.Generic variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeChainServiceError.AllocationSize()", value));
        }
    }

    public override void Write(ChainServiceException value, BigEndianStream stream) {
        switch (value) {
            case ChainServiceException.InvalidAddress variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ChainServiceException.ServiceConnectivity variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case ChainServiceException.Generic variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeChainServiceError.Write()", value));
        }
    }
}





public record DepositClaimError {
    
    public record DepositClaimFeeExceeded (
        string @tx,
        uint @vout,
        Fee? @maxFee,
        ulong @actualFee
    ) : DepositClaimError {}
    
    public record MissingUtxo (
        string @tx,
        uint @vout
    ) : DepositClaimError {}
    
    public record Generic (
        string @message
    ) : DepositClaimError {}
    

    
}

class FfiConverterTypeDepositClaimError : FfiConverterRustBuffer<DepositClaimError>{
    public static FfiConverterRustBuffer<DepositClaimError> INSTANCE = new FfiConverterTypeDepositClaimError();

    public override DepositClaimError Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new DepositClaimError.DepositClaimFeeExceeded(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeFee.INSTANCE.Read(stream),
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            case 2:
                return new DepositClaimError.MissingUtxo(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterUInt32.INSTANCE.Read(stream)
                );
            case 3:
                return new DepositClaimError.Generic(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeDepositClaimError.Read()", value));
        }
    }

    public override int AllocationSize(DepositClaimError value) {
        switch (value) {
            case DepositClaimError.DepositClaimFeeExceeded variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@tx)
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@vout)
                    + FfiConverterOptionalTypeFee.INSTANCE.AllocationSize(variant_value.@maxFee)
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@actualFee);
            case DepositClaimError.MissingUtxo variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@tx)
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@vout);
            case DepositClaimError.Generic variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@message);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeDepositClaimError.AllocationSize()", value));
        }
    }

    public override void Write(DepositClaimError value, BigEndianStream stream) {
        switch (value) {
            case DepositClaimError.DepositClaimFeeExceeded variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@tx, stream);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@vout, stream);
                FfiConverterOptionalTypeFee.INSTANCE.Write(variant_value.@maxFee, stream);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@actualFee, stream);
                break;
            case DepositClaimError.MissingUtxo variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@tx, stream);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@vout, stream);
                break;
            case DepositClaimError.Generic variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@message, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeDepositClaimError.Write()", value));
        }
    }
}







public record Fee {
    
    public record Fixed (
        ulong @amount
    ) : Fee {}
    
    public record Rate (
        ulong @satPerVbyte
    ) : Fee {}
    

    
}

class FfiConverterTypeFee : FfiConverterRustBuffer<Fee>{
    public static FfiConverterRustBuffer<Fee> INSTANCE = new FfiConverterTypeFee();

    public override Fee Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new Fee.Fixed(
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            case 2:
                return new Fee.Rate(
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeFee.Read()", value));
        }
    }

    public override int AllocationSize(Fee value) {
        switch (value) {
            case Fee.Fixed variant_value:
                return 4
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@amount);
            case Fee.Rate variant_value:
                return 4
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@satPerVbyte);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeFee.AllocationSize()", value));
        }
    }

    public override void Write(Fee value, BigEndianStream stream) {
        switch (value) {
            case Fee.Fixed variant_value:
                stream.WriteInt(1);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@amount, stream);
                break;
            case Fee.Rate variant_value:
                stream.WriteInt(2);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@satPerVbyte, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeFee.Write()", value));
        }
    }
}







public enum KeySetType: int {
    
    Default,
    Taproot,
    NativeSegwit,
    WrappedSegwit,
    Legacy
}

class FfiConverterTypeKeySetType: FfiConverterRustBuffer<KeySetType> {
    public static FfiConverterTypeKeySetType INSTANCE = new FfiConverterTypeKeySetType();

    public override KeySetType Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(KeySetType), value)) {
            return (KeySetType)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeKeySetType.Read()", value));
        }
    }

    public override int AllocationSize(KeySetType value) {
        return 4;
    }

    public override void Write(KeySetType value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







public enum Network: int {
    
    Mainnet,
    Regtest
}

class FfiConverterTypeNetwork: FfiConverterRustBuffer<Network> {
    public static FfiConverterTypeNetwork INSTANCE = new FfiConverterTypeNetwork();

    public override Network Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(Network), value)) {
            return (Network)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeNetwork.Read()", value));
        }
    }

    public override int AllocationSize(Network value) {
        return 4;
    }

    public override void Write(Network value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







public enum OnchainConfirmationSpeed: int {
    
    Fast,
    Medium,
    Slow
}

class FfiConverterTypeOnchainConfirmationSpeed: FfiConverterRustBuffer<OnchainConfirmationSpeed> {
    public static FfiConverterTypeOnchainConfirmationSpeed INSTANCE = new FfiConverterTypeOnchainConfirmationSpeed();

    public override OnchainConfirmationSpeed Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(OnchainConfirmationSpeed), value)) {
            return (OnchainConfirmationSpeed)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeOnchainConfirmationSpeed.Read()", value));
        }
    }

    public override int AllocationSize(OnchainConfirmationSpeed value) {
        return 4;
    }

    public override void Write(OnchainConfirmationSpeed value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







public record PaymentDetails {
    
    public record Spark (
        SparkInvoicePaymentDetails? @invoiceDetails
    ) : PaymentDetails {}
    
    public record Token (
        TokenMetadata @metadata,
        string @txHash,
        SparkInvoicePaymentDetails? @invoiceDetails
    ) : PaymentDetails {}
    
    public record Lightning (
        string? @description,
        string? @preimage,
        string @invoice,
        string @paymentHash,
        string @destinationPubkey,
        LnurlPayInfo? @lnurlPayInfo,
        LnurlWithdrawInfo? @lnurlWithdrawInfo
    ) : PaymentDetails {}
    
    public record Withdraw (
        string @txId
    ) : PaymentDetails {}
    
    public record Deposit (
        string @txId
    ) : PaymentDetails {}
    

    
}

class FfiConverterTypePaymentDetails : FfiConverterRustBuffer<PaymentDetails>{
    public static FfiConverterRustBuffer<PaymentDetails> INSTANCE = new FfiConverterTypePaymentDetails();

    public override PaymentDetails Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new PaymentDetails.Spark(
                    FfiConverterOptionalTypeSparkInvoicePaymentDetails.INSTANCE.Read(stream)
                );
            case 2:
                return new PaymentDetails.Token(
                    FfiConverterTypeTokenMetadata.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeSparkInvoicePaymentDetails.INSTANCE.Read(stream)
                );
            case 3:
                return new PaymentDetails.Lightning(
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeLnurlPayInfo.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeLnurlWithdrawInfo.INSTANCE.Read(stream)
                );
            case 4:
                return new PaymentDetails.Withdraw(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 5:
                return new PaymentDetails.Deposit(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePaymentDetails.Read()", value));
        }
    }

    public override int AllocationSize(PaymentDetails value) {
        switch (value) {
            case PaymentDetails.Spark variant_value:
                return 4
                    + FfiConverterOptionalTypeSparkInvoicePaymentDetails.INSTANCE.AllocationSize(variant_value.@invoiceDetails);
            case PaymentDetails.Token variant_value:
                return 4
                    + FfiConverterTypeTokenMetadata.INSTANCE.AllocationSize(variant_value.@metadata)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@txHash)
                    + FfiConverterOptionalTypeSparkInvoicePaymentDetails.INSTANCE.AllocationSize(variant_value.@invoiceDetails);
            case PaymentDetails.Lightning variant_value:
                return 4
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@description)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@preimage)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@invoice)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@paymentHash)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@destinationPubkey)
                    + FfiConverterOptionalTypeLnurlPayInfo.INSTANCE.AllocationSize(variant_value.@lnurlPayInfo)
                    + FfiConverterOptionalTypeLnurlWithdrawInfo.INSTANCE.AllocationSize(variant_value.@lnurlWithdrawInfo);
            case PaymentDetails.Withdraw variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@txId);
            case PaymentDetails.Deposit variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@txId);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePaymentDetails.AllocationSize()", value));
        }
    }

    public override void Write(PaymentDetails value, BigEndianStream stream) {
        switch (value) {
            case PaymentDetails.Spark variant_value:
                stream.WriteInt(1);
                FfiConverterOptionalTypeSparkInvoicePaymentDetails.INSTANCE.Write(variant_value.@invoiceDetails, stream);
                break;
            case PaymentDetails.Token variant_value:
                stream.WriteInt(2);
                FfiConverterTypeTokenMetadata.INSTANCE.Write(variant_value.@metadata, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@txHash, stream);
                FfiConverterOptionalTypeSparkInvoicePaymentDetails.INSTANCE.Write(variant_value.@invoiceDetails, stream);
                break;
            case PaymentDetails.Lightning variant_value:
                stream.WriteInt(3);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@description, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@preimage, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@invoice, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@paymentHash, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@destinationPubkey, stream);
                FfiConverterOptionalTypeLnurlPayInfo.INSTANCE.Write(variant_value.@lnurlPayInfo, stream);
                FfiConverterOptionalTypeLnurlWithdrawInfo.INSTANCE.Write(variant_value.@lnurlWithdrawInfo, stream);
                break;
            case PaymentDetails.Withdraw variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@txId, stream);
                break;
            case PaymentDetails.Deposit variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@txId, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePaymentDetails.Write()", value));
        }
    }
}







public enum PaymentMethod: int {
    
    Lightning,
    Spark,
    Token,
    Deposit,
    Withdraw,
    Unknown
}

class FfiConverterTypePaymentMethod: FfiConverterRustBuffer<PaymentMethod> {
    public static FfiConverterTypePaymentMethod INSTANCE = new FfiConverterTypePaymentMethod();

    public override PaymentMethod Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PaymentMethod), value)) {
            return (PaymentMethod)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePaymentMethod.Read()", value));
        }
    }

    public override int AllocationSize(PaymentMethod value) {
        return 4;
    }

    public override void Write(PaymentMethod value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







public class PaymentObserverException: UniffiException {
    PaymentObserverException() : base() {}
    PaymentObserverException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class ServiceConnectivity : PaymentObserverException {
        // Members
        public string @v1;

        // Constructor
        public ServiceConnectivity(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Generic : PaymentObserverException {
        // Members
        public string @v1;

        // Constructor
        public Generic(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    

    
}

class FfiConverterTypePaymentObserverError : FfiConverterRustBuffer<PaymentObserverException>, CallStatusErrorHandler<PaymentObserverException> {
    public static FfiConverterTypePaymentObserverError INSTANCE = new FfiConverterTypePaymentObserverError();

    public override PaymentObserverException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new PaymentObserverException.ServiceConnectivity(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new PaymentObserverException.Generic(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypePaymentObserverError.Read()", value));
        }
    }

    public override int AllocationSize(PaymentObserverException value) {
        switch (value) {

            case PaymentObserverException.ServiceConnectivity variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case PaymentObserverException.Generic variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypePaymentObserverError.AllocationSize()", value));
        }
    }

    public override void Write(PaymentObserverException value, BigEndianStream stream) {
        switch (value) {
            case PaymentObserverException.ServiceConnectivity variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case PaymentObserverException.Generic variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypePaymentObserverError.Write()", value));
        }
    }
}





/// <summary>
/// The status of a payment
/// </summary>
public enum PaymentStatus: int {
    
    /// <summary>
    /// Payment is completed successfully
    /// </summary>
    Completed,
    /// <summary>
    /// Payment is in progress
    /// </summary>
    Pending,
    /// <summary>
    /// Payment has failed
    /// </summary>
    Failed
}

class FfiConverterTypePaymentStatus: FfiConverterRustBuffer<PaymentStatus> {
    public static FfiConverterTypePaymentStatus INSTANCE = new FfiConverterTypePaymentStatus();

    public override PaymentStatus Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PaymentStatus), value)) {
            return (PaymentStatus)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePaymentStatus.Read()", value));
        }
    }

    public override int AllocationSize(PaymentStatus value) {
        return 4;
    }

    public override void Write(PaymentStatus value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







/// <summary>
/// The type of payment
/// </summary>
public enum PaymentType: int {
    
    /// <summary>
    /// Payment sent from this wallet
    /// </summary>
    Send,
    /// <summary>
    /// Payment received to this wallet
    /// </summary>
    Receive
}

class FfiConverterTypePaymentType: FfiConverterRustBuffer<PaymentType> {
    public static FfiConverterTypePaymentType INSTANCE = new FfiConverterTypePaymentType();

    public override PaymentType Read(BigEndianStream stream) {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(PaymentType), value)) {
            return (PaymentType)value;
        } else {
            throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypePaymentType.Read()", value));
        }
    }

    public override int AllocationSize(PaymentType value) {
        return 4;
    }

    public override void Write(PaymentType value, BigEndianStream stream) {
        stream.WriteInt((int)value + 1);
    }
}







public record ProvisionalPaymentDetails {
    
    public record Bitcoin (
        string @withdrawalAddress
    ) : ProvisionalPaymentDetails {}
    
    public record Lightning (
        string @invoice
    ) : ProvisionalPaymentDetails {}
    
    public record Spark (
        string @payRequest
    ) : ProvisionalPaymentDetails {}
    
    public record Token (
        string @tokenId,
        string @payRequest
    ) : ProvisionalPaymentDetails {}
    

    
}

class FfiConverterTypeProvisionalPaymentDetails : FfiConverterRustBuffer<ProvisionalPaymentDetails>{
    public static FfiConverterRustBuffer<ProvisionalPaymentDetails> INSTANCE = new FfiConverterTypeProvisionalPaymentDetails();

    public override ProvisionalPaymentDetails Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new ProvisionalPaymentDetails.Bitcoin(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new ProvisionalPaymentDetails.Lightning(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new ProvisionalPaymentDetails.Spark(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 4:
                return new ProvisionalPaymentDetails.Token(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeProvisionalPaymentDetails.Read()", value));
        }
    }

    public override int AllocationSize(ProvisionalPaymentDetails value) {
        switch (value) {
            case ProvisionalPaymentDetails.Bitcoin variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@withdrawalAddress);
            case ProvisionalPaymentDetails.Lightning variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@invoice);
            case ProvisionalPaymentDetails.Spark variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@payRequest);
            case ProvisionalPaymentDetails.Token variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@tokenId)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@payRequest);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeProvisionalPaymentDetails.AllocationSize()", value));
        }
    }

    public override void Write(ProvisionalPaymentDetails value, BigEndianStream stream) {
        switch (value) {
            case ProvisionalPaymentDetails.Bitcoin variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@withdrawalAddress, stream);
                break;
            case ProvisionalPaymentDetails.Lightning variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@invoice, stream);
                break;
            case ProvisionalPaymentDetails.Spark variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@payRequest, stream);
                break;
            case ProvisionalPaymentDetails.Token variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@tokenId, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@payRequest, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeProvisionalPaymentDetails.Write()", value));
        }
    }
}







public record ReceivePaymentMethod {
    
    public record SparkAddress: ReceivePaymentMethod {}
    
    
    public record SparkInvoice (
        u128? @amount,
        string? @tokenIdentifier,
        ulong? @expiryTime,
        string? @description,
        string? @senderPublicKey
    ) : ReceivePaymentMethod {}
    
    public record BitcoinAddress: ReceivePaymentMethod {}
    
    
    public record Bolt11Invoice (
        string @description,
        ulong? @amountSats
    ) : ReceivePaymentMethod {}
    

    
}

class FfiConverterTypeReceivePaymentMethod : FfiConverterRustBuffer<ReceivePaymentMethod>{
    public static FfiConverterRustBuffer<ReceivePaymentMethod> INSTANCE = new FfiConverterTypeReceivePaymentMethod();

    public override ReceivePaymentMethod Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new ReceivePaymentMethod.SparkAddress(
                );
            case 2:
                return new ReceivePaymentMethod.SparkInvoice(
                    FfiConverterOptionalTypeu128.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalUInt64.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 3:
                return new ReceivePaymentMethod.BitcoinAddress(
                );
            case 4:
                return new ReceivePaymentMethod.Bolt11Invoice(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterOptionalUInt64.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeReceivePaymentMethod.Read()", value));
        }
    }

    public override int AllocationSize(ReceivePaymentMethod value) {
        switch (value) {
            case ReceivePaymentMethod.SparkAddress variant_value:
                return 4;
            case ReceivePaymentMethod.SparkInvoice variant_value:
                return 4
                    + FfiConverterOptionalTypeu128.INSTANCE.AllocationSize(variant_value.@amount)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@tokenIdentifier)
                    + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(variant_value.@expiryTime)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@description)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@senderPublicKey);
            case ReceivePaymentMethod.BitcoinAddress variant_value:
                return 4;
            case ReceivePaymentMethod.Bolt11Invoice variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@description)
                    + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(variant_value.@amountSats);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeReceivePaymentMethod.AllocationSize()", value));
        }
    }

    public override void Write(ReceivePaymentMethod value, BigEndianStream stream) {
        switch (value) {
            case ReceivePaymentMethod.SparkAddress variant_value:
                stream.WriteInt(1);
                break;
            case ReceivePaymentMethod.SparkInvoice variant_value:
                stream.WriteInt(2);
                FfiConverterOptionalTypeu128.INSTANCE.Write(variant_value.@amount, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@tokenIdentifier, stream);
                FfiConverterOptionalUInt64.INSTANCE.Write(variant_value.@expiryTime, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@description, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@senderPublicKey, stream);
                break;
            case ReceivePaymentMethod.BitcoinAddress variant_value:
                stream.WriteInt(3);
                break;
            case ReceivePaymentMethod.Bolt11Invoice variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@description, stream);
                FfiConverterOptionalUInt64.INSTANCE.Write(variant_value.@amountSats, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeReceivePaymentMethod.Write()", value));
        }
    }
}







/// <summary>
/// Error type for the `BreezSdk`
/// </summary>
public class SdkException: UniffiException {
    SdkException() : base() {}
    SdkException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class SparkException : SdkException {
        // Members
        public string @v1;

        // Constructor
        public SparkException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class InvalidUuid : SdkException {
        // Members
        public string @v1;

        // Constructor
        public InvalidUuid(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    /// <summary>
    /// Invalid input error
    /// </summary>
    
    public class InvalidInput : SdkException {
        // Members
        public string @v1;

        // Constructor
        public InvalidInput(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    /// <summary>
    /// Network error
    /// </summary>
    
    public class NetworkException : SdkException {
        // Members
        public string @v1;

        // Constructor
        public NetworkException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    /// <summary>
    /// Storage error
    /// </summary>
    
    public class StorageException : SdkException {
        // Members
        public string @v1;

        // Constructor
        public StorageException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class ChainServiceException : SdkException {
        // Members
        public string @v1;

        // Constructor
        public ChainServiceException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class DepositClaimFeeExceeded : SdkException {
        // Members
        public string @tx;
        public uint @vout;
        public Fee? @maxFee;
        public ulong @actualFee;

        // Constructor
        public DepositClaimFeeExceeded(
                string @tx, 
                uint @vout, 
                Fee? @maxFee, 
                ulong @actualFee) : base(
                "@tx" + "=" + @tx+ ", " +
                "@vout" + "=" + @vout+ ", " +
                "@maxFee" + "=" + @maxFee+ ", " +
                "@actualFee" + "=" + @actualFee) {

            this.@tx = @tx;

            this.@vout = @vout;

            this.@maxFee = @maxFee;

            this.@actualFee = @actualFee;
        }
    }
    
    
    public class MissingUtxo : SdkException {
        // Members
        public string @tx;
        public uint @vout;

        // Constructor
        public MissingUtxo(
                string @tx, 
                uint @vout) : base(
                "@tx" + "=" + @tx+ ", " +
                "@vout" + "=" + @vout) {

            this.@tx = @tx;

            this.@vout = @vout;
        }
    }
    
    
    public class LnurlException : SdkException {
        // Members
        public string @v1;

        // Constructor
        public LnurlException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Generic : SdkException {
        // Members
        public string @v1;

        // Constructor
        public Generic(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    

    
}

class FfiConverterTypeSdkError : FfiConverterRustBuffer<SdkException>, CallStatusErrorHandler<SdkException> {
    public static FfiConverterTypeSdkError INSTANCE = new FfiConverterTypeSdkError();

    public override SdkException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SdkException.SparkException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new SdkException.InvalidUuid(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new SdkException.InvalidInput(
                    FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new SdkException.NetworkException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new SdkException.StorageException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new SdkException.ChainServiceException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new SdkException.DepositClaimFeeExceeded(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterUInt32.INSTANCE.Read(stream),
                    FfiConverterOptionalTypeFee.INSTANCE.Read(stream),
                    FfiConverterUInt64.INSTANCE.Read(stream));
            case 8:
                return new SdkException.MissingUtxo(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterUInt32.INSTANCE.Read(stream));
            case 9:
                return new SdkException.LnurlException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 10:
                return new SdkException.Generic(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSdkError.Read()", value));
        }
    }

    public override int AllocationSize(SdkException value) {
        switch (value) {

            case SdkException.SparkException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SdkException.InvalidUuid variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SdkException.InvalidInput variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SdkException.NetworkException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SdkException.StorageException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SdkException.ChainServiceException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SdkException.DepositClaimFeeExceeded variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@tx)
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@vout)
                    + FfiConverterOptionalTypeFee.INSTANCE.AllocationSize(variant_value.@maxFee)
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@actualFee);

            case SdkException.MissingUtxo variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@tx)
                    + FfiConverterUInt32.INSTANCE.AllocationSize(variant_value.@vout);

            case SdkException.LnurlException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case SdkException.Generic variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSdkError.AllocationSize()", value));
        }
    }

    public override void Write(SdkException value, BigEndianStream stream) {
        switch (value) {
            case SdkException.SparkException variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SdkException.InvalidUuid variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SdkException.InvalidInput variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SdkException.NetworkException variant_value:
                stream.WriteInt(4);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SdkException.StorageException variant_value:
                stream.WriteInt(5);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SdkException.ChainServiceException variant_value:
                stream.WriteInt(6);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SdkException.DepositClaimFeeExceeded variant_value:
                stream.WriteInt(7);
                FfiConverterString.INSTANCE.Write(variant_value.@tx, stream);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@vout, stream);
                FfiConverterOptionalTypeFee.INSTANCE.Write(variant_value.@maxFee, stream);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@actualFee, stream);
                break;
            case SdkException.MissingUtxo variant_value:
                stream.WriteInt(8);
                FfiConverterString.INSTANCE.Write(variant_value.@tx, stream);
                FfiConverterUInt32.INSTANCE.Write(variant_value.@vout, stream);
                break;
            case SdkException.LnurlException variant_value:
                stream.WriteInt(9);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case SdkException.Generic variant_value:
                stream.WriteInt(10);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeSdkError.Write()", value));
        }
    }
}





/// <summary>
/// Events emitted by the SDK
/// </summary>
public record SdkEvent {
    
    /// <summary>
    /// Emitted when the wallet has been synchronized with the network
    /// </summary>
    public record Synced: SdkEvent {}
    
    
    /// <summary>
    /// Emitted when data was pushed and/or pulled to/from real-time sync storage.
    /// </summary>
    public record DataSynced (
        bool @didPullNewRecords
    ) : SdkEvent {}
    
    /// <summary>
    /// Emitted when the SDK was unable to claim deposits
    /// </summary>
    public record UnclaimedDeposits (
        List<DepositInfo> @unclaimedDeposits
    ) : SdkEvent {}
    
    public record ClaimedDeposits (
        List<DepositInfo> @claimedDeposits
    ) : SdkEvent {}
    
    public record PaymentSucceeded (
        Payment @payment
    ) : SdkEvent {}
    
    public record PaymentFailed (
        Payment @payment
    ) : SdkEvent {}
    

    
}

class FfiConverterTypeSdkEvent : FfiConverterRustBuffer<SdkEvent>{
    public static FfiConverterRustBuffer<SdkEvent> INSTANCE = new FfiConverterTypeSdkEvent();

    public override SdkEvent Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SdkEvent.Synced(
                );
            case 2:
                return new SdkEvent.DataSynced(
                    FfiConverterBoolean.INSTANCE.Read(stream)
                );
            case 3:
                return new SdkEvent.UnclaimedDeposits(
                    FfiConverterSequenceTypeDepositInfo.INSTANCE.Read(stream)
                );
            case 4:
                return new SdkEvent.ClaimedDeposits(
                    FfiConverterSequenceTypeDepositInfo.INSTANCE.Read(stream)
                );
            case 5:
                return new SdkEvent.PaymentSucceeded(
                    FfiConverterTypePayment.INSTANCE.Read(stream)
                );
            case 6:
                return new SdkEvent.PaymentFailed(
                    FfiConverterTypePayment.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSdkEvent.Read()", value));
        }
    }

    public override int AllocationSize(SdkEvent value) {
        switch (value) {
            case SdkEvent.Synced variant_value:
                return 4;
            case SdkEvent.DataSynced variant_value:
                return 4
                    + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@didPullNewRecords);
            case SdkEvent.UnclaimedDeposits variant_value:
                return 4
                    + FfiConverterSequenceTypeDepositInfo.INSTANCE.AllocationSize(variant_value.@unclaimedDeposits);
            case SdkEvent.ClaimedDeposits variant_value:
                return 4
                    + FfiConverterSequenceTypeDepositInfo.INSTANCE.AllocationSize(variant_value.@claimedDeposits);
            case SdkEvent.PaymentSucceeded variant_value:
                return 4
                    + FfiConverterTypePayment.INSTANCE.AllocationSize(variant_value.@payment);
            case SdkEvent.PaymentFailed variant_value:
                return 4
                    + FfiConverterTypePayment.INSTANCE.AllocationSize(variant_value.@payment);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSdkEvent.AllocationSize()", value));
        }
    }

    public override void Write(SdkEvent value, BigEndianStream stream) {
        switch (value) {
            case SdkEvent.Synced variant_value:
                stream.WriteInt(1);
                break;
            case SdkEvent.DataSynced variant_value:
                stream.WriteInt(2);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@didPullNewRecords, stream);
                break;
            case SdkEvent.UnclaimedDeposits variant_value:
                stream.WriteInt(3);
                FfiConverterSequenceTypeDepositInfo.INSTANCE.Write(variant_value.@unclaimedDeposits, stream);
                break;
            case SdkEvent.ClaimedDeposits variant_value:
                stream.WriteInt(4);
                FfiConverterSequenceTypeDepositInfo.INSTANCE.Write(variant_value.@claimedDeposits, stream);
                break;
            case SdkEvent.PaymentSucceeded variant_value:
                stream.WriteInt(5);
                FfiConverterTypePayment.INSTANCE.Write(variant_value.@payment, stream);
                break;
            case SdkEvent.PaymentFailed variant_value:
                stream.WriteInt(6);
                FfiConverterTypePayment.INSTANCE.Write(variant_value.@payment, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSdkEvent.Write()", value));
        }
    }
}







/// <summary>
/// Represents the seed for wallet generation, either as a mnemonic phrase with an optional
/// passphrase or as raw entropy bytes.
/// </summary>
public record Seed {
    
    /// <summary>
    /// A BIP-39 mnemonic phrase with an optional passphrase.
    /// </summary>
    public record Mnemonic (
        string @mnemonic,
        string? @passphrase
    ) : Seed {}
    
    /// <summary>
    /// Raw entropy bytes.
    /// </summary>
    public record Entropy (
        byte[] @v1
    ) : Seed {}
    

    
}

class FfiConverterTypeSeed : FfiConverterRustBuffer<Seed>{
    public static FfiConverterRustBuffer<Seed> INSTANCE = new FfiConverterTypeSeed();

    public override Seed Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new Seed.Mnemonic(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 2:
                return new Seed.Entropy(
                    FfiConverterByteArray.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSeed.Read()", value));
        }
    }

    public override int AllocationSize(Seed value) {
        switch (value) {
            case Seed.Mnemonic variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@mnemonic)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@passphrase);
            case Seed.Entropy variant_value:
                return 4
                    + FfiConverterByteArray.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSeed.AllocationSize()", value));
        }
    }

    public override void Write(Seed value, BigEndianStream stream) {
        switch (value) {
            case Seed.Mnemonic variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@mnemonic, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@passphrase, stream);
                break;
            case Seed.Entropy variant_value:
                stream.WriteInt(2);
                FfiConverterByteArray.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSeed.Write()", value));
        }
    }
}







public record SendPaymentMethod {
    
    public record BitcoinAddress (
        BitcoinAddressDetails @address,
        SendOnchainFeeQuote @feeQuote
    ) : SendPaymentMethod {}
    
    public record Bolt11Invoice (
        Bolt11InvoiceDetails @invoiceDetails,
        ulong? @sparkTransferFeeSats,
        ulong @lightningFeeSats
    ) : SendPaymentMethod {}
    
    public record SparkAddress (
        string @address,
        u128 @fee,
        string? @tokenIdentifier
    ) : SendPaymentMethod {}
    
    public record SparkInvoice (
        SparkInvoiceDetails @sparkInvoiceDetails,
        u128 @fee,
        string? @tokenIdentifier
    ) : SendPaymentMethod {}
    

    
}

class FfiConverterTypeSendPaymentMethod : FfiConverterRustBuffer<SendPaymentMethod>{
    public static FfiConverterRustBuffer<SendPaymentMethod> INSTANCE = new FfiConverterTypeSendPaymentMethod();

    public override SendPaymentMethod Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SendPaymentMethod.BitcoinAddress(
                    FfiConverterTypeBitcoinAddressDetails.INSTANCE.Read(stream),
                    FfiConverterTypeSendOnchainFeeQuote.INSTANCE.Read(stream)
                );
            case 2:
                return new SendPaymentMethod.Bolt11Invoice(
                    FfiConverterTypeBolt11InvoiceDetails.INSTANCE.Read(stream),
                    FfiConverterOptionalUInt64.INSTANCE.Read(stream),
                    FfiConverterUInt64.INSTANCE.Read(stream)
                );
            case 3:
                return new SendPaymentMethod.SparkAddress(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterTypeu128.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            case 4:
                return new SendPaymentMethod.SparkInvoice(
                    FfiConverterTypeSparkInvoiceDetails.INSTANCE.Read(stream),
                    FfiConverterTypeu128.INSTANCE.Read(stream),
                    FfiConverterOptionalString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSendPaymentMethod.Read()", value));
        }
    }

    public override int AllocationSize(SendPaymentMethod value) {
        switch (value) {
            case SendPaymentMethod.BitcoinAddress variant_value:
                return 4
                    + FfiConverterTypeBitcoinAddressDetails.INSTANCE.AllocationSize(variant_value.@address)
                    + FfiConverterTypeSendOnchainFeeQuote.INSTANCE.AllocationSize(variant_value.@feeQuote);
            case SendPaymentMethod.Bolt11Invoice variant_value:
                return 4
                    + FfiConverterTypeBolt11InvoiceDetails.INSTANCE.AllocationSize(variant_value.@invoiceDetails)
                    + FfiConverterOptionalUInt64.INSTANCE.AllocationSize(variant_value.@sparkTransferFeeSats)
                    + FfiConverterUInt64.INSTANCE.AllocationSize(variant_value.@lightningFeeSats);
            case SendPaymentMethod.SparkAddress variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@address)
                    + FfiConverterTypeu128.INSTANCE.AllocationSize(variant_value.@fee)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@tokenIdentifier);
            case SendPaymentMethod.SparkInvoice variant_value:
                return 4
                    + FfiConverterTypeSparkInvoiceDetails.INSTANCE.AllocationSize(variant_value.@sparkInvoiceDetails)
                    + FfiConverterTypeu128.INSTANCE.AllocationSize(variant_value.@fee)
                    + FfiConverterOptionalString.INSTANCE.AllocationSize(variant_value.@tokenIdentifier);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSendPaymentMethod.AllocationSize()", value));
        }
    }

    public override void Write(SendPaymentMethod value, BigEndianStream stream) {
        switch (value) {
            case SendPaymentMethod.BitcoinAddress variant_value:
                stream.WriteInt(1);
                FfiConverterTypeBitcoinAddressDetails.INSTANCE.Write(variant_value.@address, stream);
                FfiConverterTypeSendOnchainFeeQuote.INSTANCE.Write(variant_value.@feeQuote, stream);
                break;
            case SendPaymentMethod.Bolt11Invoice variant_value:
                stream.WriteInt(2);
                FfiConverterTypeBolt11InvoiceDetails.INSTANCE.Write(variant_value.@invoiceDetails, stream);
                FfiConverterOptionalUInt64.INSTANCE.Write(variant_value.@sparkTransferFeeSats, stream);
                FfiConverterUInt64.INSTANCE.Write(variant_value.@lightningFeeSats, stream);
                break;
            case SendPaymentMethod.SparkAddress variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@address, stream);
                FfiConverterTypeu128.INSTANCE.Write(variant_value.@fee, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@tokenIdentifier, stream);
                break;
            case SendPaymentMethod.SparkInvoice variant_value:
                stream.WriteInt(4);
                FfiConverterTypeSparkInvoiceDetails.INSTANCE.Write(variant_value.@sparkInvoiceDetails, stream);
                FfiConverterTypeu128.INSTANCE.Write(variant_value.@fee, stream);
                FfiConverterOptionalString.INSTANCE.Write(variant_value.@tokenIdentifier, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSendPaymentMethod.Write()", value));
        }
    }
}







public record SendPaymentOptions {
    
    public record BitcoinAddress (
        OnchainConfirmationSpeed @confirmationSpeed
    ) : SendPaymentOptions {}
    
    public record Bolt11Invoice (
        bool @preferSpark,
        uint? @completionTimeoutSecs
    ) : SendPaymentOptions {}
    

    
}

class FfiConverterTypeSendPaymentOptions : FfiConverterRustBuffer<SendPaymentOptions>{
    public static FfiConverterRustBuffer<SendPaymentOptions> INSTANCE = new FfiConverterTypeSendPaymentOptions();

    public override SendPaymentOptions Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new SendPaymentOptions.BitcoinAddress(
                    FfiConverterTypeOnchainConfirmationSpeed.INSTANCE.Read(stream)
                );
            case 2:
                return new SendPaymentOptions.Bolt11Invoice(
                    FfiConverterBoolean.INSTANCE.Read(stream),
                    FfiConverterOptionalUInt32.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSendPaymentOptions.Read()", value));
        }
    }

    public override int AllocationSize(SendPaymentOptions value) {
        switch (value) {
            case SendPaymentOptions.BitcoinAddress variant_value:
                return 4
                    + FfiConverterTypeOnchainConfirmationSpeed.INSTANCE.AllocationSize(variant_value.@confirmationSpeed);
            case SendPaymentOptions.Bolt11Invoice variant_value:
                return 4
                    + FfiConverterBoolean.INSTANCE.AllocationSize(variant_value.@preferSpark)
                    + FfiConverterOptionalUInt32.INSTANCE.AllocationSize(variant_value.@completionTimeoutSecs);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSendPaymentOptions.AllocationSize()", value));
        }
    }

    public override void Write(SendPaymentOptions value, BigEndianStream stream) {
        switch (value) {
            case SendPaymentOptions.BitcoinAddress variant_value:
                stream.WriteInt(1);
                FfiConverterTypeOnchainConfirmationSpeed.INSTANCE.Write(variant_value.@confirmationSpeed, stream);
                break;
            case SendPaymentOptions.Bolt11Invoice variant_value:
                stream.WriteInt(2);
                FfiConverterBoolean.INSTANCE.Write(variant_value.@preferSpark, stream);
                FfiConverterOptionalUInt32.INSTANCE.Write(variant_value.@completionTimeoutSecs, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeSendPaymentOptions.Write()", value));
        }
    }
}







/// <summary>
/// Errors that can occur during storage operations
/// </summary>
public class StorageException: UniffiException {
    StorageException() : base() {}
    StorageException(String @Message) : base(@Message) {}

    // Each variant is a nested class
    
    
    public class Implementation : StorageException {
        // Members
        public string @v1;

        // Constructor
        public Implementation(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    /// <summary>
    /// Database initialization error
    /// </summary>
    
    public class InitializationException : StorageException {
        // Members
        public string @v1;

        // Constructor
        public InitializationException(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    
    
    public class Serialization : StorageException {
        // Members
        public string @v1;

        // Constructor
        public Serialization(
                string @v1) : base(
                "@v1" + "=" + @v1) {

            this.@v1 = @v1;
        }
    }
    

    
}

class FfiConverterTypeStorageError : FfiConverterRustBuffer<StorageException>, CallStatusErrorHandler<StorageException> {
    public static FfiConverterTypeStorageError INSTANCE = new FfiConverterTypeStorageError();

    public override StorageException Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new StorageException.Implementation(
                    FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new StorageException.InitializationException(
                    FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new StorageException.Serialization(
                    FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeStorageError.Read()", value));
        }
    }

    public override int AllocationSize(StorageException value) {
        switch (value) {

            case StorageException.Implementation variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case StorageException.InitializationException variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);

            case StorageException.Serialization variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeStorageError.AllocationSize()", value));
        }
    }

    public override void Write(StorageException value, BigEndianStream stream) {
        switch (value) {
            case StorageException.Implementation variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case StorageException.InitializationException variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case StorageException.Serialization variant_value:
                stream.WriteInt(3);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeStorageError.Write()", value));
        }
    }
}





public record UpdateDepositPayload {
    
    public record ClaimError (
        DepositClaimError @error
    ) : UpdateDepositPayload {}
    
    public record Refund (
        string @refundTxid,
        string @refundTx
    ) : UpdateDepositPayload {}
    

    
}

class FfiConverterTypeUpdateDepositPayload : FfiConverterRustBuffer<UpdateDepositPayload>{
    public static FfiConverterRustBuffer<UpdateDepositPayload> INSTANCE = new FfiConverterTypeUpdateDepositPayload();

    public override UpdateDepositPayload Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new UpdateDepositPayload.ClaimError(
                    FfiConverterTypeDepositClaimError.INSTANCE.Read(stream)
                );
            case 2:
                return new UpdateDepositPayload.Refund(
                    FfiConverterString.INSTANCE.Read(stream),
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeUpdateDepositPayload.Read()", value));
        }
    }

    public override int AllocationSize(UpdateDepositPayload value) {
        switch (value) {
            case UpdateDepositPayload.ClaimError variant_value:
                return 4
                    + FfiConverterTypeDepositClaimError.INSTANCE.AllocationSize(variant_value.@error);
            case UpdateDepositPayload.Refund variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@refundTxid)
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@refundTx);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeUpdateDepositPayload.AllocationSize()", value));
        }
    }

    public override void Write(UpdateDepositPayload value, BigEndianStream stream) {
        switch (value) {
            case UpdateDepositPayload.ClaimError variant_value:
                stream.WriteInt(1);
                FfiConverterTypeDepositClaimError.INSTANCE.Write(variant_value.@error, stream);
                break;
            case UpdateDepositPayload.Refund variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@refundTxid, stream);
                FfiConverterString.INSTANCE.Write(variant_value.@refundTx, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeUpdateDepositPayload.Write()", value));
        }
    }
}







public record WaitForPaymentIdentifier {
    
    public record PaymentId (
        string @v1
    ) : WaitForPaymentIdentifier {}
    
    public record PaymentRequest (
        string @v1
    ) : WaitForPaymentIdentifier {}
    

    
}

class FfiConverterTypeWaitForPaymentIdentifier : FfiConverterRustBuffer<WaitForPaymentIdentifier>{
    public static FfiConverterRustBuffer<WaitForPaymentIdentifier> INSTANCE = new FfiConverterTypeWaitForPaymentIdentifier();

    public override WaitForPaymentIdentifier Read(BigEndianStream stream) {
        var value = stream.ReadInt();
        switch (value) {
            case 1:
                return new WaitForPaymentIdentifier.PaymentId(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 2:
                return new WaitForPaymentIdentifier.PaymentRequest(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeWaitForPaymentIdentifier.Read()", value));
        }
    }

    public override int AllocationSize(WaitForPaymentIdentifier value) {
        switch (value) {
            case WaitForPaymentIdentifier.PaymentId variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            case WaitForPaymentIdentifier.PaymentRequest variant_value:
                return 4
                    + FfiConverterString.INSTANCE.AllocationSize(variant_value.@v1);
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeWaitForPaymentIdentifier.AllocationSize()", value));
        }
    }

    public override void Write(WaitForPaymentIdentifier value, BigEndianStream stream) {
        switch (value) {
            case WaitForPaymentIdentifier.PaymentId variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            case WaitForPaymentIdentifier.PaymentRequest variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@v1, stream);
                break;
            default:
                throw new InternalException(String.Format("invalid enum value '{0}' in FfiConverterTypeWaitForPaymentIdentifier.Write()", value));
        }
    }
}





/// <summary>
/// Trait for event listeners
/// </summary>
public interface EventListener {
    /// <summary>
    /// Called when an event occurs
    /// </summary>
    void OnEvent(SdkEvent @event);
}

class UniffiCallbackInterfaceEventListener {
    static void OnEvent(ulong @uniffiHandle,RustBuffer @event,IntPtr @uniffiFutureCallback,ulong @uniffiCallbackData,IntPtr /*_UniFFILib.UniffiForeignFuture*/ @uniffiOutReturn) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeEventListener.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            CancellationTokenSource cts = new CancellationTokenSource();

            Task.Run(async () => {
                var ret = new _UniFFILib.UniffiForeignFutureStructVoid();
                ret.@callStatus = new UniffiRustCallStatus();

                await uniffiObject.OnEvent(
                    FfiConverterTypeSdkEvent.INSTANCE.Lift(@event))
                #if NET6_0_OR_GREATER
                    .WaitAsync(cts.Token)
                #endif
                    ;

                ret.@callStatus.code = UniffiCallbackResponseStatus.SUCCESS;

                
                var cb = Marshal.GetDelegateForFunctionPointer<_UniFFILib.UniffiForeignFutureCompleteVoid>(@uniffiFutureCallback);
                cb(@uniffiCallbackData, ret);
            }, cts.Token);

            var foreignHandle = _UniFFIAsync._foreign_futures_map.Insert(cts);
            unsafe {
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).handle = foreignHandle;
                (*(_UniFFILib.UniffiForeignFuture*)uniffiOutReturn).free = Marshal.GetFunctionPointerForDelegate(_UniFFIAsync.UniffiForeignFutureFreeCallback.callback);;
            }
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeEventListener.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceEventListenerMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceEventListenerMethod0(OnEvent);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfaceEventListener _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceEventListener {
            @onEvent = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_spark_fn_init_callback_vtable_eventlistener(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}




// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeEventListener: FfiConverter<EventListener, ulong> {
    public static FfiConverterTypeEventListener INSTANCE = new FfiConverterTypeEventListener();

    public ConcurrentHandleMap<EventListener> handleMap = new ConcurrentHandleMap<EventListener>();

    public override ulong Lower(EventListener value) {
        return handleMap.Insert(value);
    }

    public override EventListener Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override EventListener Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(EventListener value) {
        return 8;
    }

    public override void Write(EventListener value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}



public interface Logger {
    void Log(LogEntry @l);
}

class UniffiCallbackInterfaceLogger {
    static void Log(ulong @uniffiHandle,RustBuffer @l,IntPtr @uniffiOutReturn,ref UniffiRustCallStatus _uniffi_out_err) {
        var handle = @uniffiHandle;
        if (FfiConverterTypeLogger.INSTANCE.handleMap.TryGet(handle, out var uniffiObject)) {
            uniffiObject.Log(
                FfiConverterTypeLogEntry.INSTANCE.Lift(@l));
        } else {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
    }

    static void UniffiFree(ulong @handle) {
        FfiConverterTypeLogger.INSTANCE.handleMap.Remove(@handle);
    }
    static _UniFFILib.UniffiCallbackInterfaceLoggerMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceLoggerMethod0(Log);
    static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

    public static void Register() {
        _UniFFILib.UniffiVTableCallbackInterfaceLogger _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceLogger {
            @log = Marshal.GetFunctionPointerForDelegate(_m0),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        // Pin vtable to ensure GC does not move the vtable across the heap
        _UniFFILib.uniffi_breez_sdk_spark_fn_init_callback_vtable_logger(GCHandle.Alloc(_vtable, GCHandleType.Pinned).AddrOfPinnedObject());
    }
}




// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeLogger: FfiConverter<Logger, ulong> {
    public static FfiConverterTypeLogger INSTANCE = new FfiConverterTypeLogger();

    public ConcurrentHandleMap<Logger> handleMap = new ConcurrentHandleMap<Logger>();

    public override ulong Lower(Logger value) {
        return handleMap.Insert(value);
    }

    public override Logger Lift(ulong value) {
        if (handleMap.TryGet(value, out var uniffiCallback)) {
            return uniffiCallback;
        } else {
            throw new InternalException($"No callback in handlemap '{value}'");
        }
    }

    public override Logger Read(BigEndianStream stream) {
        return Lift(stream.ReadULong());
    }

    public override int AllocationSize(Logger value) {
        return 8;
    }

    public override void Write(Logger value, BigEndianStream stream) {
        stream.WriteULong(Lower(value));
    }
}




class FfiConverterOptionalUInt32: FfiConverterRustBuffer<uint?> {
    public static FfiConverterOptionalUInt32 INSTANCE = new FfiConverterOptionalUInt32();

    public override uint? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt32.INSTANCE.Read(stream);
    }

    public override int AllocationSize(uint? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt32.INSTANCE.AllocationSize((uint)value);
        }
    }

    public override void Write(uint? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt32.INSTANCE.Write((uint)value, stream);
        }
    }
}




class FfiConverterOptionalUInt64: FfiConverterRustBuffer<ulong?> {
    public static FfiConverterOptionalUInt64 INSTANCE = new FfiConverterOptionalUInt64();

    public override ulong? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterUInt64.INSTANCE.Read(stream);
    }

    public override int AllocationSize(ulong? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterUInt64.INSTANCE.AllocationSize((ulong)value);
        }
    }

    public override void Write(ulong? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterUInt64.INSTANCE.Write((ulong)value, stream);
        }
    }
}




class FfiConverterOptionalBoolean: FfiConverterRustBuffer<bool?> {
    public static FfiConverterOptionalBoolean INSTANCE = new FfiConverterOptionalBoolean();

    public override bool? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterBoolean.INSTANCE.Read(stream);
    }

    public override int AllocationSize(bool? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterBoolean.INSTANCE.AllocationSize((bool)value);
        }
    }

    public override void Write(bool? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterBoolean.INSTANCE.Write((bool)value, stream);
        }
    }
}




class FfiConverterOptionalString: FfiConverterRustBuffer<string?> {
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override string? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(string? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
        }
    }

    public override void Write(string? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((string)value, stream);
        }
    }
}




class FfiConverterOptionalTypeCredentials: FfiConverterRustBuffer<Credentials?> {
    public static FfiConverterOptionalTypeCredentials INSTANCE = new FfiConverterOptionalTypeCredentials();

    public override Credentials? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeCredentials.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Credentials? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeCredentials.INSTANCE.AllocationSize((Credentials)value);
        }
    }

    public override void Write(Credentials? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeCredentials.INSTANCE.Write((Credentials)value, stream);
        }
    }
}




class FfiConverterOptionalTypeLightningAddressInfo: FfiConverterRustBuffer<LightningAddressInfo?> {
    public static FfiConverterOptionalTypeLightningAddressInfo INSTANCE = new FfiConverterOptionalTypeLightningAddressInfo();

    public override LightningAddressInfo? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeLightningAddressInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(LightningAddressInfo? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeLightningAddressInfo.INSTANCE.AllocationSize((LightningAddressInfo)value);
        }
    }

    public override void Write(LightningAddressInfo? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeLightningAddressInfo.INSTANCE.Write((LightningAddressInfo)value, stream);
        }
    }
}




class FfiConverterOptionalTypeLnurlPayInfo: FfiConverterRustBuffer<LnurlPayInfo?> {
    public static FfiConverterOptionalTypeLnurlPayInfo INSTANCE = new FfiConverterOptionalTypeLnurlPayInfo();

    public override LnurlPayInfo? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeLnurlPayInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(LnurlPayInfo? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeLnurlPayInfo.INSTANCE.AllocationSize((LnurlPayInfo)value);
        }
    }

    public override void Write(LnurlPayInfo? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeLnurlPayInfo.INSTANCE.Write((LnurlPayInfo)value, stream);
        }
    }
}




class FfiConverterOptionalTypeLnurlWithdrawInfo: FfiConverterRustBuffer<LnurlWithdrawInfo?> {
    public static FfiConverterOptionalTypeLnurlWithdrawInfo INSTANCE = new FfiConverterOptionalTypeLnurlWithdrawInfo();

    public override LnurlWithdrawInfo? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeLnurlWithdrawInfo.INSTANCE.Read(stream);
    }

    public override int AllocationSize(LnurlWithdrawInfo? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeLnurlWithdrawInfo.INSTANCE.AllocationSize((LnurlWithdrawInfo)value);
        }
    }

    public override void Write(LnurlWithdrawInfo? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeLnurlWithdrawInfo.INSTANCE.Write((LnurlWithdrawInfo)value, stream);
        }
    }
}




class FfiConverterOptionalTypePayment: FfiConverterRustBuffer<Payment?> {
    public static FfiConverterOptionalTypePayment INSTANCE = new FfiConverterOptionalTypePayment();

    public override Payment? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypePayment.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Payment? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypePayment.INSTANCE.AllocationSize((Payment)value);
        }
    }

    public override void Write(Payment? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypePayment.INSTANCE.Write((Payment)value, stream);
        }
    }
}




class FfiConverterOptionalTypeSparkInvoicePaymentDetails: FfiConverterRustBuffer<SparkInvoicePaymentDetails?> {
    public static FfiConverterOptionalTypeSparkInvoicePaymentDetails INSTANCE = new FfiConverterOptionalTypeSparkInvoicePaymentDetails();

    public override SparkInvoicePaymentDetails? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeSparkInvoicePaymentDetails.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SparkInvoicePaymentDetails? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeSparkInvoicePaymentDetails.INSTANCE.AllocationSize((SparkInvoicePaymentDetails)value);
        }
    }

    public override void Write(SparkInvoicePaymentDetails? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeSparkInvoicePaymentDetails.INSTANCE.Write((SparkInvoicePaymentDetails)value, stream);
        }
    }
}




class FfiConverterOptionalTypeAssetFilter: FfiConverterRustBuffer<AssetFilter?> {
    public static FfiConverterOptionalTypeAssetFilter INSTANCE = new FfiConverterOptionalTypeAssetFilter();

    public override AssetFilter? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeAssetFilter.INSTANCE.Read(stream);
    }

    public override int AllocationSize(AssetFilter? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeAssetFilter.INSTANCE.AllocationSize((AssetFilter)value);
        }
    }

    public override void Write(AssetFilter? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeAssetFilter.INSTANCE.Write((AssetFilter)value, stream);
        }
    }
}




class FfiConverterOptionalTypeDepositClaimError: FfiConverterRustBuffer<DepositClaimError?> {
    public static FfiConverterOptionalTypeDepositClaimError INSTANCE = new FfiConverterOptionalTypeDepositClaimError();

    public override DepositClaimError? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeDepositClaimError.INSTANCE.Read(stream);
    }

    public override int AllocationSize(DepositClaimError? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeDepositClaimError.INSTANCE.AllocationSize((DepositClaimError)value);
        }
    }

    public override void Write(DepositClaimError? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeDepositClaimError.INSTANCE.Write((DepositClaimError)value, stream);
        }
    }
}




class FfiConverterOptionalTypeFee: FfiConverterRustBuffer<Fee?> {
    public static FfiConverterOptionalTypeFee INSTANCE = new FfiConverterOptionalTypeFee();

    public override Fee? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeFee.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Fee? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeFee.INSTANCE.AllocationSize((Fee)value);
        }
    }

    public override void Write(Fee? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeFee.INSTANCE.Write((Fee)value, stream);
        }
    }
}




class FfiConverterOptionalTypePaymentDetails: FfiConverterRustBuffer<PaymentDetails?> {
    public static FfiConverterOptionalTypePaymentDetails INSTANCE = new FfiConverterOptionalTypePaymentDetails();

    public override PaymentDetails? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypePaymentDetails.INSTANCE.Read(stream);
    }

    public override int AllocationSize(PaymentDetails? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypePaymentDetails.INSTANCE.AllocationSize((PaymentDetails)value);
        }
    }

    public override void Write(PaymentDetails? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypePaymentDetails.INSTANCE.Write((PaymentDetails)value, stream);
        }
    }
}




class FfiConverterOptionalTypeSendPaymentOptions: FfiConverterRustBuffer<SendPaymentOptions?> {
    public static FfiConverterOptionalTypeSendPaymentOptions INSTANCE = new FfiConverterOptionalTypeSendPaymentOptions();

    public override SendPaymentOptions? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeSendPaymentOptions.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SendPaymentOptions? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeSendPaymentOptions.INSTANCE.AllocationSize((SendPaymentOptions)value);
        }
    }

    public override void Write(SendPaymentOptions? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeSendPaymentOptions.INSTANCE.Write((SendPaymentOptions)value, stream);
        }
    }
}




class FfiConverterOptionalTypeLogger: FfiConverterRustBuffer<Logger?> {
    public static FfiConverterOptionalTypeLogger INSTANCE = new FfiConverterOptionalTypeLogger();

    public override Logger? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeLogger.INSTANCE.Read(stream);
    }

    public override int AllocationSize(Logger? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeLogger.INSTANCE.AllocationSize((Logger)value);
        }
    }

    public override void Write(Logger? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeLogger.INSTANCE.Write((Logger)value, stream);
        }
    }
}




class FfiConverterOptionalSequenceTypePaymentStatus: FfiConverterRustBuffer<List<PaymentStatus>?> {
    public static FfiConverterOptionalSequenceTypePaymentStatus INSTANCE = new FfiConverterOptionalSequenceTypePaymentStatus();

    public override List<PaymentStatus>? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterSequenceTypePaymentStatus.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<PaymentStatus>? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterSequenceTypePaymentStatus.INSTANCE.AllocationSize((List<PaymentStatus>)value);
        }
    }

    public override void Write(List<PaymentStatus>? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterSequenceTypePaymentStatus.INSTANCE.Write((List<PaymentStatus>)value, stream);
        }
    }
}




class FfiConverterOptionalSequenceTypePaymentType: FfiConverterRustBuffer<List<PaymentType>?> {
    public static FfiConverterOptionalSequenceTypePaymentType INSTANCE = new FfiConverterOptionalSequenceTypePaymentType();

    public override List<PaymentType>? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterSequenceTypePaymentType.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<PaymentType>? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterSequenceTypePaymentType.INSTANCE.AllocationSize((List<PaymentType>)value);
        }
    }

    public override void Write(List<PaymentType>? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterSequenceTypePaymentType.INSTANCE.Write((List<PaymentType>)value, stream);
        }
    }
}




class FfiConverterOptionalSequenceTypeExternalInputParser: FfiConverterRustBuffer<List<ExternalInputParser>?> {
    public static FfiConverterOptionalSequenceTypeExternalInputParser INSTANCE = new FfiConverterOptionalSequenceTypeExternalInputParser();

    public override List<ExternalInputParser>? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterSequenceTypeExternalInputParser.INSTANCE.Read(stream);
    }

    public override int AllocationSize(List<ExternalInputParser>? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterSequenceTypeExternalInputParser.INSTANCE.AllocationSize((List<ExternalInputParser>)value);
        }
    }

    public override void Write(List<ExternalInputParser>? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterSequenceTypeExternalInputParser.INSTANCE.Write((List<ExternalInputParser>)value, stream);
        }
    }
}




class FfiConverterOptionalTypeSuccessAction: FfiConverterRustBuffer<SuccessAction?> {
    public static FfiConverterOptionalTypeSuccessAction INSTANCE = new FfiConverterOptionalTypeSuccessAction();

    public override SuccessAction? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeSuccessAction.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SuccessAction? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeSuccessAction.INSTANCE.AllocationSize((SuccessAction)value);
        }
    }

    public override void Write(SuccessAction? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeSuccessAction.INSTANCE.Write((SuccessAction)value, stream);
        }
    }
}




class FfiConverterOptionalTypeSuccessActionProcessed: FfiConverterRustBuffer<SuccessActionProcessed?> {
    public static FfiConverterOptionalTypeSuccessActionProcessed INSTANCE = new FfiConverterOptionalTypeSuccessActionProcessed();

    public override SuccessActionProcessed? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeSuccessActionProcessed.INSTANCE.Read(stream);
    }

    public override int AllocationSize(SuccessActionProcessed? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeSuccessActionProcessed.INSTANCE.AllocationSize((SuccessActionProcessed)value);
        }
    }

    public override void Write(SuccessActionProcessed? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeSuccessActionProcessed.INSTANCE.Write((SuccessActionProcessed)value, stream);
        }
    }
}




class FfiConverterOptionalTypeu128: FfiConverterRustBuffer<u128?> {
    public static FfiConverterOptionalTypeu128 INSTANCE = new FfiConverterOptionalTypeu128();

    public override u128? Read(BigEndianStream stream) {
        if (stream.ReadByte() == 0) {
            return null;
        }
        return FfiConverterTypeu128.INSTANCE.Read(stream);
    }

    public override int AllocationSize(u128? value) {
        if (value == null) {
            return 1;
        } else {
            return 1 + FfiConverterTypeu128.INSTANCE.AllocationSize((u128)value);
        }
    }

    public override void Write(u128? value, BigEndianStream stream) {
        if (value == null) {
            stream.WriteByte(0);
        } else {
            stream.WriteByte(1);
            FfiConverterTypeu128.INSTANCE.Write((u128)value, stream);
        }
    }
}




class FfiConverterSequenceString: FfiConverterRustBuffer<List<string>> {
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override List<string> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<string>(length);
        var readFn = FfiConverterString.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<string> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<string> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterString.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeDepositInfo: FfiConverterRustBuffer<List<DepositInfo>> {
    public static FfiConverterSequenceTypeDepositInfo INSTANCE = new FfiConverterSequenceTypeDepositInfo();

    public override List<DepositInfo> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<DepositInfo>(length);
        var readFn = FfiConverterTypeDepositInfo.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<DepositInfo> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeDepositInfo.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<DepositInfo> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeDepositInfo.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypePayment: FfiConverterRustBuffer<List<Payment>> {
    public static FfiConverterSequenceTypePayment INSTANCE = new FfiConverterSequenceTypePayment();

    public override List<Payment> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Payment>(length);
        var readFn = FfiConverterTypePayment.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Payment> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypePayment.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Payment> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypePayment.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeProvisionalPayment: FfiConverterRustBuffer<List<ProvisionalPayment>> {
    public static FfiConverterSequenceTypeProvisionalPayment INSTANCE = new FfiConverterSequenceTypeProvisionalPayment();

    public override List<ProvisionalPayment> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ProvisionalPayment>(length);
        var readFn = FfiConverterTypeProvisionalPayment.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ProvisionalPayment> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeProvisionalPayment.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ProvisionalPayment> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeProvisionalPayment.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeTokenMetadata: FfiConverterRustBuffer<List<TokenMetadata>> {
    public static FfiConverterSequenceTypeTokenMetadata INSTANCE = new FfiConverterSequenceTypeTokenMetadata();

    public override List<TokenMetadata> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<TokenMetadata>(length);
        var readFn = FfiConverterTypeTokenMetadata.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<TokenMetadata> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeTokenMetadata.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<TokenMetadata> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeTokenMetadata.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeUtxo: FfiConverterRustBuffer<List<Utxo>> {
    public static FfiConverterSequenceTypeUtxo INSTANCE = new FfiConverterSequenceTypeUtxo();

    public override List<Utxo> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Utxo>(length);
        var readFn = FfiConverterTypeUtxo.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Utxo> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeUtxo.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Utxo> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeUtxo.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypePaymentStatus: FfiConverterRustBuffer<List<PaymentStatus>> {
    public static FfiConverterSequenceTypePaymentStatus INSTANCE = new FfiConverterSequenceTypePaymentStatus();

    public override List<PaymentStatus> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<PaymentStatus>(length);
        var readFn = FfiConverterTypePaymentStatus.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<PaymentStatus> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypePaymentStatus.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<PaymentStatus> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypePaymentStatus.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypePaymentType: FfiConverterRustBuffer<List<PaymentType>> {
    public static FfiConverterSequenceTypePaymentType INSTANCE = new FfiConverterSequenceTypePaymentType();

    public override List<PaymentType> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<PaymentType>(length);
        var readFn = FfiConverterTypePaymentType.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<PaymentType> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypePaymentType.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<PaymentType> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypePaymentType.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeExternalInputParser: FfiConverterRustBuffer<List<ExternalInputParser>> {
    public static FfiConverterSequenceTypeExternalInputParser INSTANCE = new FfiConverterSequenceTypeExternalInputParser();

    public override List<ExternalInputParser> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<ExternalInputParser>(length);
        var readFn = FfiConverterTypeExternalInputParser.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<ExternalInputParser> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeExternalInputParser.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<ExternalInputParser> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeExternalInputParser.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeFiatCurrency: FfiConverterRustBuffer<List<FiatCurrency>> {
    public static FfiConverterSequenceTypeFiatCurrency INSTANCE = new FfiConverterSequenceTypeFiatCurrency();

    public override List<FiatCurrency> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<FiatCurrency>(length);
        var readFn = FfiConverterTypeFiatCurrency.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<FiatCurrency> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeFiatCurrency.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<FiatCurrency> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeFiatCurrency.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterSequenceTypeRate: FfiConverterRustBuffer<List<Rate>> {
    public static FfiConverterSequenceTypeRate INSTANCE = new FfiConverterSequenceTypeRate();

    public override List<Rate> Read(BigEndianStream stream) {
        var length = stream.ReadInt();
        var result = new List<Rate>(length);
        var readFn = FfiConverterTypeRate.INSTANCE.Read;
        for (int i = 0; i < length; i++) {
            result.Add(readFn(stream));
        }
        return result;
    }

    public override int AllocationSize(List<Rate> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationSizeFn = FfiConverterTypeRate.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationSizeFn(item));
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<Rate> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerFn = FfiConverterTypeRate.INSTANCE.Write;
        value.ForEach(item => writerFn(item, stream));
    }
}




class FfiConverterDictionaryStringTypeTokenBalance: FfiConverterRustBuffer<Dictionary<string, TokenBalance>> {
    public static FfiConverterDictionaryStringTypeTokenBalance INSTANCE = new FfiConverterDictionaryStringTypeTokenBalance();

    public override Dictionary<string, TokenBalance> Read(BigEndianStream stream) {
        var len = stream.ReadInt();
        var result = new Dictionary<string, TokenBalance>(len);
        var readerKey = FfiConverterString.INSTANCE.Read;
        var readerValue = FfiConverterTypeTokenBalance.INSTANCE.Read;
        for (int i = 0; i < len; i++) {
            var key = readerKey(stream);
            var value = readerValue(stream);
            result[key] = value;
        }

        return result;
    }

    public override int AllocationSize(Dictionary<string, TokenBalance> value) {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            return sizeForLength;
        }

        var allocationKeySizeFn = FfiConverterString.INSTANCE.AllocationSize;
        var allocationKValueSizeFn = FfiConverterTypeTokenBalance.INSTANCE.AllocationSize;
        var sizeForItems = value.Sum(item => allocationKeySizeFn(item.Key) + allocationKValueSizeFn(item.Value));
        return sizeForLength + sizeForItems;
    }

    public override void Write(Dictionary<string, TokenBalance> value, BigEndianStream stream) {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null) {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        var writerKey = FfiConverterString.INSTANCE.Write;
        var writerValue = FfiConverterTypeTokenBalance.INSTANCE.Write;
        foreach (var item in value) {
            writerKey(item.Key, stream);
            writerValue(item.Value, stream);
        }
    }
}



























































/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 * It's also what we have an external type that references a custom type.
 */







[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
delegate void UniFfiFutureCallback(IntPtr continuationHandle, byte pollResult);

internal static class _UniFFIAsync {
    internal const byte UNIFFI_RUST_FUTURE_POLL_READY = 0;
    // internal const byte UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1;

    internal static ConcurrentHandleMap<TaskCompletionSource<byte>> _async_handle_map = new ConcurrentHandleMap<TaskCompletionSource<byte>>();
    public static ConcurrentHandleMap<CancellationTokenSource> _foreign_futures_map = new ConcurrentHandleMap<CancellationTokenSource>();

    // FFI type for Rust future continuations
    internal class UniffiRustFutureContinuationCallback
    {
        public static UniFfiFutureCallback callback = Callback;

        public static void Callback(IntPtr continuationHandle, byte pollResult)
        {
            if (_async_handle_map.Remove((ulong)continuationHandle.ToInt64(), out TaskCompletionSource<byte> task))
            {
                task.SetResult(pollResult);
            }
            else 
            {
                throw new InternalException($"Unable to find continuation handle: {continuationHandle}");
            }
        }
    }

    public class UniffiForeignFutureFreeCallback
    {
        public static _UniFFILib.UniffiForeignFutureFree callback = Callback;

        public static void Callback(ulong handle)
        {
            if (_foreign_futures_map.Remove(handle, out CancellationTokenSource task))
            {
                task.Cancel();
            }
            else
            {
                throw new InternalException($"Unable to find cancellation token: {handle}");
            }
        }
    }

    public delegate F CompleteFuncDelegate<F>(IntPtr ptr, ref UniffiRustCallStatus status);

    public delegate void CompleteActionDelegate(IntPtr ptr, ref UniffiRustCallStatus status);

    private static async Task PollFuture(IntPtr rustFuture, Action<IntPtr, IntPtr, IntPtr> pollFunc)
    {
        byte pollResult;
        do 
        {
            var tcs = new TaskCompletionSource<byte>(TaskCreationOptions.RunContinuationsAsynchronously);
            IntPtr callback = Marshal.GetFunctionPointerForDelegate(UniffiRustFutureContinuationCallback.callback);
            ulong mapEntry = _async_handle_map.Insert(tcs);
            pollFunc(rustFuture, callback, (IntPtr)mapEntry);
            pollResult = await tcs.Task;
        }
        while(pollResult != UNIFFI_RUST_FUTURE_POLL_READY);
    }

    public static async Task<T> UniffiRustCallAsync<T, F, E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteFuncDelegate<F> completeFunc,
        Action<IntPtr> freeFunc,
        Func<F, T> liftFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
        try {
            await PollFuture(rustFuture, pollFunc);
            var result = _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));
            return liftFunc(result);
        }
        finally
        {
            freeFunc(rustFuture);
        }
    }

    public static async Task UniffiRustCallAsync<E>(
        IntPtr rustFuture,
        Action<IntPtr, IntPtr, IntPtr> pollFunc,
        CompleteActionDelegate completeFunc,
        Action<IntPtr> freeFunc,
        CallStatusErrorHandler<E> errorHandler
    ) where E : UniffiException
    {
         try {
            await PollFuture(rustFuture, pollFunc);
            _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));

        }
        finally
        {
            freeFunc(rustFuture);
        }
    }
}
#pragma warning restore 8625
public static class BreezSdkSparkMethods {
    /// <summary>
    /// Connects to the Spark network using the provided configuration and mnemonic.
    ///
    /// # Arguments
    ///
    /// * `request` - The connection request object
    ///
    /// # Returns
    ///
    /// Result containing either the initialized `BreezSdk` or an `SdkError`
    /// </summary>
    /// <exception cref="SdkException"></exception>
   public static async Task<BreezSdk> Connect(ConnectRequest @request) 
   {
    return await _UniFFIAsync.UniffiRustCallAsync(
        // Get rust future
        _UniFFILib.uniffi_breez_sdk_spark_fn_func_connect(FfiConverterTypeConnectRequest.INSTANCE.Lower(@request)),
        // Poll
        (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_breez_sdk_spark_rust_future_poll_pointer(future, continuation, data),
        // Complete
        (IntPtr future, ref UniffiRustCallStatus status) => {
            return _UniFFILib.ffi_breez_sdk_spark_rust_future_complete_pointer(future, ref status);
        },
        // Free
        (IntPtr future) => _UniFFILib.ffi_breez_sdk_spark_rust_future_free_pointer(future),
        // Lift
        (result) => FfiConverterTypeBreezSdk.INSTANCE.Lift(result),
        // Error
        FfiConverterTypeSdkError.INSTANCE
    );
   }
    public static Config DefaultConfig(Network @network) {
        return FfiConverterTypeConfig.INSTANCE.Lift(
    _UniffiHelpers.RustCall( (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_breez_sdk_spark_fn_func_default_config(FfiConverterTypeNetwork.INSTANCE.Lower(@network), ref _status)
));
    }


    /// <exception cref="SdkException"></exception>
    public static void InitLogging(string? @logDir, Logger? @appLogger, string? @logFilter) {
        
    _UniffiHelpers.RustCallWithError(FfiConverterTypeSdkError.INSTANCE, (ref UniffiRustCallStatus _status) =>
    _UniFFILib.uniffi_breez_sdk_spark_fn_func_init_logging(FfiConverterOptionalString.INSTANCE.Lower(@logDir), FfiConverterOptionalTypeLogger.INSTANCE.Lower(@appLogger), FfiConverterOptionalString.INSTANCE.Lower(@logFilter), ref _status)
);
    }


}

