# Breez SDK - Nodeless (Spark)

# About Breez SDK - Nodeless *(Spark Implementation)*

## **What Is the Breez SDK?**

The Breez SDK provides developers with an end-to-end solution for integrating self-custodial bitcoin into their apps and services. It eliminates the need for third parties, simplifies the complexities of Bitcoin and Lightning, and enables seamless onboarding for billions of users to the future of value transfer.

## **What Is the Breez SDK - Nodeless *(Spark Implementation)*?**

It’s a nodeless integration that offers a self-custodial, end-to-end solution for integrating Lightning payments, utilizing Spark with on-chain interoperability and third-party fiat on-ramps. Using the SDK you will able to:
- **Send payments** via various protocols such as: Lightning address, LNURL-Pay, Bolt11, BTC address, Spark address, BTKN
- **Receive payments** via various protocols such as: Lightning address, LNURL-Pay, Bolt11, BTC address, Spark address, BTKN
  
**Key Features**

- [x] Send and receive Lightning payments
- [x] Send and receive via LNURL-pay & Lightning addresses 
- [x] Send and receive Spark payments (BTC)
- [x] Issue, send and receive Spark tokens (BTKN)
- [x] On-chain interoperability
- [x] Bindings to all popular languages & frameworks
- [x] Keys are only held by users
- [x] Multi-app & multi-device support via real-time sync service 
- [x] Payments persistency including restore support
- [x] Automatic claims
- [x] WebAssembly support
- [x] Compatible with external signers
- [x] Free open-source solution

## Pricing

The Breez SDK is **free** for developers. 

## Support

Have a question for the team? Join us on [Telegram](https://t.me/breezsdk) or email us at <contact@breez.technology>.


## Repository

Head over to the <a href="https://github.com/breez/spark-sdk" target="_blank">Breez SDK - Nodeless *(Spark Implementation)*</a> repo.


## Ready to Light Up Your App? 
**→ [Get Started](/guide/getting_started.md)** 



# Getting Started

Integrating Breez SDK into your application takes just a few minutes. Follow these steps to get started:

- **[Installing the SDK](/guide/install.md)**
- **[Testing and development](/guide/testing.md)**
- **[Initializing the SDK](/guide/initializing.md)**
  - **[Customizing the SDK](/guide/customizing.md)**
- **[Fetching the balance](/guide/get_info.md)**
- **[Listening to events](/guide/events.md)**
- **[Adding logging](/guide/logging.md)**
- **[Custom configuration](/guide/config.md)**

## API Key

The _Nodeless_ Breez API key must be set for the SDK to work. You can request one by filling our form <a target="_blank" href="https://breez.technology/request-api-key/#contact-us-form-sdk">here</a>, or programmatically:

```bash
curl -d "fullname=<full name>" -d "company=<company>" -d "email=<email>" -d "message=<message>" \
  https://breez.technology/contact/apikey
```

## UX Guidelines

When implementing the Breez SDK, we recommend reading through our [UX Guidelines](/guide/uxguide.md) to provide a consistent and intuitive experience for your end-users.

Many of the guidelines are implemented in [Glow](https://glow-app.co), which you can use as a UX reference during SDK implementation.

## Demo

Looking for a quick way to try the SDK in your browser or as PWA? Check out our demo app *Glow*:

- **Live demo:** [https://glow-app.co](https://glow-app.co)
- **Repo:** [breez/breez-sdk-spark-example](https://github.com/breez/breez-sdk-spark-example)  

> **Note:** The demo is for demonstration purposes only and not intended for production use.

## Support

Have a question for the team? Join us on [Telegram](https://t.me/breezsdk) or email us at [contact@breez.technology](mailto:contact@breez.technology).

# Installing the SDK

The Breez SDK is available in the following platforms:

## iOS/Swift

We support integration via the [Swift Package Manager](https://www.swift.org/package-manager/) and via [CocoaPods](https://cocoapods.org/).
See [breez/breez-sdk-spark-swift](https://github.com/breez/breez-sdk-spark-swift) for more information.

### Swift Package Manager

#### Installation via Xcode

Via `File > Add Packages...`, add

```
https://github.com/breez/breez-sdk-spark-swift.git
```

as a package dependency in Xcode.

#### Installation via Swift Package Manifest

Add the following to the dependencies array of your `Package.swift`:

``` swift
.package(url: "https://github.com/breez/breez-sdk-spark-swift.git", from: "0.7.10"),
```

### CocoaPods

Add the Breez SDK to your `Podfile` like so:

``` ruby
target '<YourApp>' do
  use_frameworks!
  pod 'BreezSdkSpark'
end
```

## Android/Kotlin

We recommend integrating the Breez SDK as Gradle dependency from [our Maven repository](https://mvn.breez.technology/#/releases).

To do so, add the following to your Gradle dependencies:

```gradle
repositories {
  maven {
      url("https://mvn.breez.technology/releases")
  }
}
```

### Android Only

```gradle
dependencies {
  implementation("breez_sdk_spark:bindings-android:0.7.10")
}
```

### Kotlin Multiplatform

```gradle
dependencies {
  implementation("technology.breez.spark:breez-sdk-spark-kmp:0.7.10")
}
```

## Javascript/Typescript (Wasm)

We recommend using the official npm package: [@breeztech/breez-sdk-spark](https://www.npmjs.com/package/@breeztech/breez-sdk-spark).

> **Note:** If using Node.js, the minimum supported version is v22.

```console
npm install @breeztech/breez-sdk-spark
```
or
```console
yarn add @breeztech/breez-sdk-spark
```

## React Native/Expo Managed Workflow

We recommend using the official npm package: [@breeztech/breez-sdk-spark-react-native](https://www.npmjs.com/package/@breeztech/breez-sdk-spark-react-native).

#### React Native

```console
npm install @breeztech/breez-sdk-spark-react-native
```
or
```console
yarn add @breeztech/breez-sdk-spark-react-native
```

#### Expo Managed Workflow

```console
npx expo install @breeztech/breez-sdk-spark-react-native
```

Add the plugin to your `app.json` or `app.config.js`:

```json
{
  "expo": {
    "plugins": [
      "@breeztech/breez-sdk-spark-react-native"
    ]
  }
}
```

**Note:** This package contains native code and requires a custom development build. It will not work with Expo Go.

## Rust

We recommend to add breez sdk as a git dependency with a specific release tag.
Check [breez/spark-sdk](https://github.com/breez/spark-sdk/releases) for the latest version.

```toml
[dependencies]
breez-sdk-spark = { git = "https://github.com/breez/spark-sdk", tag = "0.7.10" }
```

## Flutter

We recommend to add our official flutter package as a git dependency. 

```yaml
dependencies:
  breez_sdk_spark_flutter:
    git:
      url: https://github.com/breez/breez-sdk-spark-flutter
```

## Go

We recommend using our official Go package: [breez/breez-sdk-spark-go](https://github.com/breez/breez-sdk-spark-go).

```console
go get github.com/breez/breez-sdk-spark-go
```

## Python

We recommend using our official Python package: [breez-sdk-spark](https://pypi.org/project/breez-sdk-spark).

```console
pip install breez-sdk-spark
```

## C#

We recommend using our official NuGet package: [Breez.Sdk.Spark](https://www.nuget.org/packages/Breez.Sdk.Spark).

### Using .NET CLI

```console
dotnet add package Breez.Sdk.Spark
```

### Using Package Manager Console

```console
Install-Package Breez.Sdk.Spark
```

### Using PackageReference

Add the following to your `.csproj` file:

```xml
<ItemGroup>
  <PackageReference Include="Breez.Sdk.Spark" Version="0.7.10" />
</ItemGroup>
```

# Testing and development

## Regtest Network

For most testing and development, we recommend using the **Regtest Network** - a deployed test network maintained by Lightspark that is free to use and carries no real-world value.

### What you can test on Regtest

- **Spark Payments**: Bitcoin and token payments using the Spark protocol
- **Deposits**: Receiving test Bitcoin from the [Lightspark Regtest Faucet](https://app.lightspark.com/regtest-faucet)
- **Withdrawals**: Sending funds back to on-chain addresses
- **Token Issuance**: Creating and testing tokens using the SDK's [issuing functionality](./issuing_tokens.md)

### Getting started

1. [Initialize the SDK](./initializing.md) using the default regtest config (no API key required)
2. [Generate a Bitcoin receiving address](./receive_payment.md#bitcoin)
3. Request funds from the [faucet](https://app.lightspark.com/regtest-faucet) to your generated address
4. Test all Spark-related functionality in a controlled development environment

## Lightning Network testing

For Lightning payments specifically, we recommend testing on **Mainnet with small amounts** since the Regtest Network doesn't have a developed Lightning Network.

Use real satoshis but keep transaction values very low while verifying payment flows work correctly.

## Development best practices

- **Start with Regtest** for most development and testing
- **Use Mainnet** for Lightning testing
- **Test all payment types** you plan to support in your application

<h1 id="initializing">
    <a class="header" href="#initializing">Initializing the SDK</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.connect">API docs</a>
</h1>

## Basic Initialization

The easiest way to initialize the SDK is with the `connect` method. This method requires:

- The network, mnemonic, and Breez API key you intend to use
- A storage directory path where the SDK can manage its data

<div class="warning">
<h4>Developer note</h4>
For WASM Web, SDK storage is managed using IndexedDB.
</div>

The storage is used to persist the SDK’s state. If you run multiple SDK instances, each must have its own unique storage directory.

Once connected, you’re ready to start interacting with the SDK.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Construct the seed using mnemonic words or entropy bytes
let mnemonic = "<mnemonic words>".to_string();
let seed = Seed::Mnemonic {
    mnemonic,
    passphrase: None,
};

// Create the default config
let mut config = default_config(Network::Mainnet);
config.api_key = Some("<breez api key>".to_string());

// Connect to the SDK using the simplified connect method
let sdk = connect(ConnectRequest {
    config,
    seed,
    storage_dir: "./.data".to_string(),
})
.await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Construct the seed using mnemonic words or entropy bytes
let mnemonic = "<mnemonic words>"
let seed = Seed.mnemonic(mnemonic: mnemonic, passphrase: nil)

// Create the default config
var config = defaultConfig(network: Network.mainnet)
config.apiKey = "<breez api key>"

// Connect to the SDK using the simplified connect method
let sdk = try await connect(
    request: ConnectRequest(
        config: config,
        seed: seed,
        storageDir: "./.data"
    ))
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Construct the seed using mnemonic words or entropy bytes
val mnemonic = "<mnemonic words>"
val seed = Seed.Mnemonic(mnemonic, null)

// Create the default config
val config = defaultConfig(Network.MAINNET)
config.apiKey = "<breez api key>"

try {
    // Connect to the SDK using the simplified connect method
    val sdk = connect(ConnectRequest(
        config = config,
        seed = seed,
        storageDir = "./.data"
    ))
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Construct the seed using mnemonic words or entropy bytes
var mnemonic = "<mnemonic words>";
var seed = new Seed.Mnemonic(mnemonic: mnemonic, passphrase: null);
// Create the default config
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    apiKey = "<breez api key>"
};
// Connect to the SDK using the simplified connect method
var sdk = await BreezSdkSparkMethods.Connect(
    request: new ConnectRequest(
        config: config,
        seed: seed,
        storageDir: "./.data"
    )
);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Call init when using the SDK in a web environment before calling any other SDK
// methods. This is not needed when using the SDK in a Node.js/Deno environment.
//
// import init, { BreezSdk, defaultConfig } from '@breeztech/breez-sdk-spark'
await init()

// Construct the seed using mnemonic words or entropy bytes
const mnemonic = '<mnemonic words>'
const seed: Seed = { type: 'mnemonic', mnemonic, passphrase: undefined }

// Create the default config
const config = defaultConfig('mainnet')
config.apiKey = '<breez api key>'

// Connect to the SDK using the simplified connect method
const sdk = await connect({
  config,
  seed,
  storageDir: './.data'
})
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Construct the seed using mnemonic words or entropy bytes
const mnemonic = '<mnemonics words>'
const seed = new Seed.Mnemonic({ mnemonic, passphrase: undefined })

// Create the default config
const config = defaultConfig(Network.Mainnet)
config.apiKey = '<breez api key>'

const sdk = await connect({
  config,
  seed,
  storageDir: `${RNFS.DocumentDirectoryPath}/data`
})
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Call once on your Dart entrypoint file, e.g.; `lib/main.dart`
// or singleton SDK service. It is recommended to use a single instance
// of the SDK across your Flutter app.
await BreezSdkSparkLib.init();

// Construct the seed using mnemonic words or entropy bytes
String mnemonic = "<mnemonic words>";
final seed = Seed.mnemonic(mnemonic: mnemonic, passphrase: null);

// Create the default config
final config = defaultConfig(network: Network.mainnet)
    .copyWith(apiKey: "<breez api key>");

final connectRequest =
    ConnectRequest(config: config, seed: seed, storageDir: "./.data");

final sdk = await connect(request: connectRequest);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Construct the seed using mnemonic words or entropy bytes
mnemonic = "<mnemonic words>"
seed = Seed.MNEMONIC(mnemonic=mnemonic, passphrase=None)
# Create the default config
config = default_config(network=Network.MAINNET)
config.api_key = "<breez api key>"
try:
    # Connect to the SDK using the simplified connect method
    sdk = await connect(
        request=ConnectRequest(config=config, seed=seed, storage_dir="./.data")
    )
    return sdk
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Construct the seed using mnemonic words or entropy bytes
mnemonic := "<mnemonic words>"
var seed breez_sdk_spark.Seed = breez_sdk_spark.SeedMnemonic{
	Mnemonic:   mnemonic,
	Passphrase: nil,
}

// Create the default config
apiKey := "<breez api key>"
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
config.ApiKey = &apiKey

connectRequest := breez_sdk_spark.ConnectRequest{
	Config:     config,
	Seed:       seed,
	StorageDir: "./.data",
}

// Connect to the SDK using the simplified connect method
sdk, err := breez_sdk_spark.Connect(connectRequest)

return sdk, err
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>

On some platforms (e.g., Android, iOS), you must use an application-specific writable directory within the app’s sandbox for SDK storage.

</div>

## Advanced Initialization

For advanced use cases where you need more control, you can configure the SDK using the Builder pattern. With the SDK Builder you can define:

- [Storage](customizing.md#with-storage) and [Real-Time Storage](customizing.md#with-real-time-storage) to manage stored data
- [Bitcoin Chain Service](customizing.md#with-chain-service) to provide network data
- [LNURL Client](customizing.md#with-lnurl-client) to make REST requests
- [Fiat Service](customizing.md#with-fiat-service) to provide Fiat currencies and exchange rates 
- Change the [Key Set](customizing.md#with-key-set) to alter the derivation path used
- [Payment Observer](customizing.md#with-payment-observer) to be notified before payments occur

See [Customizing the SDK](customizing.md) for examples of this advanced initialization pattern.

<h2 id="disconnecting">
    <a class="header" href="#disconnecting">Disconnecting</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.disconnect">API docs</a>
</h2>

When you’re done using the SDK, call the disconnect method to release any resources in use.

This is particularly useful if you need to re-instantiate the SDK, such as when changing the mnemonic or updating configuration.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
pub(crate) async fn disconnect(sdk: &BreezSdk) -> Result<()> {
    sdk.disconnect().await?;
    Ok(())
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
func disconnect(sdk: BreezSdk) async throws {
    try await sdk.disconnect()
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
suspend fun disconnect(sdk: BreezSdk)  {
    try {
        sdk.disconnect()
    } catch (e: Exception) {
        // handle error
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
async Task Disconnect(BreezSdk sdk)
{
    await sdk.Disconnect();
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
await sdk.disconnect()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
await sdk.disconnect()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
Future<void> disconnect(BreezSdk sdk) async {
  await sdk.disconnect();
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
async def disconnect(sdk: BreezSdk):
    try:
        await sdk.disconnect()
    except Exception as error:
        logging.error(error)
        raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
func Disconnect(sdk *breez_sdk_spark.BreezSdk) {
	sdk.Disconnect()
}
```

</section>

</custom-tabs>


# Customizing the SDK

Using the SDK Builder gives you more control over the initialization and modular components used when the SDK is running. Below you can find examples of initializing the SDK using the SDK Builder and implementing modular components:

- [Storage](#with-storage) and [Real-Time Storage](#with-real-time-storage) to manage stored data
- [Bitcoin Chain Service](#with-chain-service) to provide network data
- [LNURL Client](#with-lnurl-client) to make REST requests
- [Fiat Service](#with-fiat-service) to provide Fiat currencies and exchange rates
- Change the [Key Set](#with-key-set) to alter the derivation path used
- [Payment Observer](#with-payment-observer) to be notified before payments occur

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Construct the seed using mnemonic words or entropy bytes
let mnemonic = "<mnemonic words>".to_string();
let seed = Seed::Mnemonic {
    mnemonic,
    passphrase: None,
};

// Create the default config
let mut config = default_config(Network::Mainnet);
config.api_key = Some("<breez api key>".to_string());

// Build the SDK using the config, seed and default storage
let builder = SdkBuilder::new(config, seed).with_default_storage("./.data".to_string());
// You can also pass your custom implementations:
// let builder = builder.with_storage(<your storage implementation>)
// let builder = builder.with_real_time_sync_storage(<your real-time sync storage implementation>)
// let builder = builder.with_chain_service(<your chain service implementation>)
// let builder = builder.with_rest_client(<your rest client implementation>)
// let builder = builder.with_key_set(KeySetConfig { key_set_type: <your key set type>, use_address_index: <use address index>, account_number: <account number> })
// let builder = builder.with_payment_observer(<your payment observer implementation>);
let sdk = builder.build().await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Construct the seed using mnemonic words or entropy bytes
let mnemonic = "<mnemonic words>"
let seed = Seed.mnemonic(mnemonic: mnemonic, passphrase: nil)

// Create the default config
var config = defaultConfig(network: Network.mainnet)
config.apiKey = "<breez api key>"

// Build the SDK using the config, seed and default storage
let builder = SdkBuilder(config: config, seed: seed)
await builder.withDefaultStorage(storageDir: "./.data")
// You can also pass your custom implementations:
// await builder.withStorage(<your storage implementation>)
// await builder.withRealTimeSyncStorage(<your real-time sync storage implementation>)
// await builder.withChainService(<your chain service implementation>)
// await builder.withRestClient(<your rest client implementation>)
// await builder.withKeySet(<your key set type>, <use address index>, <account number>)
// await builder.withPaymentObserver(<your payment observer implementation>)
let sdk = try await builder.build()
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Construct the seed using mnemonic words or entropy bytes
val mnemonic = "<mnemonic words>"
val seed = Seed.Mnemonic(mnemonic, null)

// Create the default config
val config = defaultConfig(Network.MAINNET)
config.apiKey = "<breez api key>"

try {
    // Build the SDK using the config, seed and default storage
    val builder = SdkBuilder(config, seed)
    builder.withDefaultStorage("./.data")
    // You can also pass your custom implementations:
    // builder.withStorage(<your storage implementation>)
    // builder.withRealTimeSyncStorage(<your real-time sync storage implementation>)
    // builder.withChainService(<your chain service implementation>)
    // builder.withRestClient(<your rest client implementation>)
    // builder.withKeySet(<your key set type>, <use address index>, <account number>)
    // builder.withPaymentObserver(<your payment observer implementation>)
    val sdk = builder.build()
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Construct the seed using mnemonic words or entropy bytes
var mnemonic = "<mnemonic words>";
var seed = new Seed.Mnemonic(mnemonic: mnemonic, passphrase: null);
// Create the default config
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    apiKey = "<breez api key>"
};
// Build the SDK using the config, seed and default storage
var builder = new SdkBuilder(config: config, seed: seed);
await builder.WithDefaultStorage(storageDir: "./.data");
// You can also pass your custom implementations:
// await builder.WithStorage(<your storage implementation>)
// await builder.WithRealTimeSyncStorage(<your real-time sync storage implementation>)
// await builder.WithChainService(<your chain service implementation>)
// await builder.WithRestClient(<your rest client implementation>)
// await builder.WithKeySet(<your key set type>, <use address index>, <account number>)
// await builder.WithPaymentObserver(<your payment observer implementation>);
var sdk = await builder.Build();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Call init when using the SDK in a web environment before calling any other SDK
// methods. This is not needed when using the SDK in a Node.js/Deno environment.
await init()

// Construct the seed using mnemonic words or entropy bytes
const mnemonic = '<mnemonic words>'
const seed: Seed = { type: 'mnemonic', mnemonic, passphrase: undefined }

// Create the default config
const config = defaultConfig('mainnet')
config.apiKey = '<breez api key>'

// Build the SDK using the config, seed and default storage
let builder = SdkBuilder.new(config, seed)
builder = await builder.withDefaultStorage('./.data')
// You can also pass your custom implementations:
// builder = builder.withStorage(<your storage implementation>)
// builder = builder.withRealTimeSyncStorage(<your real-time sync storage implementation>)
// builder = builder.withChainService(<your chain service implementation>)
// builder = builder.withRestClient(<your rest client implementation>)
// builder = builder.withKeySet({ keySetType: <your key set type>, useAddressIndex: <use address index>, accountNumber: <account number> })
// builder = builder.withPaymentObserver(<your payment observer implementation>)
const sdk = await builder.build()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Construct the seed using mnemonic words or entropy bytes
const mnemonic = '<mnemonics words>'
const seed = new Seed.Mnemonic({ mnemonic, passphrase: undefined })

// Create the default config
const config = defaultConfig(Network.Mainnet)
config.apiKey = '<breez api key>'

// Build the SDK using the config, seed and default storage
const builder = new SdkBuilder(config, seed)
await builder.withDefaultStorage(`${RNFS.DocumentDirectoryPath}/data`)
// You can also pass your custom implementations:
// await builder.withStorage(<your storage implementation>)
// await builder.withRealTimeSyncStorage(<your real-time sync storage implementation>)
// await builder.withChainService(<your chain service implementation>)
// await builder.withRestClient(<your rest client implementation>)
// await builder.withKeySet({ keySetType: <your key set type>, useAddressIndex: <use address index>, accountNumber: <account number> })
// await builder.withPaymentObserver(<your payment observer implementation>)
const sdk = await builder.build()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Construct the seed using mnemonic words or entropy bytes
String mnemonic = "<mnemonic words>";
final seed = Seed.mnemonic(mnemonic: mnemonic, passphrase: null);

// Create the default config
final config = defaultConfig(network: Network.mainnet)
    .copyWith(apiKey: "<breez api key>");

// Build the SDK using the config, seed and default storage
final builder = SdkBuilder(config: config, seed: seed);
builder.withDefaultStorage(storageDir: "./.data");
// You can also pass your custom implementations:
// builder.withRestChainService(
//     url: "https://custom.chain.service",
//     credentials: Credentials(
//         username: "service-username", password: "service-password"));
// builder.withKeySet(config: KeySetConfig(keySetType: <your key set type>, useAddressIndex: <use address index>, accountNumber: <account number>));
final sdk = await builder.build();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Construct the seed using mnemonic words or entropy bytes
mnemonic = "<mnemonic words>"
seed = Seed.MNEMONIC(mnemonic=mnemonic, passphrase=None)
# Create the default config
config = default_config(network=Network.MAINNET)
config.api_key = "<breez api key>"
try:
    # Build the SDK using the config, seed and default storage
    builder = SdkBuilder(config=config, seed=seed)
    await builder.with_default_storage(storage_dir="./.data")
    # You can also pass your custom implementations:
    # await builder.with_storage(<your storage implementation>)
    # await builder.with_real_time_sync_storage(<your real-time sync storage implementation>)
    # await builder.with_chain_service(<your chain service implementation>)
    # await builder.with_rest_client(<your rest client implementation>)
    # await builder.with_key_set(<your key set type>, <use address index>, <account number>)
    # await builder.with_payment_observer(<your payment observer implementation>)
    sdk = await builder.build()
    return sdk
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Construct the seed using mnemonic words or entropy bytes
mnemonic := "<mnemonic words>"
var seed breez_sdk_spark.Seed = breez_sdk_spark.SeedMnemonic{
	Mnemonic:   mnemonic,
	Passphrase: nil,
}

// Create the default config
apiKey := "<breez api key>"
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
config.ApiKey = &apiKey

// Build the SDK using the config, seed and default storage
builder := breez_sdk_spark.NewSdkBuilder(config, seed)
builder.WithDefaultStorage("./.data")
// You can also pass your custom implementations:
// builder.WithStorage(<your storage implementation>)
// builder.WithRealTimeSyncStorage(<your real-time sync storage implementation>)
// builder.WithChainService(<your chain service implementation>)
// builder.WithRestClient(<your rest client implementation>)
// builder.WithKeySet(<your key set type>, <use address index>, <account number>)
// builder.WithPaymentObserver(<your payment observer implementation>)
sdk, err := builder.Build()

return sdk, err
```

</section>

</custom-tabs>


<h2 id="with-storage">
    <a class="header" href="#with-storage">With Storage</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_storage">API docs</a>
</h2>

When using the SDK Builder, you either have to provide a Storage implementation or use the default storage from the SDK.

**Note:** Flutter currently only supports using the default storage.

<h2 id="with-real-time-storage">
    <a class="header" href="#with-real-time-storage">With Real-Time Sync Storage</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_real_time_sync_storage">API docs</a>
</h2>

If you are providing your own Storage implementation, you also need to provide a Real-Time Sync Storage implementation when real-time sync is enabled. When using the default storage from the SDK, this is already provided.

**Note:** Flutter currently only supports using the default storage.

<h2 id="with-chain-service">
    <a class="header" href="#with-chain-service">With Chain Service</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_chain_service">API docs</a>
</h2>

The SDK provides a default Bitcoin Chain Service implementation. If you want to use your own, you can provide it either by using [With REST Chain Service](#with-rest-chain-service) or by implementing the Bitcoin Chain Service interface.

<h2 id="with-rest-chain-service">
    <a class="header" href="#with-rest-chain-service">With REST Chain Service</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_rest_chain_service">API docs</a>
</h2>

The SDK provides a default Bitcoin Chain Service implementation. If you want to use your own, you can provide it either by using [With Chain Service](#with-chain-service) or by providing a URL and optional credentials.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let url = "<your REST chain service URL>".to_string();
let chain_api_type = ChainApiType::MempoolSpace;
let optional_credentials = Credentials {
    username: "<username>".to_string(),
    password: "<password>".to_string(),
};
builder.with_rest_chain_service(
    url,
    chain_api_type,
    Some(optional_credentials),
)
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let url = "<your REST chain service URL>"
let chainApiType = ChainApiType.mempoolSpace
let optionalCredentials = Credentials(
    username: "<username>",
    password: "<password>"
)
await builder.withRestChainService(
    url: url,
    apiType: chainApiType,
    credentials: optionalCredentials
)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val url = "<your REST chain service URL>"
val chainApiType = ChainApiType.MEMPOOL_SPACE
val optionalCredentials = Credentials(
    username = "<username>",
    password = "<password>"
)
builder.withRestChainService(
    url = url,
    apiType = chainApiType,
    credentials = optionalCredentials
)
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var url = "<your REST chain service URL>";
var chainApiType = ChainApiType.MempoolSpace;
var optionalCredentials = new Credentials(
    username: "<username>",
    password: "<password>"
);
await builder.WithRestChainService(
    url: url,
    apiType: chainApiType,
    credentials: optionalCredentials
);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const url = '<your REST chain service URL>'
const chainApiType = 'mempoolSpace'
const optionalCredentials: Credentials = {
  username: '<username>',
  password: '<password>'
}
builder = builder.withRestChainService(url, chainApiType, optionalCredentials)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const url = '<your REST chain service URL>'
const chainApiType = ChainApiType.MempoolSpace
const optionalCredentials: Credentials = {
  username: '<username>',
  password: '<password>'
}
await builder.withRestChainService(url, chainApiType, optionalCredentials)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String url = "<your REST chain service URL>";
var chainApiType = ChainApiType.mempoolSpace;
var optionalCredentials = Credentials(
  username: "<username>",
  password: "<password>",
);
builder.withRestChainService(
  url: url,
  apiType: chainApiType,
  credentials: optionalCredentials,
);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
url = "<your REST chain service URL>"
chain_api_type = ChainApiType.MEMPOOL_SPACE
optional_credentials = Credentials(
    username="<username>",
    password="<password>",
)
await builder.with_rest_chain_service(
    url=url,
    api_type=chain_api_type,
    credentials=optional_credentials,
)
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
url := "<your REST chain service URL>"
chainApiType := breez_sdk_spark.ChainApiTypeMempoolSpace
optionalCredentials := &breez_sdk_spark.Credentials{
	Username: "<username>",
	Password: "<password>",
}
builder.WithRestChainService(url, chainApiType, optionalCredentials)
```

</section>

</custom-tabs>


<h2 id="with-fiat-service">
    <a class="header" href="#with-fiat-service">With Fiat Service</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_fiat_service">API docs</a>
</h2>

The SDK by default provides a list of available Fiat currencies and current exchange rates. If you want to use your own, you can provide it by implementing the Fiat Service interface.

<h2 id="with-lnurl-client">
    <a class="header" href="#with-lnurl-client">With LNURL Client</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_lnurl_client">API docs</a>
</h2>

The LNURL Client is used to make REST requests specifically when interacting with LNURL. If you want to use your own, you can it provide by implementing the REST Service interface.

<h2 id="with-key-set">
    <a class="header" href="#with-key-set">With Key Set</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_key_set">API docs</a>
</h2>

The SDK uses by default the Default key set with the account number 1 on Mainnet (0 on Regtest). You can change this to alter the derivation path used with the provided seed:

- **Default** - Uses derivation path `m/8797555'/<account number>` (use address index is ignored)
- **Taproot** - Uses derivation path `m/86'/0'/<account number>'/0/0`<br/>(or `m/86'/0'/0'/0/<account number>` when use address index is enabled)
- **Native Segwit** - Uses derivation path `m/84'/0'/<account number>'/0/0`<br/>(or `m/84'/0'/0'/0/<account number>` when use address index is enabled)
- **Wrapped Segwit** - Uses derivation path `m/49'/0'/<account number>'/0/0`<br/>(or `m/49'/0'/0'/0/<account number>` when use address index is enabled)
- **Legacy** - Uses derivation path `m/44'/0'/<account number>'/0/0`<br/>(or `m/44'/0'/0'/0/<account number>` when use address index is enabled)

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let key_set_type = KeySetType::Default;
let use_address_index = false;
let optional_account_number = 21;
builder.with_key_set(KeySetConfig {
    key_set_type,
    use_address_index,
    account_number: Some(optional_account_number),
})
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let keySetType = KeySetType.default
let useAddressIndex = false
let optionalAccountNumber = UInt32(21)

let config = KeySetConfig(
    keySetType: keySetType,
    useAddressIndex: useAddressIndex,
    accountNumber: optionalAccountNumber
)

await builder.withKeySet(config: config)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val keySetType = KeySetType.DEFAULT
val useAddressIndex = false
val optionalAccountNumber = 21u

val keySetConfig = KeySetConfig(
    keySetType = keySetType,
    useAddressIndex = useAddressIndex,
    accountNumber = optionalAccountNumber
)

builder.withKeySet(keySetConfig)
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var keySetType = KeySetType.Default;
var useAddressIndex = false;
var optionalAccountNumber = 21u;

var keySetConfig = new KeySetConfig(
    keySetType: keySetType,
    useAddressIndex: useAddressIndex,
    accountNumber: optionalAccountNumber
);

await builder.WithKeySet(keySetConfig);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
builder = builder.withKeySet({
  keySetType: 'default',
  useAddressIndex: false,
  accountNumber: 21
})
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const keySetConfig: KeySetConfig = {
  keySetType: KeySetType.Default,
  useAddressIndex: false,
  accountNumber: 21
}
await builder.withKeySet(keySetConfig)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
var keySetType = KeySetType.default_;
var useAddressIndex = false;
var optionalAccountNumber = 21;
builder.withKeySet(
  config: KeySetConfig(
    keySetType: keySetType,
    useAddressIndex: useAddressIndex,
    accountNumber: optionalAccountNumber,
  ),
);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
key_set_type = KeySetType.DEFAULT
use_address_index = False
optional_account_number = 21

key_set_config = KeySetConfig(
    key_set_type=key_set_type,
    use_address_index=use_address_index,
    account_number=optional_account_number,
)

await builder.with_key_set(config=key_set_config)
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
keySetType := breez_sdk_spark.KeySetTypeDefault
useAccountIndex := true
optionalAccountNumber := uint32(21)

keySetConfig := breez_sdk_spark.KeySetConfig{
	KeySetType:      keySetType,
	UseAddressIndex: useAccountIndex,
	AccountNumber:   &optionalAccountNumber,
}

builder.WithKeySet(keySetConfig)
```

</section>

</custom-tabs>


<h2 id="with-payment-observer">
    <a class="header" href="#with-payment-observer">With Payment Observer</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.SdkBuilder.html#method.with_payment_observer">API docs</a>
</h2>

By implementing the Payment Observer interface you can be notified before a payment is sent. It includes information about the provisional payment including the payment ID, amount to be sent (in satoshis or token base units) and payment details based on the payment method.

**Note:** Flutter currently does not support this.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
pub(crate) struct ExamplePaymentObserver {}

#[async_trait]
impl PaymentObserver for ExamplePaymentObserver {
    async fn before_send(
        &self,
        payments: Vec<ProvisionalPayment>,
    ) -> Result<(), PaymentObserverError> {
        for payment in payments {
            info!(
                "About to send payment: {:?} of amount {:?}",
                payment.payment_id, payment.amount
            );
        }
        Ok(())
    }
}

pub(crate) fn with_payment_observer(builder: SdkBuilder) -> SdkBuilder {
    let observer = ExamplePaymentObserver {};
    builder.with_payment_observer(Arc::new(observer))
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
class ExamplePaymentObserver: PaymentObserver {
    func beforeSend(payments: [ProvisionalPayment]) async {
        for payment in payments {
            print("About to send payment: \(payment.paymentId) of amount \(payment.amount)")
        }
    }
}

func withPaymentObserver(builder: SdkBuilder) async {
    let paymentObserver = ExamplePaymentObserver()
    await builder.withPaymentObserver(paymentObserver: paymentObserver)
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
class ExamplePaymentObserver : PaymentObserver {
    override suspend fun beforeSend(payments: List<ProvisionalPayment>) {
        for (payment in payments) {
            // Log.v("PaymentObserver", "About to send payment: ${payment.paymentId} of amount ${payment.amount}")
        }
    }
}

suspend fun withPaymentObserver(builder: SdkBuilder) {
    val paymentObserver = ExamplePaymentObserver()
    builder.withPaymentObserver(paymentObserver)
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
class ExamplePaymentObserver : PaymentObserver
{
    public async Task BeforeSend(List<ProvisionalPayment> payments)
    {
        foreach (var payment in payments)
        {
            Console.WriteLine($"About to send payment {payment.paymentId} of amount {payment.amount}");
        }
    }
}

async Task WithPaymentObserver(SdkBuilder builder)
{
    var paymentObserver = new ExamplePaymentObserver();
    await builder.WithPaymentObserver(paymentObserver);
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
class ExamplePaymentObserver {
  beforeSend = async (payments: ProvisionalPayment[]) => {
    for (const payment of payments) {
      console.log(`About to send payment: ${payment.paymentId} of amount ${payment.amount}`)
    }
  }
}

const exampleWithPaymentObserver = (builder: SdkBuilder): SdkBuilder => {
  const paymentObserver = new ExamplePaymentObserver()
  return builder.withPaymentObserver(paymentObserver)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
class ExamplePaymentObserver {
  beforeSend = async (payments: ProvisionalPayment[]) => {
    for (const payment of payments) {
      console.log(`About to send payment: ${payment.paymentId} of amount ${payment.amount}`)
    }
  }
}

const exampleWithPaymentObserver = async (builder: SdkBuilder) => {
  const paymentObserver = new ExamplePaymentObserver()
  await builder.withPaymentObserver(paymentObserver)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore

```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
class ExamplePaymentObserver(PaymentObserver):
    def before_send(self, payments: typing.List[ProvisionalPayment]):
        for payment in payments:
            logging.debug(f"About to send payment {payment.payment_id} of amount {payment.amount}")


async def with_payment_observer(builder: SdkBuilder):
    payment_observer = ExamplePaymentObserver()
    await builder.with_payment_observer(payment_observer=payment_observer)
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
type ExamplePaymentObserver struct{}

func (ExamplePaymentObserver) BeforeSend(payments []breez_sdk_spark.ProvisionalPayment) error {
	for _, payment := range payments {
		log.Printf("About to send payment: %v of amount %v", payment.PaymentId, payment.Amount)
	}
	return nil
}

func WithPaymentObserver(builder *breez_sdk_spark.SdkBuilder) {
	observer := ExamplePaymentObserver{}
	builder.WithPaymentObserver(observer)
}
```

</section>

</custom-tabs>


<h1 id="fetching-the-balance">
    <a class="header" href="#fetching-the-balance">Fetching the balance</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.get_info">API docs</a>
</h1>

Once connected, the balance can be retrieved at any time.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let info = sdk
    .get_info(GetInfoRequest {
        // ensure_synced: true will ensure the SDK is synced with the Spark network
        // before returning the balance
        ensure_synced: Some(false),
    })
    .await?;
let balance_sats = info.balance_sats;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// ensureSynced: true will ensure the SDK is synced with the Spark network
// before returning the balance
let info = try await sdk.getInfo(
    request: GetInfoRequest(
        ensureSynced: false
    ))
let balanceSats = info.balanceSats
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    // ensureSynced: true will ensure the SDK is synced with the Spark network
    // before returning the balance
    val info = sdk.getInfo(GetInfoRequest(false))
    val balanceSats = info.balanceSats
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// ensureSynced: true will ensure the SDK is synced with the Spark network
// before returning the balance
var info = await sdk.GetInfo(request: new GetInfoRequest(ensureSynced: false));
var balanceSats = info.balanceSats;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const info = await sdk.getInfo({
  // ensureSynced: true will ensure the SDK is synced with the Spark network
  // before returning the balance
  ensureSynced: false
})
const balanceSats = info.balanceSats
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// ensureSynced: true will ensure the SDK is synced with the Spark network
// before returning the balance
const info = await sdk.getInfo({
  ensureSynced: false
})
const balanceSats = info.balanceSats
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// ensureSynced: true will ensure the SDK is synced with the Spark network
// before returning the balance
final info = await sdk.getInfo(request: GetInfoRequest(ensureSynced: false));
final balanceSats = info.balanceSats;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    # ensure_synced: True will ensure the SDK is synced with the Spark network
    # before returning the balance
    info = await sdk.get_info(request=GetInfoRequest(ensure_synced=False))
    balance_sats = info.balance_sats
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
ensureSynced := false
info, err := sdk.GetInfo(breez_sdk_spark.GetInfoRequest{
	// EnsureSynced: true will ensure the SDK is synced with the Spark network
	// before returning the balance
	EnsureSynced: &ensureSynced,
})

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

balanceSats := info.BalanceSats
log.Printf("Balance: %v sats", balanceSats)
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>
The SDK maintains a cached balance for fast responses and updates it on every change. The `get_info` call returns the value from this cache to provide a low-latency user experience.

Right after startup, the cache may not yet reflect the latest state from the network. Depends on your use case you can use one of the following options to get the fully up to date balance:

- If your application runs continuously in the background, call `get_info` after each `SdkEvent::Synced` event.
- If you're only briefly using the SDK to fetch the balance, call `get_info` with `ensure_synced = true` before disconnecting.

</div>

# Listening to events

The SDK emits several events to provide the application with an up-to-date state of the SDK or ongoing payments.

<h2 id="add-event-listener">
    <a class="header" href="#add-event-listener">Add event listener</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.add_event_listener">API docs</a>
</h2>

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
pub(crate) struct SdkEventListener {}

#[async_trait::async_trait]
impl EventListener for SdkEventListener {
    async fn on_event(&self, e: SdkEvent) {
        match e {
            SdkEvent::Synced => {
                // Data has been synchronized with the network. When this event is received,
                // it is recommended to refresh the payment list and wallet balance.
            }
            SdkEvent::UnclaimedDeposits { unclaimed_deposits } => {
                // SDK was unable to claim some deposits automatically
            }
            SdkEvent::ClaimedDeposits { claimed_deposits } => {
                // Deposits were successfully claimed
            }
            SdkEvent::PaymentSucceeded { payment } => {
                // A payment completed successfully
            }
            SdkEvent::PaymentPending { payment } => {
                // A payment is pending (waiting for confirmation)
            }
            SdkEvent::PaymentFailed { payment } => {
                // A payment failed
            }
            SdkEvent::Optimization { optimization_event } => {
                // An optimization event occurred
            }
        }
    }
}

pub(crate) async fn add_event_listener(
    sdk: &BreezSdk,
    listener: Box<SdkEventListener>,
) -> Result<String> {
    let listener_id = sdk.add_event_listener(listener).await;
    Ok(listener_id)
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
class SdkEventListener: EventListener {
    func onEvent(event: SdkEvent) async {
        switch event {
        case .synced:
            // Data has been synchronized with the network. When this event is received,
            // it is recommended to refresh the payment list and wallet balance.
            break
        case .unclaimedDeposits(let unclaimedDeposits):
            // SDK was unable to claim some deposits automatically
            let _ = unclaimedDeposits
        case .claimedDeposits(let claimedDeposits):
            // Deposits were successfully claimed
            let _ = claimedDeposits
        case .paymentSucceeded(let paymentSucceeded):
            // A payment completed successfully
            let _ = paymentSucceeded
        case .paymentPending(let paymentPending):
            // A payment is pending (waiting for confirmation)
            let _ = paymentPending
        case .paymentFailed(let paymentFailed):
            // A payment failed
            let _ = paymentFailed
        case .optimization(let optimizationEvent):
            // An optimization event occurred
            let _ = optimizationEvent
        default:
            // Handle any future event types
            break
        }
    }
}

func addEventListener(sdk: BreezSdk, listener: SdkEventListener) async -> String {
    let listenerId = await sdk.addEventListener(listener: listener)
    return listenerId
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
class SdkListener : EventListener {
    override suspend fun onEvent(e: SdkEvent) {
        when (e) {
            is SdkEvent.Synced -> {
                // Data has been synchronized with the network. When this event is received,
                // it is recommended to refresh the payment list and wallet balance.
            }
            is SdkEvent.UnclaimedDeposits -> {
                // SDK was unable to claim some deposits automatically
                val unclaimedDeposits = e.unclaimedDeposits
            }
            is SdkEvent.ClaimedDeposits -> {
                // Deposits were successfully claimed
                val claimedDeposits = e.claimedDeposits
            }
            is SdkEvent.PaymentSucceeded -> {
                // A payment completed successfully
                val payment = e.payment
            }
            is SdkEvent.PaymentPending -> {
                // A payment is pending (waiting for confirmation)
                val pendingPayment = e.payment
            }
            is SdkEvent.PaymentFailed -> {
                // A payment failed
                val failedPayment = e.payment
            }
            is SdkEvent.Optimization -> {
                // An optimization event occurred
                val optimizationEvent = e.optimizationEvent
            }
            else -> {
                // Handle any future event types
            }
        }
    }
}

suspend fun addEventListener(sdk: BreezSdk, listener: SdkListener): String? {
    try {
        val listenerId = sdk.addEventListener(listener)
        return listenerId
    } catch (e: Exception) {
        // handle error
        return null
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
class SdkListener : EventListener
{
    public async Task OnEvent(SdkEvent sdkEvent)
    {
        switch (sdkEvent)
        {
            case SdkEvent.Synced syncedEvent:
                // Data has been synchronized with the network. When this event is received,
                // it is recommended to refresh the payment list and wallet balance.
                break;

            case SdkEvent.UnclaimedDeposits unclaimedDepositsEvent:
                // SDK was unable to claim some deposits automatically
                var unclaimedDeposits = unclaimedDepositsEvent.unclaimedDeposits;
                break;

            case SdkEvent.ClaimedDeposits claimedDepositsEvent:
                // Deposits were successfully claimed
                var claimedDeposits = claimedDepositsEvent.claimedDeposits;
                break;

            case SdkEvent.PaymentSucceeded paymentSucceededEvent:
                // A payment completed successfully
                var payment = paymentSucceededEvent.payment;
                break;

            case SdkEvent.PaymentPending paymentPendingEvent:
                // A payment is pending (waiting for confirmation)
                var pendingPayment = paymentPendingEvent.payment;
                break;

            case SdkEvent.PaymentFailed paymentFailedEvent:
                // A payment failed
                var failedPayment = paymentFailedEvent.payment;
                break;

            case SdkEvent.Optimization optimizationEvent:
                // An optimization event occurred
                var optimization = optimizationEvent.optimizationEvent;
                break;

            default:
                // Handle any future event types
                break;
        }
    }
}

async Task<string> AddEventListener(BreezSdk sdk, SdkListener listener)
{
    var listenerId = await sdk.AddEventListener(listener: listener);
    return listenerId;
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
class JsEventListener {
  onEvent = async (event: SdkEvent) => {
    switch (event.type) {
      case 'synced': {
        // Data has been synchronized with the network. When this event is received,
        // it is recommended to refresh the payment list and wallet balance.
        break
      }
      case 'unclaimedDeposits': {
        // SDK was unable to claim some deposits automatically
        const unclaimedDeposits = event.unclaimedDeposits
        break
      }
      case 'claimedDeposits': {
        // Deposits were successfully claimed
        const claimedDeposits = event.claimedDeposits
        break
      }
      case 'paymentSucceeded': {
        // A payment completed successfully
        const payment = event.payment
        break
      }
      case 'paymentPending': {
        // A payment is pending (waiting for confirmation)
        const pendingPayment = event.payment
        break
      }
      case 'paymentFailed': {
        // A payment failed
        const failedPayment = event.payment
        break
      }
      case 'optimization': {
        // An optimization event occurred
        const optimizationEvent = event.optimizationEvent
        break
      }
      default: {
        // Handle any future event types
        break
      }
    }
  }
}

const eventListener = new JsEventListener()

const listenerId = await sdk.addEventListener(eventListener)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
class JsEventListener {
  onEvent = async (event: SdkEvent) => {
    if (event.tag === SdkEvent_Tags.Synced) {
      // Data has been synchronized with the network. When this event is received,
      // it is recommended to refresh the payment list and wallet balance.
    } else if (event.tag === SdkEvent_Tags.UnclaimedDeposits) {
      // SDK was unable to claim some deposits automatically
      const unclaimedDeposits = event.inner.unclaimedDeposits
    } else if (event.tag === SdkEvent_Tags.ClaimedDeposits) {
      // Deposits were successfully claimed
      const claimedDeposits = event.inner.claimedDeposits
    } else if (event.tag === SdkEvent_Tags.PaymentSucceeded) {
      // A payment completed successfully
      const payment = event.inner.payment
    } else if (event.tag === SdkEvent_Tags.PaymentPending) {
      // A payment is pending (waiting for confirmation)
      const pendingPayment = event.inner.payment
    } else if (event.tag === SdkEvent_Tags.PaymentFailed) {
      // A payment failed
      const failedPayment = event.inner.payment
    } else if (event.tag === SdkEvent_Tags.Optimization) {
      // An optimization event occurred
      const optimizationEvent = event.inner.optimizationEvent
    } else {
      // Handle any future event types
    }
  }
}

const eventListener = new JsEventListener()

const listenerId = await sdk.addEventListener(eventListener)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
StreamSubscription<SdkEvent>? _eventSubscription;
Stream<SdkEvent>? _eventStream;

// Initializes SDK event stream.
//
// Call once on your Dart entrypoint file, e.g.; `lib/main.dart`
// or singleton SDK service. It is recommended to use a single instance
// of the SDK across your Flutter app.
void initializeEventsStream(BreezSdk sdk) {
  _eventStream ??= sdk.addEventListener().asBroadcastStream();
}

final _eventStreamController = StreamController<SdkEvent>.broadcast();
Stream<SdkEvent> get eventStream => _eventStreamController.stream;

// Subscribe to the event stream
void subscribeToEventStream() {
  _eventSubscription = _eventStream?.listen((sdkEvent) {
    switch (sdkEvent) {
      case SdkEvent_Synced():
        // Data has been synchronized with the network. When this event is received,
        // it is recommended to refresh the payment list and wallet balance.
        break;
      case SdkEvent_UnclaimedDeposits(:final unclaimedDeposits):
        // SDK was unable to claim some deposits automatically
        final _ = unclaimedDeposits;
        break;
      case SdkEvent_ClaimedDeposits(:final claimedDeposits):
        // Deposits were successfully claimed
        final _ = claimedDeposits;
        break;
      case SdkEvent_PaymentSucceeded(:final payment):
        // A payment completed successfully
        final _ = payment;
        break;
      case SdkEvent_PaymentPending(:final payment):
        // A payment is pending (waiting for confirmation)
        final _ = payment;
        break;
      case SdkEvent_PaymentFailed(:final payment):
        // A payment failed
        final _ = payment;
        break;
      case SdkEvent_Optimization(:final optimizationEvent):
        // An optimization event occurred
        final _ = optimizationEvent;
        break;
    }
    _eventStreamController.add(sdkEvent);
  }, onError: (e) {
    _eventStreamController.addError(e);
  });
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
class SdkListener(EventListener):
    def on_event(self, event: SdkEvent):
        if isinstance(event, SdkEvent.SYNCED):
            # Data has been synchronized with the network. When this event is received,
            # it is recommended to refresh the payment list and wallet balance.
            pass
        elif isinstance(event, SdkEvent.UNCLAIMED_DEPOSITS):
            # SDK was unable to claim some deposits automatically
            unclaimed_deposits = event.unclaimed_deposits
        elif isinstance(event, SdkEvent.CLAIMED_DEPOSITS):
            # Deposits were successfully claimed
            claimed_deposits = event.claimed_deposits
        elif isinstance(event, SdkEvent.PAYMENT_SUCCEEDED):
            # A payment completed successfully
            payment = event.payment
        elif isinstance(event, SdkEvent.PAYMENT_PENDING):
            # A payment is pending (waiting for confirmation)
            pending_payment = event.payment
        elif isinstance(event, SdkEvent.PAYMENT_FAILED):
            # A payment failed
            failed_payment = event.payment
        elif isinstance(event, SdkEvent.OPTIMIZATION):
            # An optimization event occurred
            optimization_event = event.optimization_event
        else:
            # Handle any future event types
            pass


async def add_event_listener(sdk: BreezSdk, listener: SdkListener):
    try:
        listener_id = await sdk.add_event_listener(listener=listener)
        return listener_id
    except Exception as error:
        logging.error(error)
        raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
type SdkListener struct{}

func (SdkListener) OnEvent(e breez_sdk_spark.SdkEvent) {
	switch event := e.(type) {
	case breez_sdk_spark.SdkEventSynced:
		// Data has been synchronized with the network. When this event is received,
		// it is recommended to refresh the payment list and wallet balance.
	case breez_sdk_spark.SdkEventUnclaimedDeposits:
		// SDK was unable to claim some deposits automatically
		unclaimedDeposits := event.UnclaimedDeposits
		_ = unclaimedDeposits
	case breez_sdk_spark.SdkEventClaimedDeposits:
		// Deposits were successfully claimed
		claimedDeposits := event.ClaimedDeposits
		_ = claimedDeposits
	case breez_sdk_spark.SdkEventPaymentSucceeded:
		// A payment completed successfully
		payment := event.Payment
		_ = payment
	case breez_sdk_spark.SdkEventPaymentPending:
		// A payment is pending (waiting for confirmation)
		pendingPayment := event.Payment
		_ = pendingPayment
	case breez_sdk_spark.SdkEventPaymentFailed:
		// A payment failed
		failedPayment := event.Payment
		_ = failedPayment
	case breez_sdk_spark.SdkEventOptimization:
		// An optimization event occurred
		optimizationEvent := event.OptimizationEvent
		_ = optimizationEvent
	default:
		// Handle any future event types
	}
}

func AddEventListener(sdk *breez_sdk_spark.BreezSdk, listener SdkListener) string {
	return sdk.AddEventListener(listener)
}
```

</section>

</custom-tabs>


<h2 id="remove-event-listener">
    <a class="header" href="#remove-event-listener">Remove event listener</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.remove_event_listener">API docs</a>
</h2>

When you no longer need to listen to events, you can remove the listener.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
pub(crate) async fn remove_event_listener(sdk: &BreezSdk, listener_id: &str) -> Result<()> {
    sdk.remove_event_listener(listener_id).await;
    Ok(())
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
func removeEventListener(sdk: BreezSdk, listenerId: String) async {
    await sdk.removeEventListener(id: listenerId)
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
suspend fun removeEventListener(sdk: BreezSdk, listenerId: String)  {
    try {
        sdk.removeEventListener(listenerId)
    } catch (e: Exception) {
        // handle error
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
async Task RemoveEventListener(BreezSdk sdk, string listenerId)
{
    await sdk.RemoveEventListener(id: listenerId);
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
await sdk.removeEventListener(listenerId)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
await sdk.removeEventListener(listenerId)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
void unsubscribeFromEventStream() {
  _eventSubscription?.cancel();
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
async def remove_event_listener(sdk: BreezSdk, listener_id: str):
    try:
        await sdk.remove_event_listener(id=listener_id)
    except Exception as error:
        logging.error(error)
        raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
func RemoveEventListener(sdk *breez_sdk_spark.BreezSdk, listenerId string) bool {
	return sdk.RemoveEventListener(listenerId)
}
```

</section>

</custom-tabs>


<h1 id="adding-logging">
    <a class="header" href="#adding-logging">Adding logging</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/fn.init_logging.html">API docs</a>
</h1>

The SDK implements detailed logging via a streaming interface you can manage within your application. The log entries are split into several levels that you can filter and store as desired within your application, for example, by appending them to a log file.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let data_dir_path = PathBuf::from(&data_dir);
fs::create_dir_all(data_dir_path)?;

init_logging(Some(data_dir), None, None)?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
class SdkLogger: Logger {
    func log(l: LogEntry) {
        print("Received log [", l.level, "]: ", l.line)
    }
}

func logging() throws {
    try initLogging(logDir: nil, appLogger: SdkLogger(), logFilter: nil)
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
class SdkLogger : Logger {
    override fun log(l: LogEntry) {
        // Log.v("SDKListener", "Received log [${l.level}]: ${l.line}")
    }
}

fun setLogger(logger: SdkLogger) {
    try {
        initLogging(null, logger, null)
    } catch (e: Exception) {
        // handle error
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
class SdkLogger : Logger
{
    public void Log(LogEntry l)
    {
        Console.WriteLine($"Received log [{l.level}]: {l.line}");
    }
}

void SetLogger(SdkLogger logger)
{
    BreezSdkSparkMethods.InitLogging(logDir: null, appLogger: logger, logFilter: null);
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
class JsLogger {
  log = (l: LogEntry) => {
    console.log(`[${l.level}]: ${l.line}`)
  }
}

const logger = new JsLogger()
await initLogging(logger)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
class JsLogger {
  log = (l: LogEntry) => {
    console.log(`[${l.level}]: ${l.line}`)
  }
}

const logger = new JsLogger()
initLogging(undefined, logger, undefined)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
StreamSubscription<LogEntry>? _logSubscription;
Stream<LogEntry>? _logStream;

// Initializes SDK log stream.
//
// Call once on your Dart entrypoint file, e.g.; `lib/main.dart`
// or singleton SDK service. It is recommended to use a single instance
// of the SDK across your Flutter app.
void initializeLogStream() {
  _logStream ??= initLogging().asBroadcastStream();
}

final _logStreamController = StreamController<LogEntry>.broadcast();
Stream<LogEntry> get logStream => _logStreamController.stream;

// Subscribe to the log stream
void subscribeToLogStream() {
  _logSubscription = _logStream?.listen((logEntry) {
    _logStreamController.add(logEntry);
  }, onError: (e) {
    _logStreamController.addError(e);
  });
}

// Unsubscribe from the log stream
void unsubscribeFromLogStream() {
  _logSubscription?.cancel();
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
class SdkLogger(Logger):
    def log(self, l: LogEntry):
        logging.debug(f"Received log [{l.level}]: {l.line}")


def set_logger(logger: SdkLogger):
    try:
        init_logging(log_dir=None, app_logger=logger, log_filter=None)
    except Exception as error:
        logging.error(error)
        raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
type SdkLogger struct{}

func (SdkLogger) Log(l breez_sdk_spark.LogEntry) {
	log.Printf("Received log [%v]: %v", l.Level, l.Line)
}

func SetLogger() {
	var loggerImpl breez_sdk_spark.Logger = SdkLogger{}
	breez_sdk_spark.InitLogging(nil, &loggerImpl, nil)
}
```

</section>

</custom-tabs>


# Payment fundamentals

How to send, receive and manage payments using the Breez SDK - Nodeless *(Spark Implementation)*:

- **[Parsing inputs]** to determine the payment type
- **[Receiving payments]** via a Lightning invoice, Bitcoin address or Spark address
- **[Sending payments]** via a Lightning invoice, Bitcoin address or Spark address
- **[Listing payments]** that have been sent or received in the past
- **[Claiming on-chain deposits]** to manually claim or refund Bitcoin payments

[Parsing inputs]: parse.md
[Receiving payments]: receive_payment.md
[Sending payments]: send_payment.md
[Listing payments]: list_payments.md
[Claiming on-chain deposits]: onchain_claims.md

## Further reading

- **[Using LNURL and Lightning addresses](lnurl.md)**
- **[Handling tokens](tokens.md)**

# Parsing inputs

The SDK provides a versatile and extensible parsing module designed to process a wide range of input strings and return parsed data in various standardized formats.

Natively supported formats include: BOLT11 invoices, LNURLs of different types, Bitcoin addresses, Spark addresses, and others. For the complete list, consult the [API documentation](https://breez.github.io/spark-sdk/breez_sdk_spark/enum.InputType.html).

<div class="warning">
<h4>Developer note</h4>
The amounts returned from calling parse on Lightning based inputs (BOLT11, LNURL) are denominated in millisatoshi.
</div>

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let input = "an input to be parsed...";

match sdk.parse(input).await? {
    InputType::BitcoinAddress(details) => {
        println!("Input is Bitcoin address {}", details.address);
    }
    InputType::Bolt11Invoice(details) => {
        println!(
            "Input is BOLT11 invoice for {} msats",
            details
                .amount_msat
                .map_or("unknown".to_string(), |a| a.to_string())
        );
    }
    InputType::LnurlPay(details) => {
        println!(
            "Input is LNURL-Pay/Lightning address accepting min/max {}/{} msats",
            details.min_sendable, details.max_sendable
        );
    }
    InputType::LnurlWithdraw(details) => {
        println!(
            "Input is LNURL-Withdraw for min/max {}/{} msats",
            details.min_withdrawable, details.max_withdrawable
        );
    }
    InputType::SparkAddress(details) => {
        println!("Input is Spark address {}", details.address);
    }
    InputType::SparkInvoice(invoice) => {
        println!("Input is Spark invoice:");
        if let Some(token_identifier) = &invoice.token_identifier {
            println!(
                "  Amount: {:?} base units of token with id {}",
                invoice.amount, token_identifier
            );
        } else {
            println!("  Amount: {:?} sats", invoice.amount);
        }

        if let Some(description) = &invoice.description {
            println!("  Description: {}", description);
        }

        if let Some(expiry_time) = invoice.expiry_time {
            println!("  Expiry time: {}", expiry_time);
        }

        if let Some(sender_public_key) = &invoice.sender_public_key {
            println!("  Sender public key: {}", sender_public_key);
        }
    }
    // Other input types are available
    _ => {}
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let input = "an input to be parsed..."

do {
    let inputType = try await sdk.parse(input: input)
    switch inputType {
    case .bitcoinAddress(v1: let details):
        print("Input is Bitcoin address \(details.address)")

    case .bolt11Invoice(v1: let details):
        let amount = details.amountMsat.map { String($0) } ?? "unknown"
        print("Input is BOLT11 invoice for \(amount) msats")

    case .lnurlPay(v1: let details):
        print(
            "Input is LNURL-Pay/Lightning address accepting min/max \(details.minSendable)/\(details.maxSendable) msats)"
        )
    case .lnurlWithdraw(v1: let details):
        print(
            "Input is LNURL-Withdraw for min/max \(details.minWithdrawable)/\(details.maxWithdrawable) msats"
        )

    case .sparkAddress(v1: let details):
        print("Input is Spark address \(details.address)")

    case .sparkInvoice(v1: let invoice):
        print("Input is Spark invoice:")
        if let tokenIdentifier = invoice.tokenIdentifier {
            print("  Amount: \(invoice.amount) base units of token with id \(tokenIdentifier)")
        } else {
            print("  Amount: \(invoice.amount) sats")
        }

        if let description = invoice.description {
            print("  Description: \(description)")
        }

        if let expiryTime = invoice.expiryTime {
            print("  Expiry time: \(Date(timeIntervalSince1970: TimeInterval(expiryTime)))")
        }

        if let senderPublicKey = invoice.senderPublicKey {
            print("  Sender public key: \(senderPublicKey)")
        }

    default:
        break  // Other input types are available
    }
} catch {
    print("Failed to parse input: \(error)")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val input = "an input to be parsed..."

try {
    val inputType = sdk.parse(input)
    when (inputType) {
        is InputType.BitcoinAddress -> {
            println("Input is Bitcoin address ${inputType.v1.address}")
        }
        is InputType.Bolt11Invoice -> {
            val amountStr = inputType.v1.amountMsat?.toString() ?: "unknown"
            println("Input is BOLT11 invoice for $amountStr msats")
        }
        is InputType.LnurlPay -> {
            println(
                    "Input is LNURL-Pay/Lightning address accepting min/max " +
                            "${inputType.v1.minSendable}/${inputType.v1.maxSendable} msats}"
            )
        }
        is InputType.LnurlWithdraw -> {
            println(
                    "Input is LNURL-Withdraw for min/max " +
                            "${inputType.v1.minWithdrawable}/${inputType.v1.maxWithdrawable} msats"
            )
        }
        is InputType.SparkAddress -> {
            println("Input is Spark address ${inputType.v1.address}")
        }
        is InputType.SparkInvoice -> {
            val invoice = inputType.v1
            println("Input is Spark invoice:")
            if (invoice.tokenIdentifier != null) {
                println(
                        "  Amount: ${invoice.amount} base units of token with id ${invoice.tokenIdentifier}"
                )
            } else {
                println("  Amount: ${invoice.amount} sats")
            }

            if (invoice.description != null) {
                println("  Description: ${invoice.description}")
            }

            if (invoice.expiryTime != null) {
                println("  Expiry time: ${invoice.expiryTime}")
            }

            if (invoice.senderPublicKey != null) {
                println("  Sender public key: ${invoice.senderPublicKey}")
            }
        }
        else -> {
            // Handle other input types
        }
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var inputStr = "an input to be parsed...";

var parsedInput = await sdk.Parse(input: inputStr);
switch (parsedInput)
{
    case InputType.BitcoinAddress bitcoinAddress:
        var details = bitcoinAddress.v1;
        Console.WriteLine($"Input is Bitcoin address {details.address}");
        break;

    case InputType.Bolt11Invoice bolt11:
        var bolt11Details = bolt11.v1;
        var amount = bolt11Details.amountMsat.HasValue ? bolt11Details.amountMsat.Value.ToString() : "unknown";
        Console.WriteLine($"Input is BOLT11 invoice for {amount} msats");
        break;

    case InputType.LnurlPay lnurlPay:
        var lnurlPayDetails = lnurlPay.v1;
        Console.WriteLine($"Input is LNURL-Pay/Lightning address accepting " +
                        $"min/max {lnurlPayDetails.minSendable}/{lnurlPayDetails.maxSendable} msats");
        break;

    case InputType.LnurlWithdraw lnurlWithdraw:
        var lnurlWithdrawDetails = lnurlWithdraw.v1;
        Console.WriteLine($"Input is LNURL-Withdraw for min/max " +
                        $"{lnurlWithdrawDetails.minWithdrawable}/{lnurlWithdrawDetails.maxWithdrawable} msats");
        break;

    case InputType.SparkAddress sparkAddress:
        var sparkAddressDetails = sparkAddress.v1;
        Console.WriteLine($"Input is Spark address {sparkAddressDetails.address}");
        break;

    case InputType.SparkInvoice sparkInvoice:
        var invoice = sparkInvoice.v1;
        Console.WriteLine("Input is Spark invoice:");
        if (invoice.tokenIdentifier != null)
        {
            Console.WriteLine($"  Amount: {invoice.amount} base units of " +
                            $"token with id {invoice.tokenIdentifier}");
        }
        else
        {
            Console.WriteLine($"  Amount: {invoice.amount} sats");
        }

        if (invoice.description != null)
        {
            Console.WriteLine($"  Description: {invoice.description}");
        }

        if (invoice.expiryTime.HasValue)
        {
            Console.WriteLine($"  Expiry time: {invoice.expiryTime}");
        }

        if (invoice.senderPublicKey != null)
        {
            Console.WriteLine($"  Sender public key: {invoice.senderPublicKey}");
        }
        break;

        // Other input types are available
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const input = 'an input to be parsed...'

const parsed = await sdk.parse(input)

switch (parsed.type) {
  case 'bitcoinAddress':
    console.log(`Input is Bitcoin address ${parsed.address}`)
    break

  case 'bolt11Invoice':
    console.log(
      `Input is BOLT11 invoice for ${
        parsed.amountMsat != null ? parsed.amountMsat.toString() : 'unknown'
      } msats`
    )
    break

  case 'lnurlPay':
    console.log(
      `Input is LNURL-Pay/Lightning address accepting min/max ${parsed.minSendable}/${parsed.maxSendable} msats`
    )
    break

  case 'lnurlWithdraw':
    console.log(
      `Input is LNURL-Withdraw for min/max ${parsed.minWithdrawable}/${parsed.maxWithdrawable} msats`
    )
    break

  case 'sparkAddress':
    console.log(`Input is Spark address ${parsed.address}`)
    break

  case 'sparkInvoice':
    console.log('Input is Spark invoice:')
    if (parsed.tokenIdentifier != null) {
      console.log(
        `  Amount: ${parsed.amount} base units of token with id ${parsed.tokenIdentifier}`
      )
    } else {
      console.log(`  Amount: ${parsed.amount} sats`)
    }

    if (parsed.description != null) {
      console.log(`  Description: ${parsed.description}`)
    }

    if (parsed.expiryTime != null) {
      console.log(`  Expiry time: ${new Date(Number(parsed.expiryTime) * 1000).toISOString()}`)
    }

    if (parsed.senderPublicKey != null) {
      console.log(`  Sender public key: ${parsed.senderPublicKey}`)
    }
    break

  default:
    // Other input types are available
    break
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const inputStr = 'an input to be parsed...'

const input = await sdk.parse(inputStr)

if (input.tag === InputType_Tags.BitcoinAddress) {
  console.log(`Input is Bitcoin address ${input.inner[0].address}`)
} else if (input.tag === InputType_Tags.Bolt11Invoice) {
  console.log(
    `Input is BOLT11 invoice for ${
      input.inner[0].amountMsat != null ? input.inner[0].amountMsat.toString() : 'unknown'
    } msats`
  )
} else if (input.tag === InputType_Tags.LnurlPay) {
  console.log(
    'Input is LNURL-Pay/Lightning address accepting min/max ' +
      `${input.inner[0].minSendable}/${input.inner[0].maxSendable} msats`
  )
} else if (input.tag === InputType_Tags.LnurlWithdraw) {
  console.log(
    'Input is LNURL-Withdraw for min/max ' +
      `${input.inner[0].minWithdrawable}/${input.inner[0].maxWithdrawable} msats`
  )
} else if (input.tag === InputType_Tags.SparkAddress) {
  console.log(`Input is Spark address ${input.inner[0].address}`)
} else if (input.tag === InputType_Tags.SparkInvoice) {
  const invoice = input.inner[0]
  console.log('Input is Spark invoice:')
  if (invoice.tokenIdentifier != null) {
    console.log(
      `  Amount: ${invoice.amount} base units of token with id ${invoice.tokenIdentifier}`
    )
  } else {
    console.log(`  Amount: ${invoice.amount} sats`)
  }

  if (invoice.description != null) {
    console.log(`  Description: ${invoice.description}`)
  }

  if (invoice.expiryTime != null) {
    console.log(`  Expiry time: ${new Date(Number(invoice.expiryTime) * 1000).toISOString()}`)
  }

  if (invoice.senderPublicKey != null) {
    console.log(`  Sender public key: ${invoice.senderPublicKey}`)
  }
} else {
  // Other input types are available
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String input = "an input to be parsed...";

InputType inputType = await sdk.parse(input: input);
if (inputType is InputType_BitcoinAddress) {
  print("Input is Bitcoin address ${inputType.field0.address}");
} else if (inputType is InputType_Bolt11Invoice) {
  String amountStr = inputType.field0.amountMsat != null
      ? inputType.field0.amountMsat.toString()
      : "unknown";
  print("Input is BOLT11 invoice for $amountStr msats");
} else if (inputType is InputType_LnurlPay) {
  print(
      "Input is LNURL-Pay/Lightning address accepting min/max ${inputType.field0.minSendable}/${inputType.field0.maxSendable} msats");
} else if (inputType is InputType_LnurlWithdraw) {
  print(
      "Input is LNURL-Withdraw for min/max ${inputType.field0.minWithdrawable}/${inputType.field0.maxWithdrawable} msats");
} else if (inputType is InputType_SparkAddress) {
  print("Input is Spark address ${inputType.field0.address}");
} else if (inputType is InputType_SparkInvoice) {
  var invoice = inputType.field0;
  print("Input is Spark invoice:");
  if (invoice.tokenIdentifier != null) {
    print("  Amount: ${invoice.amount} base units of token with id ${invoice.tokenIdentifier}");
  } else {
    print("  Amount: ${invoice.amount} sats");
  }

  if (invoice.description != null) {
    print("  Description: ${invoice.description}");
  }

  if (invoice.expiryTime != null) {
    print("  Expiry time: ${DateTime.fromMillisecondsSinceEpoch(invoice.expiryTime!.toInt() * 1000)}");
  }

  if (invoice.senderPublicKey != null) {
    print("  Sender public key: ${invoice.senderPublicKey}");
  }
} else {
  // Other input types are available
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
input_str = "an input to be parsed..."

try:
    parsed_input = await sdk.parse(input=input_str)
    if isinstance(parsed_input, InputType.BITCOIN_ADDRESS):
        details = parsed_input[0]
        logging.debug(f"Input is Bitcoin address {details.address}")
    elif isinstance(parsed_input, InputType.BOLT11_INVOICE):
        details = parsed_input[0]
        amount = "unknown"
        if details.amount_msat:
            amount = str(details.amount_msat)
        logging.debug(f"Input is BOLT11 invoice for {amount} msats")
    elif isinstance(parsed_input, InputType.LNURL_PAY):
        details = parsed_input[0]
        logging.debug(
            f"Input is LNURL-Pay/Lightning address accepting "
            f"min/max {details.min_sendable}/{details.max_sendable} msats"
        )
    elif isinstance(parsed_input, InputType.LNURL_WITHDRAW):
        details = parsed_input[0]
        logging.debug(
            f"Input is LNURL-Withdraw for min/max "
            f"{details.min_withdrawable}/{details.max_withdrawable} msats"
        )
    elif isinstance(parsed_input, InputType.SPARK_ADDRESS):
        details = parsed_input[0]
        logging.debug(f"Input is Spark address {details.address}")
    elif isinstance(parsed_input, InputType.SPARK_INVOICE):
        invoice = parsed_input[0]
        logging.debug("Input is Spark invoice:")
        if invoice.token_identifier:
            logging.debug(f"  Amount: {invoice.amount} base units of "
            f"token with id {invoice.token_identifier}")
        else:
            logging.debug(f"  Amount: {invoice.amount} sats")

        if invoice.description:
            logging.debug(f"  Description: {invoice.description}")

        if invoice.expiry_time:
            logging.debug(f"  Expiry time: {invoice.expiry_time}")

        if invoice.sender_public_key:
            logging.debug(f"  Sender public key: {invoice.sender_public_key}")
    # Other input types are available
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
inputStr := "an input to be parsed..."

input, err := sdk.Parse(inputStr)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

switch inputType := input.(type) {
case breez_sdk_spark.InputTypeBitcoinAddress:
	log.Printf("Input is Bitcoin address %s", inputType.Field0.Address)

case breez_sdk_spark.InputTypeBolt11Invoice:
	amount := "unknown"
	if inputType.Field0.AmountMsat != nil {
		amount = strconv.FormatUint(*inputType.Field0.AmountMsat, 10)
	}
	log.Printf("Input is BOLT11 invoice for %s msats", amount)

case breez_sdk_spark.InputTypeLnurlPay:
	log.Printf("Input is LNURL-Pay/Lightning address accepting min/max %d/%d msats",
		inputType.Field0.MinSendable, inputType.Field0.MaxSendable)

case breez_sdk_spark.InputTypeLnurlWithdraw:
	log.Printf("Input is LNURL-Withdraw for min/max %d/%d msats",
		inputType.Field0.MinWithdrawable, inputType.Field0.MaxWithdrawable)

case breez_sdk_spark.InputTypeSparkAddress:
	log.Printf("Input is Spark address %s", inputType.Field0.Address)

case breez_sdk_spark.InputTypeSparkInvoice:
	invoice := inputType.Field0
	log.Println("Input is Spark invoice:")
	if invoice.TokenIdentifier != nil {
		log.Printf("  Amount: %d base units of token with id %s", invoice.Amount, *invoice.TokenIdentifier)
	} else {
		log.Printf("  Amount: %d sats", invoice.Amount)
	}

	if invoice.Description != nil {
		log.Printf("  Description: %s", *invoice.Description)
	}

	if invoice.ExpiryTime != nil {
		log.Printf("  Expiry time: %d", *invoice.ExpiryTime)
	}

	if invoice.SenderPublicKey != nil {
		log.Printf("  Sender public key: %s", *invoice.SenderPublicKey)
	}

default:
	// Other input types are available
}
```

</section>

</custom-tabs>


## Supporting other input formats

The parsing module can be extended using external input parsers provided in the SDK configuration. These will be used when the input is not recognized.

You can implement and provide your own parsers, or use existing public ones.

### Configuring external parsers

Configuring external parsers can only be done before [initializing](initializing.md#basic-initialization) and the config cannot be changed through the lifetime of the connection.

Multiple parsers can be configured, and each one is defined by:

- **Provider ID**: an arbitrary id to identify the provider input type
- **Input regex**: a regex pattern that should reliably match all inputs that this parser can process, even if it may also match some invalid inputs
- **Parser URL**: an URL containing the placeholder `<input>`

When parsing an input that isn't recognized as one of the native input types, the SDK will check if the input conforms to any of the external parsers regex expressions. If so, it will make an HTTP `GET` request to the provided URL, replacing the placeholder with the input. If the input is recognized, the response should include in its body a string that can be parsed into one of the natively supported types.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Create the default config
let mut config = default_config(Network::Mainnet);
config.api_key = Some("<breez api key>".to_string());

// Configure external parsers
config.external_input_parsers = Some(vec![
    ExternalInputParser {
        provider_id: "provider_a".to_string(),
        input_regex: "^provider_a".to_string(),
        parser_url: "https://parser-domain.com/parser?input=<input>".to_string(),
    },
    ExternalInputParser {
        provider_id: "provider_b".to_string(),
        input_regex: "^provider_b".to_string(),
        parser_url: "https://parser-domain.com/parser?input=<input>".to_string(),
    },
]);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Create the default config
var config = defaultConfig(network: Network.mainnet)
config.apiKey = "<breez api key>"

// Configure external parsers
config.externalInputParsers = [
    ExternalInputParser(
        providerId: "provider_a",
        inputRegex: "^provider_a",
        parserUrl: "https://parser-domain.com/parser?input=<input>"
    ),
    ExternalInputParser(
        providerId: "provider_b",
        inputRegex: "^provider_b",
        parserUrl: "https://parser-domain.com/parser?input=<input>"
    ),
]
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Create the default config
val config = defaultConfig(Network.MAINNET)
config.apiKey = "<breez api key>"

// Configure external parsers
config.externalInputParsers = listOf(
    ExternalInputParser(
        providerId = "provider_a",
        inputRegex = "^provider_a",
        parserUrl = "https://parser-domain.com/parser?input=<input>"
    ),
    ExternalInputParser(
        providerId = "provider_b",
        inputRegex = "^provider_b",
        parserUrl = "https://parser-domain.com/parser?input=<input>"
    )
)
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Create the default config
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    apiKey = "<breez api key>",
    externalInputParsers = new List<ExternalInputParser>
    {
    new ExternalInputParser(
        providerId: "provider_a",
        inputRegex: "^provider_a",
        parserUrl: "https://parser-domain.com/parser?input=<input>"
    ),
    new ExternalInputParser(
        providerId: "provider_b",
        inputRegex: "^provider_b",
        parserUrl: "https://parser-domain.com/parser?input=<input>"
    )
    }
};
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Create the default config
const config = defaultConfig('mainnet')
config.apiKey = '<breez api key>'

// Configure external parsers
config.externalInputParsers = [
  {
    providerId: 'provider_a',
    inputRegex: '^provider_a',
    parserUrl: 'https://parser-domain.com/parser?input=<input>'
  },
  {
    providerId: 'provider_b',
    inputRegex: '^provider_b',
    parserUrl: 'https://parser-domain.com/parser?input=<input>'
  }
]
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Create the default config
const config = defaultConfig(Network.Mainnet)
config.apiKey = '<breez api key>'

// Configure external parsers
config.externalInputParsers = [
  {
    providerId: 'provider_a',
    inputRegex: '^provider_a',
    parserUrl: 'https://parser-domain.com/parser?input=<input>'
  },
  {
    providerId: 'provider_b',
    inputRegex: '^provider_b',
    parserUrl: 'https://parser-domain.com/parser?input=<input>'
  }
]
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Create the default config
Config config = defaultConfig(network: Network.mainnet)
    .copyWith(apiKey: "<breez api key>");

config = config.copyWith(
  externalInputParsers: [
    ExternalInputParser(
      providerId: "provider_a",
      inputRegex: "^provider_a",
      parserUrl: "https://parser-domain.com/parser?input=<input>",
    ),
    ExternalInputParser(
      providerId: "provider_b",
      inputRegex: "^provider_b",
      parserUrl: "https://parser-domain.com/parser?input=<input>",
    ),
  ],
);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Create the default config
config = default_config(network=Network.MAINNET)
config.api_key = "<breez api key>"

# Configure external parsers
config.external_input_parsers = [
    ExternalInputParser(
        provider_id="provider_a",
        input_regex="^provider_a",
        parser_url="https://parser-domain.com/parser?input=<input>"
    ),
    ExternalInputParser(
        provider_id="provider_b",
        input_regex="^provider_b",
        parser_url="https://parser-domain.com/parser?input=<input>"
    )
]
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Create the default config
apiKey := "<breez api key>"
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
config.ApiKey = &apiKey

// Configure external parsers
parsers := []breez_sdk_spark.ExternalInputParser{
	{
		ProviderId: "provider_a",
		InputRegex: "^provider_a",
		ParserUrl:  "https://parser-domain.com/parser?input=<input>",
	},
	{
		ProviderId: "provider_b",
		InputRegex: "^provider_b",
		ParserUrl:  "https://parser-domain.com/parser?input=<input>",
	},
}
config.ExternalInputParsers = &parsers
```

</section>

</custom-tabs>


### Public external parsers

- [**PicknPay QRs**](https://www.pnp.co.za/)
  - Maintainer: [MoneyBadger](https://www.moneybadger.co.za/)
  - Regex: `(.*)(za.co.electrum.picknpay)(.*)`
  - URL: `https://cryptoqr.net/.well-known/lnurlp/<input>`
  - More info: [support+breezsdk@moneybadger.co.za](mailto:support+breezsdk@moneybadger.co.za)
- [**Bootlegger QRs**](https://www.bootlegger.coffee/)
  - Maintainer: [MoneyBadger](https://www.moneybadger.co.za/)
  - Regex: `(.*)(wigroup\.co|yoyogroup\.co)(.*)`
  - URL: `https://cryptoqr.net/.well-known/lnurlw/<input>`
  - More info: [support+breezsdk@moneybadger.co.za](mailto:support+breezsdk@moneybadger.co.za)

### Default external parsers

The SDK ships with some embedded default external parsers. If you prefer not to use them, you can disable them in the SDK's configuration. See the available default parsers in the [API Documentation](https://breez.github.io/spark-sdk/breez_sdk_spark/constant.DEFAULT_EXTERNAL_INPUT_PARSERS.html) by checking the source of the constant.

<h1 id="receiving-payments">
    <a class="header" href="#receiving-payments">Receiving payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.receive_payment">API docs</a>
</h1>

Once the SDK is initialized, you can directly begin receiving payments. The SDK currently supports three methods of receiving: Lightning, Bitcoin and Spark.

## Lightning

#### BOLT11 invoice

When receiving via Lightning, we can generate a BOLT11 invoice to be paid. Setting the invoice amount fixes the amount the sender should pay.

**Note:** the payment may fallback to a direct Spark payment (if the payer's client supports this).

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let description = "<invoice description>".to_string();
// Optionally set the invoice amount you wish the payer to send
let optional_amount_sats = Some(5_000);
// Optionally set the expiry duration in seconds
let optional_expiry_secs = Some(3600_u32);

let response = sdk
    .receive_payment(ReceivePaymentRequest {
        payment_method: ReceivePaymentMethod::Bolt11Invoice {
            description,
            amount_sats: optional_amount_sats,
            expiry_secs: optional_expiry_secs,
        },
    })
    .await?;

let payment_request = response.payment_request;
info!("Payment request: {payment_request}");
let receive_fee_sats = response.fee;
info!("Fees: {receive_fee_sats} sats");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let description = "<invoice description>"
// Optionally set the invoice amount you wish the payer to send
let optionalAmountSats: UInt64 = 5_000
// Optionally set the expiry duration in seconds
let optionalExpirySecs: UInt32 = 3600
let response =
    try await sdk
    .receivePayment(
        request: ReceivePaymentRequest(
            paymentMethod: ReceivePaymentMethod.bolt11Invoice(
                description: description,
                amountSats: optionalAmountSats,
                expirySecs: optionalExpirySecs
            )
        ))

let paymentRequest = response.paymentRequest
print("Payment Request: {}", paymentRequest)
let receiveFeeSats = response.fee
print("Fees: {} sats", receiveFeeSats)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val description = "<invoice description>"
    // Optionally set the invoice amount you wish the payer to send
    val optionalAmountSats = 5_000.toULong()
    // Optionally set the expiry duration in seconds
    val optionalExpirySecs = 3600.toUInt()

    val request = ReceivePaymentRequest(
        ReceivePaymentMethod.Bolt11Invoice(description, optionalAmountSats, optionalExpirySecs)
    )
    val response = sdk.receivePayment(request)

    val paymentRequest = response.paymentRequest
    // Log.v("Breez", "Payment Request: ${paymentRequest}")
    val receiveFeeSats = response.fee
    // Log.v("Breez", "Fees: ${receiveFeeSats} sats")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var description = "<invoice description>";
// Optionally set the invoice amount you wish the payer to send
var optionalAmountSats = 5_000UL;
// Optionally set the expiry duration in seconds
var optionalExpirySecs = 3600U;
var paymentMethod = new ReceivePaymentMethod.Bolt11Invoice(
    description: description,
    amountSats: optionalAmountSats,
    expirySecs: optionalExpirySecs
);
var request = new ReceivePaymentRequest(paymentMethod: paymentMethod);
var response = await sdk.ReceivePayment(request: request);

var paymentRequest = response.paymentRequest;
Console.WriteLine($"Payment Request: {paymentRequest}");
var receiveFeeSats = response.fee;
Console.WriteLine($"Fees: {receiveFeeSats} sats");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const description = '<invoice description>'
// Optionally set the invoice amount you wish the payer to send
const optionalAmountSats = 5_000
// Optionally set the expiry duration in seconds
const optionalExpirySecs = 3600

const response = await sdk.receivePayment({
  paymentMethod: {
    type: 'bolt11Invoice',
    description,
    amountSats: optionalAmountSats,
    expirySecs: optionalExpirySecs
  }
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const description = '<invoice description>'
// Optionally set the invoice amount you wish the payer to send
const optionalAmountSats = BigInt(5_000)
// Optionally set the expiry duration in seconds
const optionalExpirySecs = 3600

const response = await sdk.receivePayment({
  paymentMethod: new ReceivePaymentMethod.Bolt11Invoice({
    description,
    amountSats: optionalAmountSats,
    expirySecs: optionalExpirySecs
  })
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String description = "<invoice description>";
// Optionally set the invoice amount you wish the payer to send
BigInt optionalAmountSats = BigInt.from(5000);
// Optionally set the expiry duration in seconds
int optionalExpirySecs = 3600;

// Create an invoice and set the amount you wish the payer to send
ReceivePaymentRequest request = ReceivePaymentRequest(
    paymentMethod: ReceivePaymentMethod.bolt11Invoice(
        description: description,
        amountSats: optionalAmountSats,
        expirySecs: optionalExpirySecs));
ReceivePaymentResponse response = await sdk.receivePayment(
  request: request,
);

String paymentRequest = response.paymentRequest;
print("Payment request: $paymentRequest");
BigInt receiveFeeSats = response.fee;
print("Fees: $receiveFeeSats sats");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    description = "<invoice description>"
    # Optionally set the invoice amount you wish the payer to send
    optional_amount_sats = 5_000
    # Optionally set the expiry duration in seconds
    optional_expiry_secs = 3600
    payment_method = ReceivePaymentMethod.BOLT11_INVOICE(
        description=description,
        amount_sats=optional_amount_sats,
        expiry_secs=optional_expiry_secs,
    )
    request = ReceivePaymentRequest(payment_method=payment_method)
    response = await sdk.receive_payment(request=request)

    payment_request = response.payment_request
    logging.debug(f"Payment Request: {payment_request}")
    receive_fee_sats = response.fee
    logging.debug(f"Fees: {receive_fee_sats} sats")
    return response
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
description := "<invoice description>"
// Optionally set the invoice amount you wish the payer to send
optionalAmountSats := uint64(5_000)
// Optionally set the expiry duration in seconds
optionalExpirySecs := uint32(3600)

request := breez_sdk_spark.ReceivePaymentRequest{
	PaymentMethod: breez_sdk_spark.ReceivePaymentMethodBolt11Invoice{
		Description: description,
		AmountSats:  &optionalAmountSats,
		ExpirySecs:  &optionalExpirySecs,
	},
}

response, err := sdk.ReceivePayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

paymentRequest := response.PaymentRequest
log.Printf("Payment Request: %v", paymentRequest)
receiveFeesSat := response.Fee
log.Printf("Fees: %v sats", receiveFeesSat)
```

</section>

</custom-tabs>


#### LNURL-Pay & Lightning address

To receive via LNURL-Pay and/or a Lightning address, follow [these instructions](/guide/receive_lnurl_pay.md).

> Note: Lightning payments work in Spark even if the receiver is offline. To understand how it works under the hood, read [this](https://docs.spark.money/learn/lightning).

## Bitcoin

For on-chain payments you can use the static Bitcoin address to receive payments.

> **Note:** Spark currently requires **3 on-chain confirmations** for Bitcoin transactions before they can be claimed.

The SDK monitors the specified address for new UTXOs and automatically initiates the claim process when funds are detected. If the Config's maximum deposit claim fee is not set or below the current Spark fee to claim the Bitcoin deposit, the deposit will need to be claimed or refunded manually. See [Claiming on-chain deposits](/guide/onchain_claims.md) for more details on this process.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let response = sdk
    .receive_payment(ReceivePaymentRequest {
        payment_method: ReceivePaymentMethod::BitcoinAddress,
    })
    .await?;

let payment_request = response.payment_request;
info!("Payment request: {payment_request}");
let receive_fee_sats = response.fee;
info!("Fees: {receive_fee_sats} sats");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let response =
    try await sdk
    .receivePayment(
        request: ReceivePaymentRequest(
            paymentMethod: ReceivePaymentMethod.bitcoinAddress
        ))

let paymentRequest = response.paymentRequest
print("Payment Request: {}", paymentRequest)
let receiveFeeSats = response.fee
print("Fees: {} sats", receiveFeeSats)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val request = ReceivePaymentRequest(
        ReceivePaymentMethod.BitcoinAddress
    )
    val response = sdk.receivePayment(request)

    val paymentRequest = response.paymentRequest
    // Log.v("Breez", "Payment Request: ${paymentRequest}")
    val receiveFeeSats = response.fee
    // Log.v("Breez", "Fees: ${receiveFeeSats} sats")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var request = new ReceivePaymentRequest(
    paymentMethod: new ReceivePaymentMethod.BitcoinAddress()
);
var response = await sdk.ReceivePayment(request: request);

var paymentRequest = response.paymentRequest;
Console.WriteLine($"Payment Request: {paymentRequest}");
var receiveFeeSats = response.fee;
Console.WriteLine($"Fees: {receiveFeeSats} sats");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.receivePayment({
  paymentMethod: { type: 'bitcoinAddress' }
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const response = await sdk.receivePayment({
  paymentMethod: new ReceivePaymentMethod.BitcoinAddress()
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
ReceivePaymentRequest request = ReceivePaymentRequest(
    paymentMethod: ReceivePaymentMethod.bitcoinAddress());
ReceivePaymentResponse response = await sdk.receivePayment(
  request: request,
);

String paymentRequest = response.paymentRequest;
print("Payment request: $paymentRequest");
BigInt receiveFeeSats = response.fee;
print("Fees: $receiveFeeSats sats");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    request = ReceivePaymentRequest(
        payment_method=ReceivePaymentMethod.BITCOIN_ADDRESS()
    )
    response = await sdk.receive_payment(request=request)

    payment_request = response.payment_request
    logging.debug(f"Payment Request: {payment_request}")
    receive_fee_sats = response.fee
    logging.debug(f"Fees: {receive_fee_sats} sats")
    return response
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.ReceivePaymentRequest{
	PaymentMethod: breez_sdk_spark.ReceivePaymentMethodBitcoinAddress{},
}

response, err := sdk.ReceivePayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

paymentRequest := response.PaymentRequest
log.Printf("Payment Request: %v", paymentRequest)
receiveFeesSat := response.Fee
log.Printf("Fees: %v sats", receiveFeesSat)
```

</section>

</custom-tabs>


## Spark

For payments between Spark users, you can use a Spark address or generate a Spark invoice to receive payments.

#### Spark address

Spark addresses are static.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let response = sdk
    .receive_payment(ReceivePaymentRequest {
        payment_method: ReceivePaymentMethod::SparkAddress,
    })
    .await?;

let payment_request = response.payment_request;
info!("Payment request: {payment_request}");
let receive_fee_sats = response.fee;
info!("Fees: {receive_fee_sats} sats");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let response =
    try await sdk
    .receivePayment(
        request: ReceivePaymentRequest(
            paymentMethod: ReceivePaymentMethod.sparkAddress
        ))

let paymentRequest = response.paymentRequest
print("Payment Request: {}", paymentRequest)
let receiveFeeSats = response.fee
print("Fees: {} sats", receiveFeeSats)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val request = ReceivePaymentRequest(ReceivePaymentMethod.SparkAddress)
    val response = sdk.receivePayment(request)

    val paymentRequest = response.paymentRequest
    // Log.v("Breez", "Payment Request: ${paymentRequest}")
    val receiveFeeSats = response.fee
    // Log.v("Breez", "Fees: ${receiveFeeSats} sats")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var request = new ReceivePaymentRequest(
    paymentMethod: new ReceivePaymentMethod.SparkAddress()
);
var response = await sdk.ReceivePayment(request: request);

var paymentRequest = response.paymentRequest;
Console.WriteLine($"Payment Request: {paymentRequest}");
var receiveFeeSats = response.fee;
Console.WriteLine($"Fees: {receiveFeeSats} sats");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.receivePayment({
  paymentMethod: { type: 'sparkAddress' }
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const response = await sdk.receivePayment({
  paymentMethod: new ReceivePaymentMethod.SparkAddress()
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
ReceivePaymentRequest request =
    ReceivePaymentRequest(paymentMethod: ReceivePaymentMethod.sparkAddress());
ReceivePaymentResponse response = await sdk.receivePayment(
  request: request,
);

String paymentRequest = response.paymentRequest;
print("Payment request: $paymentRequest");
BigInt receiveFeeSats = response.fee;
print("Fees: $receiveFeeSats sats");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    request = ReceivePaymentRequest(
        payment_method=ReceivePaymentMethod.SPARK_ADDRESS()
    )
    response = await sdk.receive_payment(request=request)

    payment_request = response.payment_request
    logging.debug(f"Payment Request: {payment_request}")
    receive_fee_sats = response.fee
    logging.debug(f"Fees: {receive_fee_sats} sats")
    return response
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.ReceivePaymentRequest{
	PaymentMethod: breez_sdk_spark.ReceivePaymentMethodSparkAddress{},
}

response, err := sdk.ReceivePayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

paymentRequest := response.PaymentRequest
log.Printf("Payment Request: %v", paymentRequest)
receiveFeesSat := response.Fee
log.Printf("Fees: %v sats", receiveFeesSat)
```

</section>

</custom-tabs>


#### Spark invoice

Spark invoices are single-use and may impose restrictions on the payment, such as amount, expiry, and who is able to pay it.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let optional_description = "<invoice description>".to_string();
let optional_amount_sats = Some(5_000);
// Optionally set the expiry UNIX timestamp in seconds
let optional_expiry_time_seconds = Some(1716691200);
let optional_sender_public_key = Some("<sender public key>".to_string());

let response = sdk
    .receive_payment(ReceivePaymentRequest {
        payment_method: ReceivePaymentMethod::SparkInvoice {
            token_identifier: None,
            description: Some(optional_description),
            amount: optional_amount_sats,
            expiry_time: optional_expiry_time_seconds,
            sender_public_key: optional_sender_public_key,
        },
    })
    .await?;

let payment_request = response.payment_request;
info!("Payment request: {payment_request}");
let receive_fee_sats = response.fee;
info!("Fees: {receive_fee_sats} sats");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let optionalDescription = "<invoice description>"
let optionalAmountSats = BInt(5_000)
// Optionally set the expiry UNIX timestamp in seconds
let optionalExpiryTimeSeconds: UInt64 = 1_716_691_200
let optionalSenderPublicKey = "<sender public key>"

let response =
    try await sdk
    .receivePayment(
        request: ReceivePaymentRequest(
            paymentMethod: ReceivePaymentMethod.sparkInvoice(
                amount: optionalAmountSats,
                tokenIdentifier: nil,
                expiryTime: optionalExpiryTimeSeconds,
                description: optionalDescription,
                senderPublicKey: optionalSenderPublicKey
            )
        ))

let paymentRequest = response.paymentRequest
print("Payment Request: {}", paymentRequest)
let receiveFeeSats = response.fee
print("Fees: {} sats", receiveFeeSats)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val optionalDescription = "<invoice description>"
    // Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in
    // package)
    val optionalAmountSats = BigInteger.fromLong(5_000L)
    // Android (BigInteger from java.math)
    // val optionalAmountSats = BigInteger.valueOf(5_000L)
    // Optionally set the expiry UNIX timestamp in seconds
    val optionalExpiryTimeSeconds = 1716691200.toULong()
    val optionalSenderPublicKey = "<sender public key>"

    val request = ReceivePaymentRequest(
        ReceivePaymentMethod.SparkInvoice(
            tokenIdentifier = null,
            description = optionalDescription,
            amount = optionalAmountSats,
            expiryTime = optionalExpiryTimeSeconds,
            senderPublicKey = optionalSenderPublicKey
        )
    )
    val response = sdk.receivePayment(request)

    val paymentRequest = response.paymentRequest
    // Log.v("Breez", "Payment Request: ${paymentRequest}")
    val receiveFeeSats = response.fee
    // Log.v("Breez", "Fees: ${receiveFeeSats} sats")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var optionalDescription = "<invoice description>";
var optionalAmountSats = new BigInteger(5000);
// Optionally set the expiry UNIX timestamp in seconds
var optionalExpiryTimeSeconds = 1716691200UL;
var optionalSenderPublicKey = "<sender public key>";

var request = new ReceivePaymentRequest(
    paymentMethod: new ReceivePaymentMethod.SparkInvoice(
        description: optionalDescription,
        amount: optionalAmountSats,
        expiryTime: optionalExpiryTimeSeconds,
        senderPublicKey: optionalSenderPublicKey,
        tokenIdentifier: null
    )
);
var response = await sdk.ReceivePayment(request: request);

var paymentRequest = response.paymentRequest;
Console.WriteLine($"Payment Request: {paymentRequest}");
var receiveFeeSats = response.fee;
Console.WriteLine($"Fees: {receiveFeeSats} sats");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const optionalDescription = '<invoice description>'
const optionalAmountSats = '5000'
// Optionally set the expiry UNIX timestamp in seconds
const optionalExpiryTimeSeconds = 1716691200
const optionalSenderPublicKey = '<sender public key>'

const response = await sdk.receivePayment({
  paymentMethod: {
    type: 'sparkInvoice',
    description: optionalDescription,
    amount: optionalAmountSats,
    expiryTime: optionalExpiryTimeSeconds,
    senderPublicKey: optionalSenderPublicKey
  }
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const optionalDescription = '<invoice description>'
const optionalAmountSats = BigInt(5_000)
// Optionally set the expiry UNIX timestamp in seconds
const optionalExpiryTimeSeconds = BigInt(1716691200)
const optionalSenderPublicKey = '<sender public key>'

const response = await sdk.receivePayment({
  paymentMethod: new ReceivePaymentMethod.SparkInvoice({
    description: optionalDescription,
    amount: optionalAmountSats,
    expiryTime: optionalExpiryTimeSeconds,
    senderPublicKey: optionalSenderPublicKey,
    tokenIdentifier: undefined
  })
})

const paymentRequest = response.paymentRequest
console.log(`Payment Request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} sats`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String optionalDescription = "<invoice description>";
BigInt optionalAmountSats = BigInt.from(5000);
// Optionally set the expiry UNIX timestamp in seconds
BigInt optionalExpiryTimeSeconds = BigInt.from(1716691200);
String optionalSenderPublicKey = "<sender public key>";

ReceivePaymentRequest request =
    ReceivePaymentRequest(paymentMethod: ReceivePaymentMethod.sparkInvoice(
      description: optionalDescription,
      amount: optionalAmountSats,
      expiryTime: optionalExpiryTimeSeconds,
      senderPublicKey: optionalSenderPublicKey,
    ));
ReceivePaymentResponse response = await sdk.receivePayment(
  request: request,
);

String paymentRequest = response.paymentRequest;
print("Payment request: $paymentRequest");
BigInt receiveFeeSats = response.fee;
print("Fees: $receiveFeeSats sats");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    optional_description = "<invoice description>"
    optional_amount_sats = 5_000
    # Optionally set the expiry UNIX timestamp in seconds
    optional_expiry_time_seconds = 1716691200
    optional_sender_public_key = "<sender public key>"

    request = ReceivePaymentRequest(
        payment_method=ReceivePaymentMethod.SPARK_INVOICE(
            description=optional_description,
            amount=optional_amount_sats,
            expiry_time=optional_expiry_time_seconds,
            sender_public_key=optional_sender_public_key,
            token_identifier=None,
        )
    )
    response = await sdk.receive_payment(request=request)

    payment_request = response.payment_request
    logging.debug(f"Payment Request: {payment_request}")
    receive_fee_sats = response.fee
    logging.debug(f"Fees: {receive_fee_sats} sats")
    return response
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
optionalDescription := "<invoice description>"
optionalAmountSats := new(big.Int).SetInt64(5_000)
// Optionally set the expiry UNIX timestamp in seconds
optionalExpiryTimeSeconds := uint64(1716691200)
optionalSenderPublicKey := "<sender public key>"

request := breez_sdk_spark.ReceivePaymentRequest{
	PaymentMethod: breez_sdk_spark.ReceivePaymentMethodSparkInvoice{
		Description:     &optionalDescription,
		Amount:          &optionalAmountSats,
		ExpiryTime:      &optionalExpiryTimeSeconds,
		SenderPublicKey: &optionalSenderPublicKey,
	},
}

response, err := sdk.ReceivePayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

paymentRequest := response.PaymentRequest
log.Printf("Payment Request: %v", paymentRequest)
receiveFeesSat := response.Fee
log.Printf("Fees: %v sats", receiveFeesSat)
```

</section>

</custom-tabs>


## Event Flows

Once a receive payment is initiated, you can follow and react to the different payment events using the guide below for each payment method. See [Listening to events](/guide/events.md) for how to subscribe to events.

| Event      | Description                                    | UX Suggestion                                                                                                                         |
| ---------- | ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **Synced** | The SDK has synced payments in the background. | Update the payments list and balance. See [listing payments](/guide/list_payments.md) and [fetching the balance](/guide/get_info.md). |

#### Lightning

| Event                | Description                                                       | UX Suggestion                                    |
| -------------------- | ----------------------------------------------------------------- | ------------------------------------------------ |
| **PaymentPending**   | The Spark transfer was detected and the claim process will start. | Show payment as pending.                         |
| **PaymentSucceeded** | The Spark transfer is claimed and the payment is complete.        | Update the balance and show payment as complete. |

#### Bitcoin

| Event                 | Description                                                                                                                                                                                               | UX Suggestion                                                                                                    |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **UnclaimedDeposits** | The SDK attempted to claim static address deposits but they failed from one of several reasons. Either the claim fee exceeded the maximum allowed limit or there was an issue finding the available UTXO. | Allow the user to refund these failed deposits. See [Handling unclaimed deposits](/guide/unclaimed_deposits.md). |
| **ClaimedDeposits**   | The SDK successfully claimed static address deposits.                                                                                                                                                     |                                                                                                                  |
| **PaymentPending**    | The Spark transfer was detected and the claim process will start.                                                                                                                                         | Show payment as pending.                                                                                         |
| **PaymentSucceeded**  | The Spark transfer is claimed and the payment is complete.                                                                                                                                                | Update the balance and show payment as complete.                                                                 |

#### Spark

| Event                | Description                                                                                                                                                                                          | UX Suggestion                                    |
| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------ |
| **PaymentPending**   | The Spark transfer was detected and the claim process will start. For Spark HTLC payments, the claim will only start once the HTLC is claimed. For more details see [Spark HTLC payments](htlcs.md). | Show payment as pending.                         |
| **PaymentSucceeded** | The Spark transfer is claimed and the payment is complete.                                                                                                                                           | Update the balance and show payment as complete. |

# Sending payments

Once the SDK is initialized, you can directly begin sending payments. The send process takes two steps:

1. [Preparing the Payment](send_payment.md#preparing-payments)
2. [Sending the Payment](send_payment.md#sending-payments)

For sending payments via LNURL, see [LNURL-Pay](lnurl_pay.md).

<h2 id="preparing-payments">
    <a class="header" href="#preparing-payments">Preparing Payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.prepare_send_payment">API docs</a>
</h2>

During the prepare step, the SDK ensures that the inputs are valid with respect to the payment request type,
and also returns the fees related to the payment so they can be confirmed.

The payment request field supports Lightning invoices, Bitcoin addresses, Spark addresses and Spark invoices.

## Lightning

#### BOLT11 invoice

For BOLT11 invoices the amount can be optionally set. The amount set in the request is only taken into account if it's an amountless invoice.

If the invoice also contains a Spark address, the payment can be sent directly via a Spark transfer instead. When this is the case, the prepare response includes the Spark transfer fee.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let payment_request = "<bolt11 invoice>".to_string();
// Optionally set the amount you wish the pay the receiver
let optional_amount_sats = Some(5_000);

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        amount: optional_amount_sats,
        token_identifier: None,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to create the Send Payment
if let SendPaymentMethod::Bolt11Invoice {
    spark_transfer_fee_sats,
    lightning_fee_sats,
    ..
} = prepare_response.payment_method
{
    // Fees to pay via Lightning
    info!("Lightning Fees: {lightning_fee_sats} sats");
    // Or fees to pay (if available) via a Spark transfer
    info!("Spark Transfer Fees: {spark_transfer_fee_sats:?} sats");
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let paymentRequest = "<bolt11 invoice>"
// Optionally set the amount you wish the pay the receiver (requires 'import BigNumber')
let optionalAmountSats = BInt(5_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        amount: optionalAmountSats
    ))

if case let .bolt11Invoice(_, sparkTransferFeeSats, lightningFeeSats) = prepareResponse
    .paymentMethod
{
    // Fees to pay via Lightning
    print("Lightning Fee: \(lightningFeeSats) sats")
    // Or fees to pay (if available) via a Spark transfer
    if let sparkTransferFeeSats = sparkTransferFeeSats {
        print("Spark Transfer Fee: \(sparkTransferFeeSats) sats")
    }
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val paymentRequest = "<bolt11 invoice>"
// Optionally set the amount you wish the pay the receiver
// Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in package)
val optionalAmountSats = BigInteger.fromLong(5_000L)
// Android (BigInteger from java.math)
// val optionalAmountSats = BigInteger.valueOf(5_000L)

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        optionalAmountSats,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // If the fees are acceptable, continue to create the Send Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.Bolt11Invoice) {
        // Fees to pay via Lightning
        val lightningFeeSats = paymentMethod.lightningFeeSats
        // Or fees to pay (if available) via a Spark transfer
        val sparkTransferFeeSats = paymentMethod.sparkTransferFeeSats
        // Log.v("Breez", "Lightning Fees: ${lightningFeeSats} sats")
        // Log.v("Breez", "Spark Transfer Fees: ${sparkTransferFeeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var paymentRequest = "<bolt11 invoice>";
// Optionally set the amount you wish the pay the receiver
var optionalAmountSats = new BigInteger(5000);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    amount: optionalAmountSats
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.Bolt11Invoice bolt11Method)
{
    // Fees to pay via Lightning
    var lightningFeeSats = bolt11Method.lightningFeeSats;
    // Or fees to pay (if available) via a Spark transfer
    var sparkTransferFeeSats = bolt11Method.sparkTransferFeeSats;
    Console.WriteLine($"Lightning Fees: {lightningFeeSats} sats");
    Console.WriteLine($"Spark Transfer Fees: {sparkTransferFeeSats} sats");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const paymentRequest = '<bolt11 invoice>'
// Optionally set the amount you wish the pay the receiver
const optionalAmountSats = BigInt(5_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: optionalAmountSats
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod.type === 'bolt11Invoice') {
  // Fees to pay via Lightning
  const lightningFeeSats = prepareResponse.paymentMethod.lightningFeeSats
  // Or fees to pay (if available) via a Spark transfer
  const sparkTransferFeeSats = prepareResponse.paymentMethod.sparkTransferFeeSats
  console.debug(`Lightning Fees: ${lightningFeeSats} sats`)
  console.debug(`Spark Transfer Fees: ${sparkTransferFeeSats} sats`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const paymentRequest = '<bolt11 invoice>'
// Optionally set the amount you wish the pay the receiver
const optionalAmountSats = BigInt(5_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: optionalAmountSats,
  tokenIdentifier: undefined,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.Bolt11Invoice) {
  // Fees to pay via Lightning
  const lightningFeeSats = prepareResponse.paymentMethod.inner.lightningFeeSats
  // Or fees to pay (if available) via a Spark transfer
  const sparkTransferFeeSats = prepareResponse.paymentMethod.inner.sparkTransferFeeSats
  console.debug(`Lightning Fees: ${lightningFeeSats} sats`)
  console.debug(`Spark Transfer Fees: ${sparkTransferFeeSats} sats`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String paymentRequest = "<bolt11 invoice>";
// Optionally set the amount you wish the pay the receiver
BigInt optionalAmountSats = BigInt.from(5000);

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest, amount: optionalAmountSats);
final response = await sdk.prepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_Bolt11Invoice) {
  // Fees to pay via Lightning
  final lightningFeeSats = paymentMethod.lightningFeeSats;
  // Or fees to pay (if available) via a Spark transfer
  final sparkTransferFeeSats = paymentMethod.sparkTransferFeeSats;
  print("Lightning Fees: $lightningFeeSats sats");
  print("Spark Transfer Fees: $sparkTransferFeeSats sats");
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
payment_request = "<bolt11 invoice>"
# Optionally set the amount you wish the pay the receiver
optional_amount_sats = 5_000
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        amount=optional_amount_sats,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # If the fees are acceptable, continue to create the Send Payment
    if isinstance(
        prepare_response.payment_method, SendPaymentMethod.BOLT11_INVOICE
    ):
        # Fees to pay via Lightning
        lightning_fee_sats = prepare_response.payment_method.lightning_fee_sats
        # Or fees to pay (if available) via a Spark transfer
        spark_transfer_fee_sats = (
            prepare_response.payment_method.spark_transfer_fee_sats
        )
        logging.debug(f"Lightning Fees: {lightning_fee_sats} sats")
        logging.debug(f"Spark Transfer Fees: {spark_transfer_fee_sats} sats")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
paymentRequest := "<bolt11 invoice>"
// Optionally set the amount you wish the pay the receiver
optionalAmountSats := new(big.Int).SetInt64(5_000)

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	Amount:         &optionalAmountSats,
}
response, err := sdk.PrepareSendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

// If the fees are acceptable, continue to create the Send Payment
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodBolt11Invoice:
	// Fees to pay via Lightning
	lightningFeeSats := paymentMethod.LightningFeeSats
	// Or fees to pay (if available) via a Spark transfer
	sparkTransferFeeSats := paymentMethod.SparkTransferFeeSats
	log.Printf("Lightning Fees: %v sats", lightningFeeSats)
	log.Printf("Spark Transfer Fees: %v sats", sparkTransferFeeSats)
}
```

</section>

</custom-tabs>


## Bitcoin

For Bitcoin addresses, the amount must be set in the request. The prepare response includes fee quotes for three payment speeds: Slow, Medium, and Fast.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let payment_request = "<bitcoin address>".to_string();
// Set the amount you wish the pay the receiver
let amount_sats = Some(50_000);

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        amount: amount_sats,
        token_identifier: None,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to create the Send Payment
if let SendPaymentMethod::BitcoinAddress { fee_quote, .. } = &prepare_response.payment_method {
    info!("Slow Fees: {} sats", fee_quote.speed_slow.total_fee_sat());
    info!(
        "Medium Fees: {} sats",
        fee_quote.speed_medium.total_fee_sat()
    );
    info!("Fast Fees: {} sats", fee_quote.speed_fast.total_fee_sat());
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let paymentRequest = "<bitcoin address>"
// Set the amount you wish the pay the receiver (requires 'import BigNumber')
let amountSats = BInt(50_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        amount: amountSats
    ))

if case let .bitcoinAddress(_, feeQuote) = prepareResponse.paymentMethod {
    let slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
    let mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
    let fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
    print("Slow Fees: \(slowFeeSats) sats")
    print("Medium Fees: \(mediumFeeSats) sats")
    print("Fast Fees: \(fastFeeSats) sats")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val paymentRequest = "<bitcoin address>"
// Set the amount you wish the pay the receiver
// Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in package)
val amountSats = BigInteger.fromLong(50_000L)
// Android (BigInteger from java.math)
// val amountSats = BigInteger.valueOf(50_000L)

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        amountSats,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // If the fees are acceptable, continue to create the Send Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.BitcoinAddress) {
        val feeQuote = paymentMethod.feeQuote
        val slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
        val mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
        val fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
        // Log.v("Breez", "Slow Fees: ${slowFeeSats} sats")
        // Log.v("Breez", "Medium Fees: ${mediumFeeSats} sats")
        // Log.v("Breez", "Fast Fees: ${fastFeeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var paymentRequest = "<bitcoin address>";
// Set the amount you wish the pay the receiver
var amountSats = new BigInteger(50000);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    amount: amountSats
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.BitcoinAddress bitcoinMethod)
{
    var feeQuote = bitcoinMethod.feeQuote;
    var slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat;
    var mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat;
    var fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat;
    Console.WriteLine($"Slow Fees: {slowFeeSats} sats");
    Console.WriteLine($"Medium Fees: {mediumFeeSats} sats");
    Console.WriteLine($"Fast Fees: {fastFeeSats} sats");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const paymentRequest = '<bitcoin address>'
// Set the amount you wish the pay the receiver
const amountSats = BigInt(50_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: amountSats
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod.type === 'bitcoinAddress') {
  const feeQuote = prepareResponse.paymentMethod.feeQuote
  const slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
  const mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
  const fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
  console.debug(`Slow Fees: ${slowFeeSats} sats`)
  console.debug(`Medium Fees: ${mediumFeeSats} sats`)
  console.debug(`Fast Fees: ${fastFeeSats} sats`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const paymentRequest = '<bitcoin address>'
// Set the amount you wish the pay the receiver
const amountSats = BigInt(50_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: amountSats,
  tokenIdentifier: undefined,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.BitcoinAddress) {
  const feeQuote = prepareResponse.paymentMethod.inner.feeQuote
  const slowFeeSats = feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat
  const mediumFeeSats = feeQuote.speedMedium.userFeeSat + feeQuote.speedMedium.l1BroadcastFeeSat
  const fastFeeSats = feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat
  console.debug(`Slow Fees: ${slowFeeSats} sats`)
  console.debug(`Medium Fees: ${mediumFeeSats} sats`)
  console.debug(`Fast Fees: ${fastFeeSats} sats`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String paymentRequest = "<bitcoin address>";
// Set the amount you wish the pay the receiver
BigInt amountSats = BigInt.from(50000);

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest, amount: amountSats);
final response = await sdk.prepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_BitcoinAddress) {
  final feeQuote = paymentMethod.feeQuote;
  final slowFeeSats =
      feeQuote.speedSlow.userFeeSat + feeQuote.speedSlow.l1BroadcastFeeSat;
  final mediumFeeSats = feeQuote.speedMedium.userFeeSat +
      feeQuote.speedMedium.l1BroadcastFeeSat;
  final fastFeeSats =
      feeQuote.speedFast.userFeeSat + feeQuote.speedFast.l1BroadcastFeeSat;
  print("Slow Fees: $slowFeeSats sats");
  print("Medium Fees: $mediumFeeSats sats");
  print("Fast Fees: $fastFeeSats sats");
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
payment_request = "<bitcoin address>"
# Set the amount you wish the pay the receiver
amount_sats = 50_000
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        amount=amount_sats,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # If the fees are acceptable, continue to create the Send Payment
    if isinstance(
        prepare_response.payment_method, SendPaymentMethod.BITCOIN_ADDRESS
    ):
        fee_quote = prepare_response.payment_method.fee_quote
        slow_fee_sats = (
            fee_quote.speed_slow.user_fee_sat
            + fee_quote.speed_slow.l1_broadcast_fee_sat
        )
        medium_fee_sats = (
            fee_quote.speed_medium.user_fee_sat
            + fee_quote.speed_medium.l1_broadcast_fee_sat
        )
        fast_fee_sats = (
            fee_quote.speed_fast.user_fee_sat
            + fee_quote.speed_fast.l1_broadcast_fee_sat
        )
        logging.debug(f"Slow Fees: {slow_fee_sats} sats")
        logging.debug(f"Medium Fees: {medium_fee_sats} sats")
        logging.debug(f"Fast Fees: {fast_fee_sats} sats")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
paymentRequest := "<bitcoin address>"
// Set the amount you wish the pay the receiver
amountSats := new(big.Int).SetInt64(50_000)

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	Amount:         &amountSats,
}
response, err := sdk.PrepareSendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

// If the fees are acceptable, continue to create the Send Payment
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodBitcoinAddress:
	feeQuote := paymentMethod.FeeQuote
	slowFeeQuote := feeQuote.SpeedSlow.UserFeeSat + feeQuote.SpeedSlow.L1BroadcastFeeSat
	mediumFeeQuote := feeQuote.SpeedMedium.UserFeeSat + feeQuote.SpeedMedium.L1BroadcastFeeSat
	fastFeeQuote := feeQuote.SpeedFast.UserFeeSat + feeQuote.SpeedFast.L1BroadcastFeeSat
	log.Printf("Slow Fees: %v sats", slowFeeQuote)
	log.Printf("Medium Fees: %v sats", mediumFeeQuote)
	log.Printf("Fast Fees: %v sats", fastFeeQuote)
}
```

</section>

</custom-tabs>


## Spark

#### Spark address

For Spark addresses, the amount must be set in the request. Sending to a Spark address uses a direct Spark transfer.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let payment_request = "<spark address>".to_string();
// Set the amount you wish the pay the receiver
let amount_sats = Some(50_000);

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        amount: amount_sats,
        token_identifier: None,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to create the Send Payment
if let SendPaymentMethod::SparkAddress { fee, .. } = prepare_response.payment_method {
    info!("Fees: {} sats", fee);
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let paymentRequest = "<spark address>"
// Set the amount you wish the pay the receiver (requires 'import BigNumber')
let amountSats = BInt(50_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        amount: amountSats
    ))

if case let .sparkAddress(_, feeSats, _) = prepareResponse.paymentMethod {
    print("Fees: \(feeSats) sats")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val paymentRequest = "<spark address>"
// Set the amount you wish the pay the receiver
// Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in package)
val amountSats = BigInteger.fromLong(50_000L)
// Android (BigInteger from java.math)
// val amountSats = BigInteger.valueOf(50_000L)

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        amountSats,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // If the fees are acceptable, continue to create the Send Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.SparkAddress) {
        val feeSats = paymentMethod.fee
        // Log.v("Breez", "Fees: ${feeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var paymentRequest = "<spark address>";
// Set the amount you wish the pay the receiver
var amountSats = new BigInteger(50000);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    amount: amountSats
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.SparkAddress sparkMethod)
{
    var fee = sparkMethod.fee;
    Console.WriteLine($"Fees: {fee} sats");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const paymentRequest = '<spark address>'
// Set the amount you wish the pay the receiver
const amountSats = BigInt(50_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: amountSats
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod.type === 'sparkAddress') {
  const feeSats = prepareResponse.paymentMethod.fee
  console.debug(`Fees: ${feeSats} sats`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const paymentRequest = '<spark address>'
// Set the amount you wish the pay the receiver
const amountSats = BigInt(50_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: amountSats,
  tokenIdentifier: undefined,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.SparkAddress) {
  const feeSats = prepareResponse.paymentMethod.inner.fee
  console.debug(`Fees: ${feeSats} sats`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String paymentRequest = "<spark address>";
// Set the amount you wish the pay the receiver
BigInt amountSats = BigInt.from(50000);

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest, amount: amountSats);
final response = await sdk.prepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_SparkAddress) {
  final feeSats = paymentMethod.fee;
  print("Fees: $feeSats sats");
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
payment_request = "<spark address>"
# Set the amount you wish the pay the receiver
amount_sats = 50_000
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        amount=amount_sats,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # If the fees are acceptable, continue to create the Send Payment
    if isinstance(prepare_response.payment_method, SendPaymentMethod.SPARK_ADDRESS):
        fee = prepare_response.payment_method.fee
        logging.debug(f"Fees: {fee} sats")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
paymentRequest := "<spark address>"
// Set the amount you wish the pay the receiver
amountSats := new(big.Int).SetInt64(50_000)

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	Amount:         &amountSats,
}
response, err := sdk.PrepareSendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

// If the fees are acceptable, continue to create the Send Payment
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodSparkAddress:
	feeSats := paymentMethod.Fee
	log.Printf("Fees: %v sats", feeSats)
}
```

</section>

</custom-tabs>


#### Spark invoice

For Spark invoices, the amount can be optionally set. It is only required if the invoice doesn't specify an amount. If the invoice specifies an amount, providing a different amount is not supported.

<div class="warning">
<h4>Developer note</h4>
Spark invoices may require a token (non-Bitcoin) as the payment asset. To determine the requirements of a Spark invoice and any restrictions it may impose, see the <a href="./parse.md">Parsing inputs</a> page. To learn more about tokens, see the <a href="./tokens.md">Handling tokens</a> page.
</div>

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let payment_request = "<spark invoice>".to_string();
// Optionally set the amount you wish the pay the receiver
let optional_amount_sats = Some(50_000);

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        amount: optional_amount_sats,
        token_identifier: None,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to create the Send Payment
if let SendPaymentMethod::SparkInvoice { fee, .. } = prepare_response.payment_method {
    info!("Fees: {} sats", fee);
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let paymentRequest = "<spark invoice>"
// Optionally set the amount you wish the pay the receiver (requires 'import BigNumber')
let optionalAmountSats = BInt(50_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        amount: optionalAmountSats
    ))

if case let .sparkInvoice(_, feeSats, _) = prepareResponse.paymentMethod {
    print("Fees: \(feeSats) sats")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val paymentRequest = "<spark invoice>"
// Optionally set the amount you wish the pay the receiver
// Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in
// package)
val optionalAmountSats = BigInteger.fromLong(50_000L)
// Android (BigInteger from java.math)
// val optionalAmountSats = BigInteger.valueOf(50_000L)

try {
    val req = PrepareSendPaymentRequest(
        paymentRequest,
        optionalAmountSats,
    )
    val prepareResponse = sdk.prepareSendPayment(req)

    // If the fees are acceptable, continue to create the Send Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.SparkInvoice) {
        val feeSats = paymentMethod.fee
        // Log.v("Breez", "Fees: ${feeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var paymentRequest = "<spark invoice>";
// Optionally set the amount you wish the pay the receiver
var optionalAmountSats = new BigInteger(50000);

var request = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    amount: optionalAmountSats
);
var prepareResponse = await sdk.PrepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.SparkInvoice sparkInvoiceMethod)
{
    var fee = sparkInvoiceMethod.fee;
    Console.WriteLine($"Fees: {fee} sats");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const paymentRequest = '<spark invoice>'
// Optionally set the amount you wish the pay the receiver
const optionalAmountSats = BigInt(50_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: optionalAmountSats
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod.type === 'sparkInvoice') {
  const feeSats = prepareResponse.paymentMethod.fee
  console.debug(`Fees: ${feeSats} sats`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const paymentRequest = '<spark invoice>'
// Optionally set the amount you wish the pay the receiver
const optionalAmountSats = BigInt(50_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: optionalAmountSats,
  tokenIdentifier: undefined,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to create the Send Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.SparkInvoice) {
  const feeSats = prepareResponse.paymentMethod.inner.fee
  console.debug(`Fees: ${feeSats} sats`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String paymentRequest = "<spark invoice>";
// Optionally set the amount you wish the pay the receiver
BigInt optionalAmountSats = BigInt.from(50000);

final request = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest, amount: optionalAmountSats);
final response = await sdk.prepareSendPayment(request: request);

// If the fees are acceptable, continue to create the Send Payment
final paymentMethod = response.paymentMethod;
if (paymentMethod is SendPaymentMethod_SparkInvoice) {
  final feeSats = paymentMethod.fee;
  print("Fees: $feeSats sats");
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
payment_request = "<spark invoice>"
# Optionally set the amount you wish the pay the receiver
optional_amount_sats = 50_000
try:
    request = PrepareSendPaymentRequest(
        payment_request=payment_request,
        amount=optional_amount_sats,
    )
    prepare_response = await sdk.prepare_send_payment(request=request)

    # If the fees are acceptable, continue to create the Send Payment
    if isinstance(prepare_response.payment_method, SendPaymentMethod.SPARK_INVOICE):
        fee = prepare_response.payment_method.fee
        logging.debug(f"Fees: {fee} sats")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
paymentRequest := "<spark invoice>"
// Optionally set the amount you wish the pay the receiver
optionalAmountSats := new(big.Int).SetInt64(50_000)

request := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	Amount:         &optionalAmountSats,
}
response, err := sdk.PrepareSendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

// If the fees are acceptable, continue to create the Send Payment
switch paymentMethod := response.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodSparkInvoice:
	feeSats := paymentMethod.Fee
	log.Printf("Fees: %v sats", feeSats)
}
```

</section>

</custom-tabs>


<h2 id="sending-payments">
    <a class="header" href="#sending-payments">Sending Payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.send_payment">API docs</a>
</h2>

Once the payment has been prepared and the fees are accepted, the payment can be sent by passing:
- **Prepare Response** - The response from the [Preparing the Payment](send_payment.md#preparing-payments) step.
- **Options** - Any payment method specific options for the payment (see below).
- **Idempotency Key** - An optional UUID that identifies the payment. If set, providing the same idempotency key for multiple requests will ensure that only one payment is made.

## Lightning

In the optional send payment options for BOLT11 invoices, you can set:
- **Prefer Spark** - Set the preference to use Spark to transfer the payment if the invoice contains a Spark address. By default, using Spark transfers are disabled.
- **Completion Timeout** - By default, this function returns immediately. You can override this behavior by specifying a completion timeout in seconds. If the timeout is reached, a pending payment object is returned. If the payment completes within the timeout, the completed payment object is returned.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let options = Some(SendPaymentOptions::Bolt11Invoice {
    prefer_spark: false,
    completion_timeout_secs: Some(10),
});
let optional_idempotency_key = Some("<idempotency key uuid>".to_string());
let send_response = sdk
    .send_payment(SendPaymentRequest {
        prepare_response,
        options,
        idempotency_key: optional_idempotency_key,
    })
    .await?;
let payment = send_response.payment;
info!("Payment: {payment:?}");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let options = SendPaymentOptions.bolt11Invoice(preferSpark: false, completionTimeoutSecs: 10)
let optionalIdempotencyKey = "<idempotency key uuid>"
let sendResponse = try await sdk.sendPayment(
    request: SendPaymentRequest(
        prepareResponse: prepareResponse,
        options: options,
        idempotencyKey: optionalIdempotencyKey
    ))
let payment = sendResponse.payment
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val options = SendPaymentOptions.Bolt11Invoice(
        preferSpark = false, 
        completionTimeoutSecs = 10u
    )
    val optionalIdempotencyKey = "<idempotency key uuid>"
    val sendResponse = sdk.sendPayment(
        SendPaymentRequest(
            prepareResponse,
            options,
            optionalIdempotencyKey
        )
    )
    val payment = sendResponse.payment
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var options = new SendPaymentOptions.Bolt11Invoice(
    preferSpark: false,
    completionTimeoutSecs: 10
);
var optionalIdempotencyKey = "<idempotency key uuid>";
var request = new SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey
);
var sendResponse = await sdk.SendPayment(request: request);
var payment = sendResponse.payment;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const options: SendPaymentOptions = {
  type: 'bolt11Invoice',
  preferSpark: false,
  completionTimeoutSecs: 10
}
const optionalIdempotencyKey = '<idempotency key uuid>'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const options = new SendPaymentOptions.Bolt11Invoice({
  preferSpark: false,
  completionTimeoutSecs: 10
})
const optionalIdempotencyKey = '<idempotency key uuid>'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final options = SendPaymentOptions.bolt11Invoice(
    preferSpark: false, completionTimeoutSecs: 10);
String? optionalIdempotencyKey = "<idempotency key uuid>";
final request = SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey);
SendPaymentResponse response = await sdk.sendPayment(request: request);
Payment payment = response.payment;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    options = SendPaymentOptions.BOLT11_INVOICE(
        prefer_spark=False, completion_timeout_secs=10
    )
    optional_idempotency_key = "<idempotency key uuid>"
    request = SendPaymentRequest(
        prepare_response=prepare_response,
        options=options,
        idempotency_key=optional_idempotency_key,
    )
    send_response = await sdk.send_payment(request=request)
    payment = send_response.payment
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
var completionTimeoutSecs uint32 = 10
var options breez_sdk_spark.SendPaymentOptions = breez_sdk_spark.SendPaymentOptionsBolt11Invoice{
	PreferSpark:           false,
	CompletionTimeoutSecs: &completionTimeoutSecs,
}

optionalIdempotencyKey := "<idempotency key uuid>"
request := breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	Options:         &options,
	IdempotencyKey:  &optionalIdempotencyKey,
}
response, err := sdk.SendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payment := response.Payment
```

</section>

</custom-tabs>


## Bitcoin

In the optional send payment options for Bitcoin addresses, you can set:
- **Confirmation Speed** - The priority that the Bitcoin transaction confirms, that also effects the fee paid. By default, it is set to Fast.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let options = SendPaymentOptions::BitcoinAddress {
    confirmation_speed: OnchainConfirmationSpeed::Medium,
};
let optional_idempotency_key = Some("<idempotency key uuid>".to_string());
let send_response = sdk
    .send_payment(SendPaymentRequest {
        prepare_response,
        options: Some(options),
        idempotency_key: optional_idempotency_key,
    })
    .await?;
let payment = send_response.payment;
info!("Payment: {payment:?}");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let options = SendPaymentOptions.bitcoinAddress(
    confirmationSpeed: .medium
)
let optionalIdempotencyKey = "<idempotency key uuid>"
let sendResponse = try await sdk.sendPayment(
    request: SendPaymentRequest(
        prepareResponse: prepareResponse,
        options: options,
        idempotencyKey: optionalIdempotencyKey
    ))
let payment = sendResponse.payment
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val options = SendPaymentOptions.BitcoinAddress(
        OnchainConfirmationSpeed.MEDIUM
    )
    val optionalIdempotencyKey = "<idempotency key uuid>"
    val sendResponse = sdk.sendPayment(
        SendPaymentRequest(
            prepareResponse,
            options,
            optionalIdempotencyKey
        )
    )
    val payment = sendResponse.payment
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var options = new SendPaymentOptions.BitcoinAddress(
    confirmationSpeed: OnchainConfirmationSpeed.Medium
);
var optionalIdempotencyKey = "<idempotency key uuid>";
var request = new SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey
);
var sendResponse = await sdk.SendPayment(request: request);
var payment = sendResponse.payment;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const options: SendPaymentOptions = {
  type: 'bitcoinAddress',
  confirmationSpeed: 'medium'
}
const optionalIdempotencyKey = '<idempotency key uuid>'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const optionalIdempotencyKey = '<idempotency key uuid>'
const options = new SendPaymentOptions.BitcoinAddress({
  confirmationSpeed: OnchainConfirmationSpeed.Medium
})
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final options = SendPaymentOptions.bitcoinAddress(
    confirmationSpeed: OnchainConfirmationSpeed.medium);
String? optionalIdempotencyKey = "<idempotency key uuid>";
final request = SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options,
    idempotencyKey: optionalIdempotencyKey);
SendPaymentResponse response = await sdk.sendPayment(request: request);
Payment payment = response.payment;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    options = SendPaymentOptions.BITCOIN_ADDRESS(
        confirmation_speed=OnchainConfirmationSpeed.MEDIUM
    )
    optional_idempotency_key = "<idempotency key uuid>"
    request = SendPaymentRequest(
        prepare_response=prepare_response,
        options=options,
        idempotency_key=optional_idempotency_key,
    )
    send_response = await sdk.send_payment(request=request)
    payment = send_response.payment
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
var options breez_sdk_spark.SendPaymentOptions = breez_sdk_spark.SendPaymentOptionsBitcoinAddress{
	ConfirmationSpeed: breez_sdk_spark.OnchainConfirmationSpeedMedium,
}

optionalIdempotencyKey := "<idempotency key uuid>"
request := breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	Options:         &options,
	IdempotencyKey:  &optionalIdempotencyKey,
}
response, err := sdk.SendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payment := response.Payment
```

</section>

</custom-tabs>


## Spark

In the optional send payment options for Spark addresses, you can set:
- **HTLC Options** - Enables Spark HTLC payments, which are an advanced feature that allows for conditional payments. See the [Spark HTLC Payments](htlcs.md) page for more details and example usage.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let optional_idempotency_key = Some("<idempotency key uuid>".to_string());
let send_response = sdk
    .send_payment(SendPaymentRequest {
        prepare_response,
        options: None,
        idempotency_key: optional_idempotency_key,
    })
    .await?;
let payment = send_response.payment;
info!("Payment: {payment:?}");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let optionalIdempotencyKey = "<idempotency key uuid>"
let sendResponse = try await sdk.sendPayment(
    request: SendPaymentRequest(
        prepareResponse: prepareResponse,
        idempotencyKey: optionalIdempotencyKey
    ))
let payment = sendResponse.payment
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val optionalIdempotencyKey = "<idempotency key uuid>"
    val sendResponse = sdk.sendPayment(
        SendPaymentRequest(
            prepareResponse,
            idempotencyKey = optionalIdempotencyKey
        )
    )
    val payment = sendResponse.payment
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var optionalIdempotencyKey = "<idempotency key uuid>";
var request = new SendPaymentRequest(
    prepareResponse: prepareResponse,
    idempotencyKey: optionalIdempotencyKey
);
var sendResponse = await sdk.SendPayment(request: request);
var payment = sendResponse.payment;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const optionalIdempotencyKey = '<idempotency key uuid>'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const optionalIdempotencyKey = '<idempotency key uuid>'
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options: undefined,
  idempotencyKey: optionalIdempotencyKey
})
const payment = sendResponse.payment
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String? optionalIdempotencyKey = "<idempotency key uuid>";
final request = SendPaymentRequest(
    prepareResponse: prepareResponse, idempotencyKey: optionalIdempotencyKey);
SendPaymentResponse response = await sdk.sendPayment(request: request);
Payment payment = response.payment;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    optional_idempotency_key = "<idempotency key uuid>"
    request = SendPaymentRequest(
        prepare_response=prepare_response, idempotency_key=optional_idempotency_key
    )
    send_response = await sdk.send_payment(request=request)
    payment = send_response.payment
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
optionalIdempotencyKey := "<idempotency key uuid>"
request := breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	IdempotencyKey:  &optionalIdempotencyKey,
}
response, err := sdk.SendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payment := response.Payment
```

</section>

</custom-tabs>


## Event Flows

Once a send payment is initiated, you can follow and react to the different payment events using the guide below for each payment method. See [Listening to events](/guide/events.html) for how to subscribe to events.

| Event      | Description                                    | UX Suggestion                                                                                                                         |
| ---------- | ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **Synced** | The SDK has synced payments in the background. | Update the payments list and balance. See [listing payments](/guide/list_payments.md) and [fetching the balance](/guide/get_info.md). |

#### Lightning

| Event                | Description                                                                       | UX Suggestion                                    |
| -------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------ |
| **PaymentPending**   | The Spark transfer has been started. Awaiting Lightning payment completion.       | Show payment as pending.                         |
| **PaymentSucceeded** | The Lightning invoice has been paid either over Lightning or via a Spark transfer | Update the balance and show payment as complete. |
| **PaymentFailed**    | The attempt to pay the Lightning invoice failed.                                  |                                                  |

#### Bitcoin

| Event                | Description                                                                  | UX Suggestion                                    |
| -------------------- | ---------------------------------------------------------------------------- | ------------------------------------------------ |
| **PaymentPending**   | The Spark transfer has been started. Awaiting on-chain withdrawal completion. | Show payment as pending.                         |
| **PaymentSucceeded** | The payment amount was successfully withdrawn on-chain.                       | Update the balance and show payment as complete. |

#### Spark

| Event                | Description                     | UX Suggestion                                    |
| -------------------- | ------------------------------- | ------------------------------------------------ |
| **PaymentSucceeded** | The Spark transfer is complete. | Update the balance and show payment as complete. |

<h1 id="listing-payments">
    <a class="header" href="#listing-payments">Listing payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.list_payments">API docs</a>
</h1>

To view your payment history, you can list all the payments that have been sent and received.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let response = sdk.list_payments(ListPaymentsRequest::default()).await?;
let payments = response.payments;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let response = try await sdk.listPayments(
    request: ListPaymentsRequest())
let payments = response.payments
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val response = sdk.listPayments(ListPaymentsRequest())
    val payments = response.payments
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var response = await sdk.ListPayments(request: new ListPaymentsRequest());
var payments = response.payments;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.listPayments({})
const payments = response.payments
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const response = await sdk.listPayments({
  typeFilter: undefined,
  statusFilter: undefined,
  assetFilter: undefined,
  paymentDetailsFilter: undefined,
  fromTimestamp: undefined,
  toTimestamp: undefined,
  offset: undefined,
  limit: undefined,
  sortAscending: undefined
})
const payments = response.payments
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
ListPaymentsRequest request = ListPaymentsRequest();
ListPaymentsResponse response = await sdk.listPayments(request: request);
List<Payment> payments = response.payments;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
response = await sdk.list_payments(request=ListPaymentsRequest())
payments = response.payments
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
response, err := sdk.ListPayments(breez_sdk_spark.ListPaymentsRequest{})

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payments := response.Payments
```

</section>

</custom-tabs>


## Filtering Payments

When listing payments you can also filter and page the results.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Filter by asset (Bitcoin or Token)
let asset_filter = AssetFilter::Token {
    token_identifier: Some("token_identifier_here".to_string()),
};
// To filter by Bitcoin instead:
// let asset_filter = AssetFilter::Bitcoin;

let response = sdk
    .list_payments(ListPaymentsRequest {
        // Filter by payment type
        type_filter: Some(vec![PaymentType::Send, PaymentType::Receive]),
        // Filter by status
        status_filter: Some(vec![PaymentStatus::Completed]),
        asset_filter: Some(asset_filter),
        // Time range filters
        from_timestamp: Some(1704067200), // Unix timestamp
        to_timestamp: Some(1735689600),   // Unix timestamp
        // Pagination
        offset: Some(0),
        limit: Some(50),
        // Sort order (true = oldest first, false = newest first)
        sort_ascending: Some(false),
        payment_details_filter: None,
    })
    .await?;
let payments = response.payments;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Filter by asset (Bitcoin or Token)
let assetFilter = AssetFilter.token(tokenIdentifier: "token_identifier_here")
// To filter by Bitcoin instead:
// let assetFilter = AssetFilter.bitcoin

let response = try await sdk.listPayments(
    request: ListPaymentsRequest(
        // Filter by payment type
        typeFilter: [PaymentType.send, PaymentType.receive],
        // Filter by status
        statusFilter: [PaymentStatus.completed],
        assetFilter: assetFilter,
        // Time range filters
        fromTimestamp: 1_704_067_200,  // Unix timestamp
        toTimestamp: 1_735_689_600,  // Unix timestamp
        // Pagination
        offset: 0,
        limit: 50,
        // Sort order (true = oldest first, false = newest first)
        sortAscending: false
    ))
let payments = response.payments
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    // Filter by asset (Bitcoin or Token)
    val assetFilter = AssetFilter.Token(tokenIdentifier = "token_identifier_here")
    // To filter by Bitcoin instead:
    // val assetFilter = AssetFilter.Bitcoin

    val response = sdk.listPayments(
        ListPaymentsRequest(
            // Filter by payment type
            typeFilter = listOf(PaymentType.SEND, PaymentType.RECEIVE),
            // Filter by status
            statusFilter = listOf(PaymentStatus.COMPLETED),
            assetFilter = assetFilter,
            // Time range filters
            fromTimestamp = 1704067200u, // Unix timestamp
            toTimestamp = 1735689600u,   // Unix timestamp
            // Pagination
            offset = 0u,
            limit = 50u,
            // Sort order (true = oldest first, false = newest first)
            sortAscending = false
        ))
    val payments = response.payments
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Filter by asset (Bitcoin or Token)
var assetFilter = new AssetFilter.Token(tokenIdentifier: "token_identifier_here");
// To filter by Bitcoin instead:
// var assetFilter = new AssetFilter.Bitcoin();

var request = new ListPaymentsRequest(
    // Filter by payment type
    typeFilter: new List<PaymentType> { PaymentType.Send, PaymentType.Receive },
    // Filter by status
    statusFilter: new List<PaymentStatus> { PaymentStatus.Completed },
    assetFilter: assetFilter,
    // Time range filters
    fromTimestamp: 1704067200, // Unix timestamp
    toTimestamp: 1735689600,   // Unix timestamp
                               // Pagination
    offset: 0,
    limit: 50,
    // Sort order (true = oldest first, false = newest first)
    sortAscending: false
);

var response = await sdk.ListPayments(request: request);
var payments = response.payments;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Filter by asset (Bitcoin or Token)
const assetFilter: AssetFilter = { type: 'token', tokenIdentifier: 'token_identifier_here' }
// To filter by Bitcoin instead:
// const assetFilter: AssetFilter = { type: 'bitcoin' }

const response = await sdk.listPayments({
  // Filter by payment type
  typeFilter: ['send', 'receive'],
  // Filter by status
  statusFilter: ['completed'],
  assetFilter,
  // Time range filters
  fromTimestamp: 1704067200, // Unix timestamp
  toTimestamp: 1735689600, // Unix timestamp
  // Pagination
  offset: 0,
  limit: 50,
  // Sort order (true = oldest first, false = newest first)
  sortAscending: false
})
const payments = response.payments
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Filter by asset (Bitcoin or Token)
const assetFilter = new AssetFilter.Token({ tokenIdentifier: 'token_identifier_here' })
// To filter by Bitcoin instead:
// const assetFilter = new AssetFilter.Bitcoin()

const response = await sdk.listPayments({
  // Filter by payment type
  typeFilter: [PaymentType.Send, PaymentType.Receive],
  // Filter by status
  statusFilter: [PaymentStatus.Completed],
  assetFilter,
  paymentDetailsFilter: undefined,
  // Time range filters
  fromTimestamp: 1704067200n, // Unix timestamp
  toTimestamp: 1735689600n, // Unix timestamp
  // Pagination
  offset: 0,
  limit: 50,
  // Sort order (true = oldest first, false = newest first)
  sortAscending: false
})
const payments = response.payments
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Filter by asset (Bitcoin or Token)
AssetFilter assetFilter = AssetFilter.token(tokenIdentifier: "token_identifier_here");
// To filter by Bitcoin instead:
// AssetFilter assetFilter = AssetFilter.bitcoin();

ListPaymentsRequest request = ListPaymentsRequest(
  // Filter by payment type
  typeFilter: [PaymentType.send, PaymentType.receive],
  // Filter by status
  statusFilter: [PaymentStatus.completed],
  assetFilter: assetFilter,
  // Time range filters
  fromTimestamp: BigInt.from(1704067200), // Unix timestamp
  toTimestamp: BigInt.from(1735689600),   // Unix timestamp
  // Pagination
  offset: 0,
  limit: 50,
  // Sort order (true = oldest first, false = newest first)
  sortAscending: false,
);
ListPaymentsResponse response = await sdk.listPayments(request: request);
List<Payment> payments = response.payments;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Filter by asset (Bitcoin or Token)
asset_filter = AssetFilter.TOKEN(token_identifier="token_identifier_here")
# To filter by Bitcoin instead:
# asset_filter = AssetFilter.BITCOIN

request = ListPaymentsRequest(
    # Filter by payment type
    type_filter=[PaymentType.SEND, PaymentType.RECEIVE],
    # Filter by status
    status_filter=[PaymentStatus.COMPLETED],
    asset_filter=asset_filter,
    # Time range filters
    from_timestamp=1704067200,  # Unix timestamp
    to_timestamp=1735689600,    # Unix timestamp
    # Pagination
    offset=0,
    limit=50,
    # Sort order (true = oldest first, false = newest first)
    sort_ascending=False
)
response = await sdk.list_payments(request=request)
payments = response.payments
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Filter by asset (Bitcoin or Token)
tokenIdentifier := "token_identifier_here"
var assetFilter breez_sdk_spark.AssetFilter = breez_sdk_spark.AssetFilterToken{TokenIdentifier: &tokenIdentifier}
// To filter by Bitcoin instead:
// var assetFilter breez_sdk_spark.AssetFilter = breez_sdk_spark.AssetFilterBitcoin

// Filter options
typeFilter := []breez_sdk_spark.PaymentType{
	breez_sdk_spark.PaymentTypeSend,
	breez_sdk_spark.PaymentTypeReceive,
}
statusFilter := []breez_sdk_spark.PaymentStatus{
	breez_sdk_spark.PaymentStatusCompleted,
}
fromTimestamp := uint64(1704067200) // Unix timestamp
toTimestamp := uint64(1735689600)   // Unix timestamp
offset := uint32(0)
limit := uint32(50)
sortAscending := false

request := breez_sdk_spark.ListPaymentsRequest{
	TypeFilter:    &typeFilter,    // Filter by payment type
	StatusFilter:  &statusFilter,  // Filter by status
	AssetFilter:   &assetFilter,   // Filter by asset (Bitcoin or Token)
	FromTimestamp: &fromTimestamp, // Time range filters
	ToTimestamp:   &toTimestamp,   // Time range filters
	Offset:        &offset,        // Pagination
	Limit:         &limit,         // Pagination
	SortAscending: &sortAscending, // Sort order (true = oldest first, false = newest first)
}
response, err := sdk.ListPayments(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payments := response.Payments
```

</section>

</custom-tabs>


<h2 id="get-payment">
    <a class="header" href="#get-payment">Get Payment</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.get_payment">API docs</a>
</h2>

You can also retrieve a single payment using the payment id:

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let payment_id = "<payment id>".to_string();
let response = sdk.get_payment(GetPaymentRequest { payment_id }).await?;
let payment = response.payment;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let paymentId = "<payment id>"
let response = try await sdk.getPayment(
    request: GetPaymentRequest(paymentId: paymentId)
)
let payment = response.payment
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val paymentId = "<payment id>";
    val response = sdk.getPayment(GetPaymentRequest(paymentId))
    val payment = response.payment
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var paymentId = "<payment id>";
var response = await sdk.GetPayment(
    request: new GetPaymentRequest(paymentId: paymentId)
);
var payment = response.payment;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const paymentId = '<payment id>'
const response = await sdk.getPayment({
  paymentId
})
const payment = response.payment
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const paymentId = '<payment id>'
const response = await sdk.getPayment({
  paymentId
})
const payment = response.payment
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String paymentId = "<payment id>";
GetPaymentRequest request = GetPaymentRequest(paymentId: paymentId);
GetPaymentResponse response = await sdk.getPayment(request: request);
Payment payment = response.payment;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
payment_id = "<payment id>"
response = await sdk.get_payment(
    request=GetPaymentRequest(payment_id=payment_id)
)
payment = response.payment
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
paymentId := "<payment id>"
request := breez_sdk_spark.GetPaymentRequest{
	PaymentId: paymentId,
}
response, err := sdk.GetPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payment := response.Payment
```

</section>

</custom-tabs>


# Claiming on-chain deposits

When receiving bitcoin through on-chain deposits, the SDK [automatically attempts](#setting-a-max-fee-for-automatic-claims) to claim these funds to make them available in your balance. However, if the maximum deposit claim fee is too low for claiming deposits, they won't be automatically claimed and should be [manually claimed](#manually-claiming-deposits).

## Setting a max fee for automatic claims

The [maximum deposit claim fee](config.md#max-deposit-claim-fee) setting in the SDK configuration defines the maximum fee the SDK uses when automatically claiming an on-chain deposit. The SDK's default fee limit is set to 1 sats/vbyte, which is low and requires manual claiming when fees exceed this threshold. You can set a higher fee, either in sats/vbyte, in absolute sats, or to the fastest recommended fee at the time of claim, with a leeway in sats/vbyte.

To increase the likelihood of automatically claiming deposits, you may set the maximum fee to the fastest recommended rate at the time of claim, which can result in higher fees.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Create the default config
let mut config = default_config(Network::Mainnet);
config.api_key = Some("<breez api key>".to_string());

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.max_deposit_claim_fee = Some(MaxFee::NetworkRecommended {
    leeway_sat_per_vbyte: 1,
});
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Create the default config
var config = defaultConfig(network: Network.mainnet)
config.apiKey = "<breez api key>"

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = MaxFee.networkRecommended(leewaySatPerVbyte: 1)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Create the default config
val config = defaultConfig(Network.MAINNET)
config.apiKey = "<breez api key>"

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = MaxFee.NetworkRecommended(leewaySatPerVbyte = 1u)
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Create the default config
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    apiKey = "<breez api key>"
};

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config = config with { maxDepositClaimFee = new MaxFee.NetworkRecommended(leewaySatPerVbyte: 1) };
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Create the default config
const config = defaultConfig('mainnet')
config.apiKey = '<breez api key>'

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = { type: 'networkRecommended', leewaySatPerVbyte: 1 }
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Create the default config
const config = defaultConfig(Network.Mainnet)
config.apiKey = '<breez api key>'

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = new MaxFee.NetworkRecommended({ leewaySatPerVbyte: BigInt(1) })
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Create the default config
var config = defaultConfig(network: Network.mainnet);
config = config.copyWith(apiKey: "<breez api key>");

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config = config.copyWith(
    maxDepositClaimFee:
        MaxFee.networkRecommended(leewaySatPerVbyte: BigInt.from(1)));
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Create the default config
config = default_config(network=Network.MAINNET)
config.api_key = "<breez api key>"

# Set the maximum fee to the fastest network recommended fee at the time of claim
# with a leeway of 1 sats/vbyte
config.max_deposit_claim_fee = MaxFee.NETWORK_RECOMMENDED(leeway_sat_per_vbyte=1)
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Create the default config
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
apiKey := "<breez api key>"
config.ApiKey = &apiKey

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
networkRecommendedInterface := breez_sdk_spark.MaxFee(breez_sdk_spark.MaxFeeNetworkRecommended{LeewaySatPerVbyte: 1})
config.MaxDepositClaimFee = &networkRecommendedInterface
```

</section>

</custom-tabs>


However, even when setting a high fee, the SDK might still fail to automatically claim deposits. In these cases, it's recommended to manually claim them by letting the end user accept the required fees. When [manual intervention](#manually-claiming-deposits) is required, the SDK emits an `UnclaimedDeposits` event containing information about the deposit. See [Listening to events](events.md) for how to subscribe to events.

## Manually claiming deposits

When a deposit cannot be automatically claimed due to the configured maximum fee being too low, you can manually claim it by specifying a higher fee limit. The recommended approach is to display a user interface showing the required fee amount and request user approval before proceeding with manual claiming.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
if let Some(DepositClaimError::MaxDepositClaimFeeExceeded {
    required_fee_sats, ..
}) = &deposit.claim_error
{
    // Show UI to user with the required fee and get approval
    let user_approved = true; // Replace with actual user approval logic

    if user_approved {
        let request = ClaimDepositRequest {
            txid: deposit.txid.clone(),
            vout: deposit.vout,
            max_fee: Some(MaxFee::Fixed {
                amount: *required_fee_sats,
            }),
        };
        sdk.claim_deposit(request).await?;
    }
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
if case .maxDepositClaimFeeExceeded(_, _, _, let requiredFeeSats, _) = deposit.claimError {
    // Show UI to user with the required fee and get approval
    let userApproved = true  // Replace with actual user approval logic

    if userApproved {
        let claimRequest = ClaimDepositRequest(
            txid: deposit.txid,
            vout: deposit.vout,
            maxFee: MaxFee.fixed(amount: requiredFeeSats)
        )
        try await sdk.claimDeposit(request: claimRequest)
    }
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val claimError = deposit.claimError
    if (claimError is DepositClaimError.MaxDepositClaimFeeExceeded) {
        val requiredFee = claimError.requiredFeeSats

        // Show UI to user with the required fee and get approval
        val userApproved = true // Replace with actual user approval logic

        if (userApproved) {
            val claimRequest = ClaimDepositRequest(
                txid = deposit.txid,
                vout = deposit.vout,
                maxFee = MaxFee.Fixed(requiredFee)
            )
            sdk.claimDeposit(claimRequest)
        }
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
if (deposit.claimError is DepositClaimError.MaxDepositClaimFeeExceeded exceeded)
{
    var requiredFee = exceeded.requiredFeeSats;

    // Show UI to user with the required fee and get approval
    var userApproved = true; // Replace with actual user approval logic

    if (userApproved)
    {
        var claimRequest = new ClaimDepositRequest(
            txid: deposit.txid,
            vout: deposit.vout,
            maxFee: new MaxFee.Fixed(amount: requiredFee)
        );
        await sdk.ClaimDeposit(request: claimRequest);
    }
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
if (deposit.claimError?.type === 'maxDepositClaimFeeExceeded') {
  const requiredFee = deposit.claimError.requiredFeeSats

  // Show UI to user with the required fee and get approval
  const userApproved = true // Replace with actual user approval logic

  if (userApproved) {
    const claimRequest: ClaimDepositRequest = {
      txid: deposit.txid,
      vout: deposit.vout,
      maxFee: { type: 'fixed', amount: requiredFee }
    }
    await sdk.claimDeposit(claimRequest)
  }
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
if (deposit.claimError?.tag === DepositClaimError_Tags.MaxDepositClaimFeeExceeded) {
  const requiredFee = deposit.claimError.inner.requiredFeeSats

  // Show UI to user with the required fee and get approval
  const userApproved = true // Replace with actual user approval logic

  if (userApproved) {
    const claimRequest: ClaimDepositRequest = {
      txid: deposit.txid,
      vout: deposit.vout,
      maxFee: new MaxFee.Fixed({ amount: requiredFee })
    }
    await sdk.claimDeposit(claimRequest)
  }
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final claimError = deposit.claimError;
if (claimError is DepositClaimError_MaxDepositClaimFeeExceeded) {
  final requiredFee = claimError.requiredFeeSats;

  // Show UI to user with the required fee and get approval
  bool userApproved = true; // Replace with actual user approval logic

  if (userApproved) {
    final claimRequest = ClaimDepositRequest(
      txid: deposit.txid,
      vout: deposit.vout,
      maxFee: MaxFee.fixed(amount: requiredFee),
    );
    await sdk.claimDeposit(request: claimRequest);
  }
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    if isinstance(
        deposit.claim_error, DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED
    ):
        required_fee = deposit.claim_error.required_fee_sats

        # Show UI to user with the required fee and get approval
        user_approved = True  # Replace with actual user approval logic

        if user_approved:
            claim_request = ClaimDepositRequest(
                txid=deposit.txid,
                vout=deposit.vout,
                max_fee=Fee.FIXED(amount=required_fee),
            )
            await sdk.claim_deposit(request=claim_request)
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
if claimErr := *deposit.ClaimError; claimErr != nil {
	if exceeded, ok := claimErr.(breez_sdk_spark.DepositClaimErrorMaxDepositClaimFeeExceeded); ok {
		requiredFee := exceeded.RequiredFeeSats

		// Show UI to user with the required fee and get approval
		userApproved := true // Replace with actual user approval logic

		if userApproved {
			maxFee := breez_sdk_spark.MaxFee(breez_sdk_spark.MaxFeeFixed{Amount: requiredFee})
			claimRequest := breez_sdk_spark.ClaimDepositRequest{
				Txid:   deposit.Txid,
				Vout:   deposit.Vout,
				MaxFee: &maxFee,
			}
			_, err := sdk.ClaimDeposit(claimRequest)
			if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
				return err
			}
		}
	}
}
```

</section>

</custom-tabs>


## Listing unclaimed deposits

Retrieve all deposits that have not yet been claimed, including the specific reason why each deposit is unclaimed.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let request = ListUnclaimedDepositsRequest {};
let response = sdk.list_unclaimed_deposits(request).await?;

for deposit in response.deposits {
    info!("Unclaimed deposit: {}:{}", deposit.txid, deposit.vout);
    info!("Amount: {} sats", deposit.amount_sats);

    if let Some(claim_error) = &deposit.claim_error {
        match claim_error {
            DepositClaimError::MaxDepositClaimFeeExceeded {
                max_fee,
                required_fee_sats,
                required_fee_rate_sat_per_vbyte,
                ..
            } => {
                info!(
                    "Max claim fee exceeded. Max: {:?}, Required: {} sats or {} sats/vByte",
                    max_fee, required_fee_sats, required_fee_rate_sat_per_vbyte
                );
            }
            DepositClaimError::MissingUtxo { .. } => {
                info!("UTXO not found when claiming deposit");
            }
            DepositClaimError::Generic { message } => {
                info!("Claim failed: {}", message);
            }
        }
    }
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let request = ListUnclaimedDepositsRequest()
let response = try await sdk.listUnclaimedDeposits(request: request)

for deposit in response.deposits {
    print("Unclaimed deposit: \(deposit.txid):\(deposit.vout)")
    print("Amount: \(deposit.amountSats) sats")

    if let claimError = deposit.claimError {
        switch claimError {
        case .maxDepositClaimFeeExceeded(
            let tx, let vout, let maxFee, let requiredFeeSats, let requiredFeeRateSatPerVbyte):
            let maxFeeStr: String
            if let maxFee = maxFee {
                switch maxFee {
                case .fixed(let amount):
                    maxFeeStr = "\(amount) sats"
                case .rate(let satPerVbyte):
                    maxFeeStr = "\(satPerVbyte) sats/vByte"
                }
            } else {
                maxFeeStr = "none"
            }
            print(
                "Max claim fee exceeded. Max: \(maxFeeStr), Required: \(requiredFeeSats) sats or \(requiredFeeRateSatPerVbyte) sats/vByte"
            )
        case .missingUtxo(let tx, let vout):
            print("UTXO not found when claiming deposit")
        case .generic(let message):
            print("Claim failed: \(message)")
        }
    }
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val request = ListUnclaimedDepositsRequest
    val response = sdk.listUnclaimedDeposits(request)

    for (deposit in response.deposits) {
        // Log.v("Breez", "Unclaimed deposit: ${deposit.txid}:${deposit.vout}")
        // Log.v("Breez", "Amount: ${deposit.amountSats} sats")

        deposit.claimError?.let { claimError ->
            when (claimError) {
                is DepositClaimError.MaxDepositClaimFeeExceeded -> {
                    val maxFee = claimError.maxFee
                    val maxFeeStr = when (maxFee) {
                        is Fee.Fixed -> "${maxFee.amount} sats"
                        is Fee.Rate -> "${maxFee.satPerVbyte} sats/vByte"
                        null -> "none"
                    }
                    // Log.v("Breez", "Max claim fee exceeded. Max: $maxFeeStr, Required: ${claimError.requiredFeeSats} sats or ${claimError.requiredFeeRateSatPerVbyte} sats/vByte")
                }
                is DepositClaimError.MissingUtxo -> {
                    // Log.v("Breez", "UTXO not found when claiming deposit")
                }
                is DepositClaimError.Generic -> {
                    // Log.v("Breez", "Claim failed: ${claimError.message}")
                }
            }
        }
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var request = new ListUnclaimedDepositsRequest();
var response = await sdk.ListUnclaimedDeposits(request: request);

foreach (var deposit in response.deposits)
{
    Console.WriteLine($"Unclaimed deposit: {deposit.txid}:{deposit.vout}");
    Console.WriteLine($"Amount: {deposit.amountSats} sats");

    if (deposit.claimError != null)
    {
        if (deposit.claimError is DepositClaimError.MaxDepositClaimFeeExceeded exceeded)
        {
            var maxFeeStr = "none";
            if (exceeded.maxFee != null)
            {
                if (exceeded.maxFee is Fee.Fixed fixedFee)
                {
                    maxFeeStr = $"{fixedFee.amount} sats";
                }
                else if (exceeded.maxFee is Fee.Rate rateFee)
                {
                    maxFeeStr = $"{rateFee.satPerVbyte} sats/vByte";
                }
            }
            Console.WriteLine($"Claim failed: Fee exceeded. Max: {maxFeeStr}, " +
                            $"Required: {exceeded.requiredFeeSats} sats or {exceeded.requiredFeeRateSatPerVbyte} sats/vByte");
        }
        else if (deposit.claimError is DepositClaimError.MissingUtxo)
        {
            Console.WriteLine("Claim failed: UTXO not found");
        }
        else if (deposit.claimError is DepositClaimError.Generic generic)
        {
            Console.WriteLine($"Claim failed: {generic.message}");
        }
    }
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const request: ListUnclaimedDepositsRequest = {}
const response = await sdk.listUnclaimedDeposits(request)

for (const deposit of response.deposits) {
  console.log(`Unclaimed deposit: ${deposit.txid}:${deposit.vout}`)
  console.log(`Amount: ${deposit.amountSats} sats`)

  if (deposit.claimError != null) {
    switch (deposit.claimError.type) {
      case 'maxDepositClaimFeeExceeded': {
        let maxFeeStr = 'none'
        if (deposit.claimError.maxFee != null) {
          if (deposit.claimError.maxFee.type === 'fixed') {
            maxFeeStr = `${deposit.claimError.maxFee.amount} sats`
          } else if (deposit.claimError.maxFee.type === 'rate') {
            maxFeeStr = `${deposit.claimError.maxFee.satPerVbyte} sats/vByte`
          }
        }
        console.log(
          `Max claim fee exceeded. Max: ${maxFeeStr}, Required: ${deposit.claimError.requiredFeeSats} sats or ${deposit.claimError.requiredFeeRateSatPerVbyte} sats/vByte`
        )
        break
      }
      case 'missingUtxo':
        console.log('UTXO not found when claiming deposit')
        break
      case 'generic':
        console.log(`Claim failed: ${deposit.claimError.message}`)
        break
    }
  }
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const request: ListUnclaimedDepositsRequest = {}
const response = await sdk.listUnclaimedDeposits(request)

for (const deposit of response.deposits) {
  console.log(`Unclaimed deposit: ${deposit.txid}:${deposit.vout}`)
  console.log(`Amount: ${deposit.amountSats} sats`)

  if (deposit.claimError != null) {
    if (deposit.claimError?.tag === DepositClaimError_Tags.MaxDepositClaimFeeExceeded) {
      let maxFeeStr = 'none'
      if (deposit.claimError.inner.maxFee != null) {
        if (deposit.claimError.inner.maxFee.tag === Fee_Tags.Fixed) {
          maxFeeStr = `${deposit.claimError.inner.maxFee.inner.amount} sats`
        } else if (deposit.claimError.inner.maxFee.tag === Fee_Tags.Rate) {
          maxFeeStr = `${deposit.claimError.inner.maxFee.inner.satPerVbyte} sats/vByte`
        }
      }
      console.log(
        `Max claim fee exceeded. Max: ${maxFeeStr}, 
        Required: ${deposit.claimError.inner.requiredFeeSats} sats 
        or ${deposit.claimError.inner.requiredFeeRateSatPerVbyte} sats/vByte`
      )
    } else if (deposit.claimError?.tag === DepositClaimError_Tags.MissingUtxo) {
      console.log('UTXO not found when claiming deposit')
    } else if (deposit.claimError?.tag === DepositClaimError_Tags.Generic) {
      console.log(`Claim failed: ${deposit.claimError.inner.message}`)
    }
  }
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final request = ListUnclaimedDepositsRequest();
final response = await sdk.listUnclaimedDeposits(request: request);

for (DepositInfo deposit in response.deposits) {
  print("Unclaimed deposit: ${deposit.txid}:${deposit.vout}");
  print("Amount: ${deposit.amountSats} sats");

  final claimError = deposit.claimError;
  if (claimError is DepositClaimError_MaxDepositClaimFeeExceeded) {
    final maxFeeStr = claimError.maxFee != null
        ? (claimError.maxFee is Fee_Fixed
            ? '${(claimError.maxFee as Fee_Fixed).amount} sats'
            : '${(claimError.maxFee as Fee_Rate).satPerVbyte} sats/vByte')
        : 'none';
    print(
        "Max claim fee exceeded. Max: $maxFeeStr, Required: ${claimError.requiredFeeSats} sats or ${claimError.requiredFeeRateSatPerVbyte} sats/vByte");
  } else if (claimError is DepositClaimError_MissingUtxo) {
    print("UTXO not found when claiming deposit");
  } else if (claimError is DepositClaimError_Generic) {
    print("Claim failed: ${claimError.message}");
  }
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    request = ListUnclaimedDepositsRequest()
    response = await sdk.list_unclaimed_deposits(request=request)

    for deposit in response.deposits:
        logging.info(f"Unclaimed deposit: {deposit.txid}:{deposit.vout}")
        logging.info(f"Amount: {deposit.amount_sats} sats")

        if deposit.claim_error:
            if isinstance(
                deposit.claim_error, DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED
            ):
                max_fee_str = "none"
                if deposit.claim_error.max_fee is not None:
                    if isinstance(deposit.claim_error.max_fee, Fee.FIXED):
                        max_fee_str = f"{deposit.claim_error.max_fee.amount} sats"
                    elif isinstance(deposit.claim_error.max_fee, Fee.RATE):
                        max_fee_str = f"{deposit.claim_error.max_fee.sat_per_vbyte} sats/vByte"
                logging.info(
                    f"Claim failed: Fee exceeded. Max: {max_fee_str}, "
                    f"Required: {deposit.claim_error.required_fee_sats} sats "
                    f"or {deposit.claim_error.required_fee_rate_sat_per_vbyte} sats/vByte"
                )
            elif isinstance(deposit.claim_error, DepositClaimError.MISSING_UTXO):
                logging.info("Claim failed: UTXO not found")
            elif isinstance(deposit.claim_error, DepositClaimError.GENERIC):
                logging.info(f"Claim failed: {deposit.claim_error.message}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.ListUnclaimedDepositsRequest{}
response, err := sdk.ListUnclaimedDeposits(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

for _, deposit := range response.Deposits {
	log.Printf("Unclaimed Deposit: %v:%v", deposit.Txid, deposit.Vout)
	log.Printf("Amount: %v sats", deposit.AmountSats)

	if claimErr := *deposit.ClaimError; claimErr != nil {
		switch claimErr := claimErr.(type) {
		case breez_sdk_spark.DepositClaimErrorMaxDepositClaimFeeExceeded:
			maxFeeStr := "none"
			if claimErr.MaxFee != nil {
				switch fee := (*claimErr.MaxFee).(type) {
				case breez_sdk_spark.FeeFixed:
					maxFeeStr = fmt.Sprintf("%v sats", fee.Amount)
				case breez_sdk_spark.FeeRate:
					maxFeeStr = fmt.Sprintf("%v sats/vByte", fee.SatPerVbyte)
				}
			}
			log.Printf("Max claim fee exceeded. Max: %v, Required: %v sats or %v sats/vByte", maxFeeStr, claimErr.RequiredFeeSats, claimErr.RequiredFeeRateSatPerVbyte)
		case breez_sdk_spark.DepositClaimErrorMissingUtxo:
			log.Print("UTXO not found when claiming deposit")
		case breez_sdk_spark.DepositClaimErrorGeneric:
			log.Printf("Claim failed: %v", claimErr.Message)
		}
	}
}
```

</section>

</custom-tabs>


## Refunding deposits

When a deposit cannot be successfully claimed you can refund it to an external Bitcoin address. This creates a transaction that sends the amount (minus transaction fees) to the specified destination address.

The [recommended fees](#recommended-fees) API is useful for determining appropriate fee levels for refund transactions.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let txid = "your_deposit_txid".to_string();
let vout = 0;
let destination_address = "bc1qexample...".to_string(); // Your Bitcoin address

// Set the fee for the refund transaction using the half-hour feerate
let recommended_fees = sdk.recommended_fees().await?;
let fee = Fee::Rate { sat_per_vbyte: recommended_fees.half_hour_fee };
// or using a fixed amount
//let fee = Fee::Fixed { amount: 500 };

let request = RefundDepositRequest {
    txid,
    vout,
    destination_address,
    fee,
};

let response = sdk.refund_deposit(request).await?;
info!("Refund transaction created:");
info!("Transaction ID: {}", response.tx_id);
info!("Transaction hex: {}", response.tx_hex);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let txid = "your_deposit_txid"
let vout: UInt32 = 0
let destinationAddress = "bc1qexample..."  // Your Bitcoin address

// Set the fee for the refund transaction using the half-hour feerate
let recommendedFees = try await sdk.recommendedFees()
let fee = Fee.rate(satPerVbyte: recommendedFees.halfHourFee)
// or using a fixed amount
//let fee = Fee.fixed(amount: 500) // 500 sats

let request = RefundDepositRequest(
    txid: txid,
    vout: vout,
    destinationAddress: destinationAddress,
    fee: fee
)

let response = try await sdk.refundDeposit(request: request)
print("Refund transaction created:")
print("Transaction ID: \(response.txId)")
print("Transaction hex: \(response.txHex)")
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val txid = "your_deposit_txid"
    val vout = 0u
    val destinationAddress = "bc1qexample..." // Your Bitcoin address

    // Set the fee for the refund transaction using the half-hour feerate
    val recommendedFees = sdk.recommendedFees()
    val fee = Fee.Rate(recommendedFees.halfHourFee)
    // or using a fixed amount
    //val fee = Fee.Fixed(500u)

    val request = RefundDepositRequest(
        txid = txid,
        vout = vout,
        destinationAddress = destinationAddress,
        fee = fee
    )

    val response = sdk.refundDeposit(request)
    // Log.v("Breez", "Refund transaction created:")
    // Log.v("Breez", "Transaction ID: ${response.txId}")
    // Log.v("Breez", "Transaction hex: ${response.txHex}")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var txid = "your_deposit_txid";
var vout = 0U;
var destinationAddress = "bc1qexample...";  // Your Bitcoin address

// Set the fee for the refund transaction using the half-hour feerate
var recommendedFees = await sdk.RecommendedFees();
var fee = new Fee.Rate(satPerVbyte: recommendedFees.halfHourFee);
// or using a fixed amount
//var fee = new Fee.Fixed(amount: 500);

var request = new RefundDepositRequest(
    txid: txid,
    vout: vout,
    destinationAddress: destinationAddress,
    fee: fee
);

var response = await sdk.RefundDeposit(request: request);
Console.WriteLine("Refund transaction created:");
Console.WriteLine($"Transaction ID: {response.txId}");
Console.WriteLine($"Transaction hex: {response.txHex}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const txid = 'your_deposit_txid'
const vout = 0
const destinationAddress = 'bc1qexample...' // Your Bitcoin address

// Set the fee for the refund transaction using the half-hour feerate
const recommendedFees = await sdk.recommendedFees()
const fee: Fee = { type: 'rate', satPerVbyte: recommendedFees.halfHourFee }
// or using a fixed amount
// const fee: Fee = { type: 'fixed', amount: 500 }

const request: RefundDepositRequest = {
  txid,
  vout,
  destinationAddress,
  fee
}

const response = await sdk.refundDeposit(request)
console.log('Refund transaction created:')
console.log('Transaction ID:', response.txId)
console.log('Transaction hex:', response.txHex)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const txid = 'your_deposit_txid'
const vout = 0
const destinationAddress = 'bc1qexample...' // Your Bitcoin address

// Set the fee for the refund transaction using the half-hour feerate
const recommendedFees = await sdk.recommendedFees()
const fee = new Fee.Rate({ satPerVbyte: recommendedFees.halfHourFee })
// or using a fixed amount
// const fee = new Fee.Fixed({ amount: BigInt(500) })

const request: RefundDepositRequest = {
  txid,
  vout,
  destinationAddress,
  fee
}

const response = await sdk.refundDeposit(request)
console.log('Refund transaction created:')
console.log('Transaction ID:', response.txId)
console.log('Transaction hex:', response.txHex)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String txid = "your_deposit_txid";
int vout = 0;
String destinationAddress = "bc1qexample..."; // Your Bitcoin address

// Set the fee for the refund transaction using the half-hour feerate
final recommendedFees = await sdk.recommendedFees();
Fee fee = Fee.rate(satPerVbyte: recommendedFees.halfHourFee);
// or using a fixed amount
//Fee fee = Fee.fixed(amount: BigInt.from(500));

final request = RefundDepositRequest(
  txid: txid,
  vout: vout,
  destinationAddress: destinationAddress,
  fee: fee,
);

final response = await sdk.refundDeposit(request: request);
print("Refund transaction created:");
print("Transaction ID: ${response.txId}");
print("Transaction hex: ${response.txHex}");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    txid = "your_deposit_txid"
    vout = 0
    destination_address = "bc1qexample..."  # Your Bitcoin address

    # Set the fee for the refund transaction using the half-hour feerate
    recommended_fees = await sdk.recommended_fees()
    fee = Fee.RATE(sat_per_vbyte=recommended_fees.half_hour_fee)
    # or using a fixed amount
    #fee = Fee.FIXED(amount=500)

    request = RefundDepositRequest(
        txid=txid, vout=vout, destination_address=destination_address, fee=fee
    )

    response = await sdk.refund_deposit(request=request)
    logging.info("Refund transaction created:")
    logging.info(f"Transaction ID: {response.tx_id}")
    logging.info(f"Transaction hex: {response.tx_hex}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
txid := "<your_deposit_txid>"
vout := uint32(0)
destinationAddress := "bc1qexample..." // Your Bitcoin address

// Set the fee for the refund transaction using the half-hour feerate
recommendedFees, err := sdk.RecommendedFees()
if err != nil {
	return err
}
fee := breez_sdk_spark.Fee(breez_sdk_spark.FeeRate{SatPerVbyte: recommendedFees.HalfHourFee})
// or using a fixed amount
//fee := breez_sdk_spark.Fee(breez_sdk_spark.FeeFixed{Amount: 500})

request := breez_sdk_spark.RefundDepositRequest{
	Txid:               txid,
	Vout:               vout,
	DestinationAddress: destinationAddress,
	Fee:                fee,
}
response, err := sdk.RefundDeposit(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

log.Print("Refund transaction created:")
log.Printf("Transaction ID: %v", response.TxId)
log.Printf("Transaction hex: %v", response.TxHex)
```

</section>

</custom-tabs>


## Implementing a custom claim logic

For advanced use cases, you may want to implement a custom claim logic instead of relying on the SDK's automatic process. This gives you complete control over when and how deposits are claimed.

To disable automatic claims, unset the [maximum deposit claim fee](config.md#max-deposit-claim-fee). Then use the methods described above to manually claim deposits based on your business logic.

Common scenarios for custom claiming logic include:

- **Dynamic fee adjustment**: Adjust claiming fees based on market conditions or priority
- **Conditional claiming**: Only claim deposits that meet certain criteria (amount thresholds, time windows, etc.)
- **Integration with external systems**: Coordinate claims with other business processes

The [recommended fees](#recommended-fees) API is useful for determining appropriate fee levels for claiming deposits. For example, you can implement a custom claim logic to only claim deposits if the required fee rate is less than the fastest recommended fee (or any other).

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
if let Some(DepositClaimError::MaxDepositClaimFeeExceeded {
    required_fee_rate_sat_per_vbyte, ..
}) = &deposit.claim_error
{
    let recommended_fees = sdk.recommended_fees().await?;

    if *required_fee_rate_sat_per_vbyte <= recommended_fees.fastest_fee {
        let request = ClaimDepositRequest {
            txid: deposit.txid.clone(),
            vout: deposit.vout,
            max_fee: Some(MaxFee::Rate {
                sat_per_vbyte: *required_fee_rate_sat_per_vbyte,
            }),
        };
        sdk.claim_deposit(request).await?;
    }
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
if case .maxDepositClaimFeeExceeded(_, _, _, _, let requiredFeeRateSatPerVbyte) = deposit.claimError {
    let recommendedFees = try await sdk.recommendedFees()

    if requiredFeeRateSatPerVbyte <= recommendedFees.fastestFee {
        let claimRequest = ClaimDepositRequest(
            txid: deposit.txid,
            vout: deposit.vout,
            maxFee: MaxFee.rate(satPerVbyte: requiredFeeRateSatPerVbyte)
        )
        try await sdk.claimDeposit(request: claimRequest)
    }
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val claimError = deposit.claimError
    if (claimError is DepositClaimError.MaxDepositClaimFeeExceeded) {
        val requiredFeeRate = claimError.requiredFeeRateSatPerVbyte

        val recommendedFees = sdk.recommendedFees()

        if (requiredFeeRate <= recommendedFees.fastestFee) {
            val claimRequest = ClaimDepositRequest(
                txid = deposit.txid,
                vout = deposit.vout,
                maxFee = MaxFee.Rate(requiredFeeRate)
            )
            sdk.claimDeposit(claimRequest)
        }
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
if (deposit.claimError is DepositClaimError.MaxDepositClaimFeeExceeded exceeded)
{
    var requiredFeeRate = exceeded.requiredFeeRateSatPerVbyte;

    var recommendedFees = await sdk.RecommendedFees();

    if (requiredFeeRate <= recommendedFees.fastestFee)
    {
        var claimRequest = new ClaimDepositRequest(
            txid: deposit.txid,
            vout: deposit.vout,
            maxFee: new MaxFee.Rate(satPerVbyte: requiredFeeRate)
        );
        await sdk.ClaimDeposit(request: claimRequest);
    }
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
if (deposit.claimError?.type === 'maxDepositClaimFeeExceeded') {
  const requiredFeeRate = deposit.claimError.requiredFeeRateSatPerVbyte

  const recommendedFees = await sdk.recommendedFees()

  if (requiredFeeRate <= recommendedFees.fastestFee) {
    const claimRequest: ClaimDepositRequest = {
      txid: deposit.txid,
      vout: deposit.vout,
      maxFee: { type: 'rate', satPerVbyte: requiredFeeRate }
    }
    await sdk.claimDeposit(claimRequest)
  }
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
if (deposit.claimError?.tag === DepositClaimError_Tags.MaxDepositClaimFeeExceeded) {
  const requiredFeeRate = deposit.claimError.inner.requiredFeeRateSatPerVbyte

  const recommendedFees = await sdk.recommendedFees()

  if (requiredFeeRate <= recommendedFees.fastestFee) {
    const claimRequest: ClaimDepositRequest = {
      txid: deposit.txid,
      vout: deposit.vout,
      maxFee: new MaxFee.Rate({ satPerVbyte: requiredFeeRate })
    }
    await sdk.claimDeposit(claimRequest)
  }
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final claimError = deposit.claimError;
if (claimError is DepositClaimError_MaxDepositClaimFeeExceeded) {
  final requiredFeeRate = claimError.requiredFeeRateSatPerVbyte;

  final recommendedFees = await sdk.recommendedFees();

  if (requiredFeeRate <= recommendedFees.fastestFee) {
    final claimRequest = ClaimDepositRequest(
      txid: deposit.txid,
      vout: deposit.vout,
      maxFee: MaxFee.rate(satPerVbyte: requiredFeeRate),
    );
    await sdk.claimDeposit(request: claimRequest);
  }
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    if isinstance(
        deposit.claim_error, DepositClaimError.MAX_DEPOSIT_CLAIM_FEE_EXCEEDED
    ):
        required_fee_rate = deposit.claim_error.required_fee_rate_sat_per_vbyte

        recommended_fees = await sdk.recommended_fees()

        if required_fee_rate <= recommended_fees.fastest_fee:
            claim_request = ClaimDepositRequest(
                txid=deposit.txid,
                vout=deposit.vout,
                max_fee=MaxFee.RATE(sat_per_vbyte=required_fee_rate),
            )
            await sdk.claim_deposit(request=claim_request)
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
if claimErr := *deposit.ClaimError; claimErr != nil {
	if exceeded, ok := claimErr.(breez_sdk_spark.DepositClaimErrorMaxDepositClaimFeeExceeded); ok {
		requiredFeeRate := exceeded.RequiredFeeRateSatPerVbyte

		recommendedFees, err := sdk.RecommendedFees()
		if err != nil {
			return err
		}

		if requiredFeeRate <= recommendedFees.FastestFee {
			maxFee := breez_sdk_spark.MaxFee(breez_sdk_spark.MaxFeeRate{SatPerVbyte: requiredFeeRate})
			claimRequest := breez_sdk_spark.ClaimDepositRequest{
				Txid:   deposit.Txid,
				Vout:   deposit.Vout,
				MaxFee: &maxFee,
			}
			_, err := sdk.ClaimDeposit(claimRequest)
			if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
				return err
			}
		}
	}
}
```

</section>

</custom-tabs>


## Recommended fees

Get Bitcoin fee estimates for different confirmation targets to help determine appropriate fee levels for claiming or refunding deposits.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let response = sdk.recommended_fees().await?;
info!("Fastest fee: {} sats/vByte", response.fastest_fee);
info!("Half-hour fee: {} sats/vByte", response.half_hour_fee);
info!("Hour fee: {} sats/vByte", response.hour_fee);
info!("Economy fee: {} sats/vByte", response.economy_fee);
info!("Minimum fee: {} sats/vByte", response.minimum_fee);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let response = try await sdk.recommendedFees()
print("Fastest fee: \(response.fastestFee) sats/vByte")
print("Half-hour fee: \(response.halfHourFee) sats/vByte")
print("Hour fee: \(response.hourFee) sats/vByte")
print("Economy fee: \(response.economyFee) sats/vByte")
print("Minimum fee: \(response.minimumFee) sats/vByte")
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val response = sdk.recommendedFees()
println("Fastest fee: ${response.fastestFee} sats/vByte")
println("Half-hour fee: ${response.halfHourFee} sats/vByte")
println("Hour fee: ${response.hourFee} sats/vByte")
println("Economy fee: ${response.economyFee} sats/vByte")
println("Minimum fee: ${response.minimumFee} sats/vByte")
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var response = await sdk.RecommendedFees();
    Console.WriteLine($"Fastest fee: {response.fastestFee} sats/vByte");
    Console.WriteLine($"Half-hour fee: {response.halfHourFee} sats/vByte");
    Console.WriteLine($"Hour fee: {response.hourFee} sats/vByte");
    Console.WriteLine($"Economy fee: {response.economyFee} sats/vByte");
    Console.WriteLine($"Minimum fee: {response.minimumFee} sats/vByte");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.recommendedFees()
console.log('Fastest fee:', response.fastestFee, 'sats/vByte')
console.log('Half-hour fee:', response.halfHourFee, 'sats/vByte')
console.log('Hour fee:', response.hourFee, 'sats/vByte')
console.log('Economy fee:', response.economyFee, 'sats/vByte')
console.log('Minimum fee:', response.minimumFee, 'sats/vByte')
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const response = await sdk.recommendedFees()
console.log('Fastest fee:', response.fastestFee, 'sats/vByte')
console.log('Half-hour fee:', response.halfHourFee, 'sats/vByte')
console.log('Hour fee:', response.hourFee, 'sats/vByte')
console.log('Economy fee:', response.economyFee, 'sats/vByte')
console.log('Minimum fee:', response.minimumFee, 'sats/vByte')
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final response = await sdk.recommendedFees();
print("Fastest fee: ${response.fastestFee} sats/vByte");
print("Half-hour fee: ${response.halfHourFee} sats/vByte");
print("Hour fee: ${response.hourFee} sats/vByte");
print("Economy fee: ${response.economyFee} sats/vByte");
print("Minimum fee: ${response.minimumFee} sats/vByte");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
response = await sdk.recommended_fees()
logging.info(f"Fastest fee: {response.fastest_fee} sats/vByte")
logging.info(f"Half-hour fee: {response.half_hour_fee} sats/vByte")
logging.info(f"Hour fee: {response.hour_fee} sats/vByte")
logging.info(f"Economy fee: {response.economy_fee} sats/vByte")
logging.info(f"Minimum fee: {response.minimum_fee} sats/vByte")
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
response, err := sdk.RecommendedFees()
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}
log.Printf("Fastest fee: %v sats/vByte", response.FastestFee)
log.Printf("Half-hour fee: %v sats/vByte", response.HalfHourFee)
log.Printf("Hour fee: %v sats/vByte", response.HourFee)
log.Printf("Economy fee: %v sats/vByte", response.EconomyFee)
log.Printf("Minimum fee: %v sats/vByte", response.MinimumFee)
```

</section>

</custom-tabs>


# Using LNURL and Lightning addresses

The Breez SDK - Nodeless *(Spark Implementation)* supports the following <a target="_blank" href="https://github.com/lnurl/luds">LNURL</a> functionality:

- **[Sending payments using LNURL-Pay/Lightning address]** (including BIP353 addresses)
- **[Receiving payments using LNURL-Pay/Lightning address]**
- **[Receiving payments using LNURL-Withdraw]**
- **[Using LNURL-Auth]**

[Sending payments using LNURL-Pay/Lightning address]: lnurl_pay.md
[Receiving payments using LNURL-Pay/Lightning address]: receive_lnurl_pay.md
[Receiving payments using LNURL-Withdraw]: lnurl_withdraw.md
[Using LNURL-Auth]: lnurl_auth.md

<h1 id="lnurl-pay">
    <a class="header" href="#lnurl-pay">Sending payments using LNURL-Pay and Lightning address</a>
</h1>

<h2 id="preparing-lnurl-payments">
    <a class="header" href="#preparing-lnurl-payments">Preparing LNURL Payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.prepare_lnurl_pay">API docs</a>
</h2>

During the prepare step, the SDK ensures that the inputs are valid with respect to the LNURL-pay request,
and also returns the fees related to the payment so they can be confirmed.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Endpoint can also be of the form:
// lnurlp://domain.com/lnurl-pay?key=val
// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf
let lnurl_pay_url = "lightning@address.com";

if let Ok(InputType::LightningAddress(details)) = sdk.parse(lnurl_pay_url).await {
    let amount_sats = 5_000;
    let optional_comment = Some("<comment>".to_string());
    let optional_validate_success_action_url = Some(true);

    let prepare_response = sdk
        .prepare_lnurl_pay(PrepareLnurlPayRequest {
            amount_sats,
            pay_request: details.pay_request,
            comment: optional_comment,
            validate_success_action_url: optional_validate_success_action_url,
        })
        .await?;

    // If the fees are acceptable, continue to create the LNURL Pay
    let fee_sats = prepare_response.fee_sats;
    info!("Fees: {fee_sats} sats");
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Endpoint can also be of the form:
// lnurlp://domain.com/lnurl-pay?key=val
// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf
let lnurlPayUrl = "lightning@address.com"

let inputType = try await sdk.parse(input: lnurlPayUrl)
if case .lightningAddress(v1: let details) = inputType {
    let amountSats: UInt64 = 5_000
    let optionalComment = "<comment>"
    let payRequest = details.payRequest
    let optionalValidateSuccessActionUrl = true

    let request = PrepareLnurlPayRequest(
        amountSats: amountSats,
        payRequest: payRequest,
        comment: optionalComment,
        validateSuccessActionUrl: optionalValidateSuccessActionUrl
    )
    let response = try await sdk.prepareLnurlPay(request: request)

    // If the fees are acceptable, continue to create the LNURL Pay
    let feesSat = response.feeSats
    print("Fees: \(feesSat) sats")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Endpoint can also be of the form:
// lnurlp://domain.com/lnurl-pay?key=val
// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf
val lnurlPayUrl = "lightning@address.com"
try {
    val inputType = sdk.parse(lnurlPayUrl)
    if (inputType is InputType.LightningAddress) {
        val amountSats = 5_000.toULong()
        val optionalComment = "<comment>"
        val payRequest = inputType.v1.payRequest
        val optionalValidateSuccessActionUrl = true

        val req = PrepareLnurlPayRequest(
            amountSats,
            payRequest,
            optionalComment,
            optionalValidateSuccessActionUrl
        )
        val prepareResponse = sdk.prepareLnurlPay(req)

        // If the fees are acceptable, continue to create the LNURL Pay
        val feeSats = prepareResponse.feeSats;
        // Log.v("Breez", "Fees: ${feeSats} sats")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Endpoint can also be of the form:
// lnurlp://domain.com/lnurl-pay?key=val
// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43r
//     vv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3k
//     vdnxx5crxwpjvyunsephsz36jf
var lnurlPayUrl = "lightning@address.com";
var parsedInput = await sdk.Parse(lnurlPayUrl);
if (parsedInput is InputType.LightningAddress lightningAddress)
{
    var details = lightningAddress.v1;
    var amountSats = 5_000UL;
    var optionalComment = "<comment>";
    var payRequest = details.payRequest;
    var optionalValidateSuccessActionUrl = true;

    var request = new PrepareLnurlPayRequest(
        amountSats: amountSats,
        payRequest: payRequest,
        comment: optionalComment,
        validateSuccessActionUrl: optionalValidateSuccessActionUrl
    );
    var prepareResponse = await sdk.PrepareLnurlPay(request: request);

    // If the fees are acceptable, continue to create the LNURL Pay
    var feeSats = prepareResponse.feeSats;
    Console.WriteLine($"Fees: {feeSats} sats");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Endpoint can also be of the
// lnurlp://domain.com/lnurl-pay?key=val
// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf
const lnurlPayUrl = 'lightning@address.com'

const input = await sdk.parse(lnurlPayUrl)
if (input.type === 'lightningAddress') {
  const amountSats = 5_000
  const optionalComment = '<comment>'
  const payRequest = input.payRequest
  const optionalValidateSuccessActionUrl = true

  const prepareResponse = await sdk.prepareLnurlPay({
    amountSats,
    payRequest,
    comment: optionalComment,
    validateSuccessActionUrl: optionalValidateSuccessActionUrl
  })

  // If the fees are acceptable, continue to create the LNURL Pay
  const feeSats = prepareResponse.feeSats
  console.log(`Fees: ${feeSats} sats`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Endpoint can also be of the
// lnurlp://domain.com/lnurl-pay?key=val
// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf
const lnurlPayUrl = 'lightning@address.com'

const input = await sdk.parse(lnurlPayUrl)
if (input.tag === InputType_Tags.LightningAddress) {
  const amountSats = BigInt(5_000)
  const optionalComment = '<comment>'
  const payRequest = input.inner[0].payRequest
  const optionalValidateSuccessActionUrl = true

  const prepareResponse = await sdk.prepareLnurlPay({
    amountSats,
    payRequest,
    comment: optionalComment,
    validateSuccessActionUrl: optionalValidateSuccessActionUrl
  })

  // If the fees are acceptable, continue to create the LNURL Pay
  const feeSats = prepareResponse.feeSats
  console.log(`Fees: ${feeSats} sats`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
/// Endpoint can also be of the form:
/// lnurlp://domain.com/lnurl-pay?key=val
/// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf
String lnurlPayUrl = "lightning@address.com";

InputType inputType = await sdk.parse(input: lnurlPayUrl);
if (inputType is InputType_LightningAddress) {
  BigInt amountSats = BigInt.from(5000);
  String optionalComment = "<comment>";
  bool optionalValidateSuccessActionUrl = true;

  PrepareLnurlPayRequest request = PrepareLnurlPayRequest(
    amountSats: amountSats,
    payRequest: inputType.field0.payRequest,
    comment: optionalComment,
    validateSuccessActionUrl: optionalValidateSuccessActionUrl,
  );
  PrepareLnurlPayResponse prepareResponse =
      await sdk.prepareLnurlPay(request: request);

  // If the fees are acceptable, continue to create the LNURL Pay
  BigInt feeSats = prepareResponse.feeSats;
  print("Fees: $feeSats sats");
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Endpoint can also be of the form:
# lnurlp://domain.com/lnurl-pay?key=val
# lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43r
#     vv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3k
#     vdnxx5crxwpjvyunsephsz36jf
lnurl_pay_url = "lightning@address.com"
try:
    parsed_input = await sdk.parse(lnurl_pay_url)
    if isinstance(parsed_input, InputType.LIGHTNING_ADDRESS):
        details = parsed_input[0]

        request = PrepareLnurlPayRequest(
            amount_sats=5_000,
            pay_request=details.pay_request,
            comment="<comment>",
            validate_success_action_url=True,
        )
        prepare_response = await sdk.prepare_lnurl_pay(request=request)

        # If the fees are acceptable, continue to create the LNURL Pay
        logging.debug(f"Fees: {prepare_response.fee_sats} sats")
        return prepare_response
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Endpoint can also be of the form:
// lnurlp://domain.com/lnurl-pay?key=val
// lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4excttsv9un7um9wdekjmmw84jxywf5x43rvv35xgmr2enrxanr2cfcvsmnwe3jxcukvde48qukgdec89snwde3vfjxvepjxpjnjvtpxd3kvdnxx5crxwpjvyunsephsz36jf
lnurlPayUrl := "lightning@address.com"

input, err := sdk.Parse(lnurlPayUrl)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

switch inputType := input.(type) {
case breez_sdk_spark.InputTypeLightningAddress:
	amountSats := uint64(5_000)
	optionalComment := "<comment>"
	optionalValidateSuccessActionUrl := true

	request := breez_sdk_spark.PrepareLnurlPayRequest{
		AmountSats:               amountSats,
		PayRequest:               inputType.Field0.PayRequest,
		Comment:                  &optionalComment,
		ValidateSuccessActionUrl: &optionalValidateSuccessActionUrl,
	}

	response, err := sdk.PrepareLnurlPay(request)

	if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
		return nil, err
	}

	// If the fees are acceptable, continue to create the LNURL Pay
	feeSats := response.FeeSats
	log.Printf("Fees: %v sats", feeSats)
	return &response, nil
}
```

</section>

</custom-tabs>


<h2 id="lnurl-payments">
    <a class="header" href="#lnurl-payments">LNURL Payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.lnurl_pay">API docs</a>
</h2>

Once the payment has been prepared and the fees are accepted, the payment can be sent by passing:
- **Prepare Response** - The response from the [Preparing LNURL Payments](lnurl_pay.md#preparing-lnurl-payments) step.
- **Idempotency Key** - An optional UUID that identifies the payment. If set, providing the same idempotency key for multiple requests will ensure that only one payment is made.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let optional_idempotency_key = Some("<idempotency key uuid>".to_string());
let response = sdk
    .lnurl_pay(LnurlPayRequest {
        prepare_response,
        idempotency_key: optional_idempotency_key,
    })
    .await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let optionalIdempotencyKey = "<idempotency key uuid>"
let response = try await sdk.lnurlPay(
    request: LnurlPayRequest(
        prepareResponse: prepareResponse,
        idempotencyKey: optionalIdempotencyKey
    ))
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val optionalIdempotencyKey = "<idempotency key uuid>"
    val response = sdk.lnurlPay(LnurlPayRequest(prepareResponse, optionalIdempotencyKey))
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var optionalIdempotencyKey = "<idempotency key uuid>";
var response = await sdk.LnurlPay(
    new LnurlPayRequest(
        prepareResponse: prepareResponse,
        idempotencyKey: optionalIdempotencyKey
    )
);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const optionalIdempotencyKey = '<idempotency key uuid>'
const response = await sdk.lnurlPay({
  prepareResponse,
  idempotencyKey: optionalIdempotencyKey
})
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const optionalIdempotencyKey = '<idempotency key uuid>'
const response = await sdk.lnurlPay({
  prepareResponse,
  idempotencyKey: optionalIdempotencyKey
})
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String? optionalIdempotencyKey = "<idempotency key uuid>";
LnurlPayResponse response = await sdk.lnurlPay(
  request: LnurlPayRequest(
    prepareResponse: prepareResponse,
    idempotencyKey: optionalIdempotencyKey),
);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    optional_idempotency_key = "<idempotency key uuid>"
    response = await sdk.lnurl_pay(
        LnurlPayRequest(
            prepare_response=prepare_response,
            idempotency_key=optional_idempotency_key,
        )
    )
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
optionalIdempotencyKey := "<idempotency key uuid>"
request := breez_sdk_spark.LnurlPayRequest{
	PrepareResponse: prepareResponse,
	IdempotencyKey:  &optionalIdempotencyKey,
}

response, err := sdk.LnurlPay(request)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payment := response.Payment
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>
By default when the LNURL-pay results in a success action with a URL, the URL is validated to check if there is a mismatch with the LNURL callback domain. You can disable this behaviour by setting the optional validation <code>PrepareLnurlPayRequest</code> param to false.
</div>

## Supported Specs

- [LUD-01](https://github.com/lnurl/luds/blob/luds/01.md) LNURL bech32 encoding
- [LUD-06](https://github.com/lnurl/luds/blob/luds/06.md) `payRequest` spec
- [LUD-09](https://github.com/lnurl/luds/blob/luds/09.md) `successAction` field for `payRequest`
- [LUD-16](https://github.com/lnurl/luds/blob/luds/16.md) LN Address
- [LUD-17](https://github.com/lnurl/luds/blob/luds/17.md) Support for lnurlp prefix with non-bech32-encoded LNURL URLs

<h1 id="lightning-address">
    <a class="header" href="#lightning-address">Receiving payments using LNURL-Pay and Lightning addresses</a>
</h1>

<h2 id="what-is-lightning-address">
    <a class="header" href="#what-is-lightning-address">What is a Lightning address?</a>
</h2>

A Lightning address is a human-readable identifier formatted like an email address (e.g., `user@domain.com`) that can be used to receive Bitcoin payments over the Lightning Network. Behind the scenes, it uses the LNURL-Pay protocol to dynamically generate invoices when someone wants to send a payment to this address.

<h2 id="lnurl-server">
    <a class="header" href="#lnurl-server">Configuring a custom domain</a>
</h2>

To use Lightning addresses with the Breez SDK, you first need to supply a domain. There are two options:

1. **Use a hosted LNURL server**: You can have your custom domain configured to an LNURL server run by Breez.
2. **Self-hosted LNURL server**: You can run your own [LNURL server](https://github.com/breez/spark-sdk/tree/main/crates/breez-sdk/lnurl) in a self-hosted environment.

In case you choose to point your domain to a hosted LNURL server, you will need to add a CNAME record in your domain's DNS settings.

> **Note:**: If you're using Cloudflare, make sure the CNAME record is set to 'DNS only' (not 'Proxied').

**Option 1: Using your domain without any subdomain**

This points yourdomain.com directly to the LNURL server. Some DNS providers do not support this method. If yours doesn't support CNAME or ALIAS records for the root domain, you will need to configure your domain at the registrar level to use an external DNS provider (like Google Cloud DNS).
* **Host/Name**: @
* **Type**: CNAME (or ALIAS if available)
* **Value/Target**: breez.tips

**Option 2: Using a subdomain**
This points a subdomain like pay.yourdomain.com to the LNURL server.
* **Host/Name**: pay (or your chosen prefix like payment, tip, donate)
* **Type**: CNAME
* **Value/Target**: breez.tips

[Send us](mailto:contact@breez.technology) your domain name (e.g., yourdomain.com or pay.yourdomain.com).

We will verify and add it to our list of allowed domains.

<h2 id="configuring-lightning-address">
    <a class="header" href="#configuring-lightning-address">Configuring Lightning addresses for users</a>
</h2>

Configure your domain in the SDK by passing the `lnurl_domain` parameter in the SDK configuration:

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let mut config = default_config(Network::Mainnet);
config.api_key = Some("your-api-key".to_string());
config.lnurl_domain = Some("yourdomain.com".to_string());
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
var config = defaultConfig(network: Network.mainnet)
config.apiKey = "your-api-key"
config.lnurlDomain = "yourdomain.com"
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val config = defaultConfig(Network.MAINNET)
config.apiKey = "your-api-key"
config.lnurlDomain = "yourdomain.com"
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    apiKey = "your-api-key",
    lnurlDomain = "yourdomain.com"
};
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const config = defaultConfig('mainnet')
config.apiKey = 'your-api-key'
config.lnurlDomain = 'yourdomain.com'
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const config = defaultConfig(Network.Mainnet)
config.apiKey = 'your-api-key'
config.lnurlDomain = 'yourdomain.com'
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final config = defaultConfig(network: Network.mainnet)
    .copyWith(
      apiKey: 'your-api-key',
      lnurlDomain: 'yourdomain.com'
    );
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
config = default_config(network=Network.MAINNET)
config.api_key = "your-api-key"
config.lnurl_domain = "yourdomain.com"
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
lnurlDomain := "yourdomain.com"
apiKey := "your-api-key"
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
config.ApiKey = &apiKey
config.LnurlDomain = &lnurlDomain
```

</section>

</custom-tabs>


<h2 id="managing-lightning-address">
    <a class="header" href="#managing-lightning-address">Managing Lightning addresses</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.check_lightning_address_available">API docs</a>
</h2>

The SDK provides several functions to manage Lightning addresses:

<h3 id="checking-availability">
    <a class="header" href="#checking-availability">Checking address availability</a>
</h3>

Before registering a Lightning address, you can check if the username is available. In your UI you can use a quick check mark to show the address is available before registering.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let request = CheckLightningAddressRequest { username };

let is_available = sdk.check_lightning_address_available(request).await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let request = CheckLightningAddressRequest(
    username: username
)

let available = try await sdk.checkLightningAddressAvailable(req: request)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val request = CheckLightningAddressRequest(
    username = username
)

val available = sdk.checkLightningAddressAvailable(request)
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var request = new CheckLightningAddressRequest(username: username);
var isAvailable = await sdk.CheckLightningAddressAvailable(request);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const request = {
  username
}

const available = await sdk.checkLightningAddressAvailable(request)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const request = {
  username
}

const available = await sdk.checkLightningAddressAvailable(request)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final request = CheckLightningAddressRequest(
  username: username,
);

final available = await sdk.checkLightningAddressAvailable(request: request);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
request = CheckLightningAddressRequest(username=username)
is_available = await sdk.check_lightning_address_available(request)
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.CheckLightningAddressRequest{
	Username: username,
}

isAvailable, err := sdk.CheckLightningAddressAvailable(request)
if err != nil {
	return false, err
}
```

</section>

</custom-tabs>


<h3 id="registering-address">
    <a class="header" href="#registering-address">Registering a Lightning address</a>
</h3>

Once you've confirmed a username is available, you can register it by passing a username and a description. The username will be used in `username@domain.com`. The description will be included in lnurl metadata and as the invoice description, so this is what the sender will see. The description is optional, and will default to `Pay to username@domain.com`.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let request = RegisterLightningAddressRequest {
    username,
    description,
};

let address_info = sdk.register_lightning_address(request).await?;
let lightning_address = address_info.lightning_address;
let lnurl = address_info.lnurl;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let request = RegisterLightningAddressRequest(
    username: username,
    description: description
)

let addressInfo = try await sdk.registerLightningAddress(request: request)
let lightningAddress = addressInfo.lightningAddress
let lnurl = addressInfo.lnurl
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val request = RegisterLightningAddressRequest(
    username = username,
    description = description
)

val addressInfo = sdk.registerLightningAddress(request)
val lightningAddress = addressInfo.lightningAddress
val lnurl = addressInfo.lnurl
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var request = new RegisterLightningAddressRequest(
    username: username,
    description: description
);

var addressInfo = await sdk.RegisterLightningAddress(request);
var lightningAddress = addressInfo.lightningAddress;
var lnurl = addressInfo.lnurl;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const request = {
  username,
  description
}

const addressInfo = await sdk.registerLightningAddress(request)
const lightningAddress = addressInfo.lightningAddress
const lnurl = addressInfo.lnurl
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const request = {
  username,
  description
}

const addressInfo = await sdk.registerLightningAddress(request)
const lightningAddress = addressInfo.lightningAddress
const lnurl = addressInfo.lnurl
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final request = RegisterLightningAddressRequest(
  username: username,
  description: description,
);

final addressInfo = await sdk.registerLightningAddress(request: request);
final lightningAddress = addressInfo.lightningAddress;
final lnurl = addressInfo.lnurl;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
request = RegisterLightningAddressRequest(
    username=username,
    description=description
)

address_info = await sdk.register_lightning_address(request)
lightning_address = address_info.lightning_address
lnurl = address_info.lnurl
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.RegisterLightningAddressRequest{
	Username:    username,
	Description: &description,
}

addressInfo, err := sdk.RegisterLightningAddress(request)
if err != nil {
	return nil, err
}

_ = addressInfo.LightningAddress
_ = addressInfo.Lnurl
```

</section>

</custom-tabs>


<h3 id="retrieving-address">
    <a class="header" href="#retrieving-address">Retrieving Lightning address information</a>
</h3>

You can retrieve information about the currently registered Lightning address.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let address_info_opt = sdk.get_lightning_address().await?;

if let Some(info) = address_info_opt {
    let lightning_address = &info.lightning_address;
    let username = &info.username;
    let description = &info.description;
    let lnurl = &info.lnurl;
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
if let addressInfo = try await sdk.getLightningAddress() {
    let lightningAddress = addressInfo.lightningAddress
    let username = addressInfo.username
    let description = addressInfo.description
    let lnurl = addressInfo.lnurl
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val addressInfoOpt = sdk.getLightningAddress()

if (addressInfoOpt != null) {
    val lightningAddress = addressInfoOpt.lightningAddress
    val username = addressInfoOpt.username
    val description = addressInfoOpt.description
    val lnurl = addressInfoOpt.lnurl
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var addressInfoOpt = await sdk.GetLightningAddress();

if (addressInfoOpt != null)
{
    var lightningAddress = addressInfoOpt.lightningAddress;
    var username = addressInfoOpt.username;
    var description = addressInfoOpt.description;
    var lnurl = addressInfoOpt.lnurl;
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const addressInfoOpt = await sdk.getLightningAddress()

if (addressInfoOpt != null) {
  const lightningAddress = addressInfoOpt.lightningAddress
  const username = addressInfoOpt.username
  const description = addressInfoOpt.description
  const lnurl = addressInfoOpt.lnurl
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const addressInfoOpt = await sdk.getLightningAddress()

if (addressInfoOpt != null) {
  const lightningAddress = addressInfoOpt.lightningAddress
  const username = addressInfoOpt.username
  const description = addressInfoOpt.description
  const lnurl = addressInfoOpt.lnurl
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final addressInfoOpt = await sdk.getLightningAddress();

if (addressInfoOpt == null) {
  throw Exception("No Lightning Address registered for this user.");
}

final lightningAddress = addressInfoOpt.lightningAddress;
final username = addressInfoOpt.username;
final description = addressInfoOpt.description;
final lnurl = addressInfoOpt.lnurl;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
address_info_opt = await sdk.get_lightning_address()

if address_info_opt is not None:
    lightning_address = address_info_opt.lightning_address
    username = address_info_opt.username
    description = address_info_opt.description
    lnurl = address_info_opt.lnurl
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
addressInfoOpt, err := sdk.GetLightningAddress()
if err != nil {
	return nil, err
}

if addressInfoOpt != nil {
	_ = addressInfoOpt.LightningAddress
	_ = addressInfoOpt.Username
	_ = addressInfoOpt.Description
	_ = addressInfoOpt.Lnurl
}
```

</section>

</custom-tabs>


<h3 id="deleting-address">
    <a class="header" href="#deleting-address">Deleting a Lightning address</a>
</h3>

When a user no longer wants to use the Lightning address, you can delete it.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
sdk.delete_lightning_address().await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
try await sdk.deleteLightningAddress()
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
sdk.deleteLightningAddress()
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
await sdk.DeleteLightningAddress();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
await sdk.deleteLightningAddress()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
await sdk.deleteLightningAddress()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
await sdk.deleteLightningAddress();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
await sdk.delete_lightning_address()
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
err := sdk.DeleteLightningAddress()
if err != nil {
	return err
}
```

</section>

</custom-tabs>


<h2 id="lnurl-metadata">
    <a class="header" href="#lnurl-metadata">Accessing LNURL payment metadata</a>
</h2>

When receiving payments via LNURL-Pay or Lightning addresses, additional metadata may be included with the payment. This metadata is available on the received payment.

<h3 id="sender-comment">
    <a class="header" href="#sender-comment">Sender comment</a>
</h3>

If the sender includes a comment with their payment (as defined in [LUD-12](https://github.com/lnurl/luds/blob/luds/12.md)), it will be available on the received payment. This is the message that the sender wrote when making the payment.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Check if this is a lightning payment with LNURL receive metadata
if let Some(PaymentDetails::Lightning {
    lnurl_receive_metadata: Some(metadata),
    ..
}) = payment.details
{
    // Access the sender comment if present
    if let Some(comment) = metadata.sender_comment {
        println!("Sender comment: {}", comment);
    }
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Check if this is a lightning payment with LNURL receive metadata
if case .lightning(let details) = payment.details {
    // Access the sender comment if present
    if let metadata = details.lnurlReceiveMetadata,
       let comment = metadata.senderComment {
        print("Sender comment: \(comment)")
    }
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details is PaymentDetails.Lightning) {
    val details = payment.details as PaymentDetails.Lightning
    val metadata = details.lnurlReceiveMetadata

    // Access the sender comment if present
    metadata?.senderComment?.let { comment ->
        println("Sender comment: $comment")
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details is PaymentDetails.Lightning lightningDetails)
{
    var metadata = lightningDetails.lnurlReceiveMetadata;

    // Access the sender comment if present
    if (metadata?.senderComment != null)
    {
        Console.WriteLine($"Sender comment: {metadata.senderComment}");
    }
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details?.type === 'lightning') {
  const metadata = payment.details.lnurlReceiveMetadata

  // Access the sender comment if present
  if (metadata?.senderComment != null) {
    console.log('Sender comment:', metadata.senderComment)
  }
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details?.tag === PaymentDetails_Tags.Lightning) {
  const metadata = payment.details.inner.lnurlReceiveMetadata

  // Access the sender comment if present
  if (metadata?.senderComment != null) {
    console.log('Sender comment:', metadata.senderComment)
  }
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details case PaymentDetails_Lightning lightningDetails) {
  final metadata = lightningDetails.lnurlReceiveMetadata;

  // Access the sender comment if present
  final comment = metadata?.senderComment;
  if (comment != null) {
    print('Sender comment: $comment');
  }
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Check if this is a lightning payment with LNURL receive metadata
if isinstance(payment.details, PaymentDetails.LIGHTNING):
    metadata = payment.details.lnurl_receive_metadata

    # Access the sender comment if present
    if metadata is not None and metadata.sender_comment is not None:
        print(f"Sender comment: {metadata.sender_comment}")
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Check if this is a lightning payment with LNURL receive metadata
if lightningDetails, ok := (*payment.Details).(breez_sdk_spark.PaymentDetailsLightning); ok {
	metadata := lightningDetails.LnurlReceiveMetadata

	// Access the sender comment if present
	if metadata != nil && metadata.SenderComment != nil {
		println("Sender comment:", *metadata.SenderComment)
	}
}
```

</section>

</custom-tabs>


<h3 id="nostr-zap">
    <a class="header" href="#nostr-zap">Nostr Zap request</a>
</h3>

If the payment was sent as a Nostr Zap (as defined in [NIP-57](https://github.com/nostr-protocol/nips/blob/master/57.md)), the received payment will include the zap request event. It carries the signed Nostr event (kind 9734) used to create the zap, and will also include the zap receipt event (kind 9735) once that has been created and published.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Check if this is a lightning payment with LNURL receive metadata
if let Some(PaymentDetails::Lightning {
    lnurl_receive_metadata: Some(metadata),
    ..
}) = payment.details
{
    // Access the Nostr zap request if present
    if let Some(zap_request) = metadata.nostr_zap_request {
        // The zap_request is a JSON string containing the Nostr event (kind 9734)
        println!("Nostr zap request: {}", zap_request);
    }

    // Access the Nostr zap receipt if present
    if let Some(zap_receipt) = metadata.nostr_zap_receipt {
        // The zap_receipt is a JSON string containing the Nostr event (kind 9735)
        println!("Nostr zap receipt: {}", zap_receipt);
    }
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Check if this is a lightning payment with LNURL receive metadata
if case .lightning(let details) = payment.details {
    if let metadata = details.lnurlReceiveMetadata {
        // Access the Nostr zap request if present
        if let zapRequest = metadata.nostrZapRequest {
            // The zapRequest is a JSON string containing the Nostr event (kind 9734)
            print("Nostr zap request: \(zapRequest)")
        }

        // Access the Nostr zap receipt if present
        if let zapReceipt = metadata.nostrZapReceipt {
            // The zapReceipt is a JSON string containing the Nostr event (kind 9735)
            print("Nostr zap receipt: \(zapReceipt)")
        }
    }
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details is PaymentDetails.Lightning) {
    val details = payment.details as PaymentDetails.Lightning
    val metadata = details.lnurlReceiveMetadata

    // Access the Nostr zap request if present
    metadata?.nostrZapRequest?.let { zapRequest ->
        // The zapRequest is a JSON string containing the Nostr event (kind 9734)
        println("Nostr zap request: $zapRequest")
    }

    // Access the Nostr zap receipt if present
    metadata?.nostrZapReceipt?.let { zapReceipt ->
        // The zapReceipt is a JSON string containing the Nostr event (kind 9735)
        println("Nostr zap receipt: $zapReceipt")
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details is PaymentDetails.Lightning lightningDetails)
{
    var metadata = lightningDetails.lnurlReceiveMetadata;

    if (metadata != null)
    {
        // Access the Nostr zap request if present
        if (metadata.nostrZapRequest != null)
        {
            // The nostrZapRequest is a JSON string containing the Nostr event (kind 9734)
            Console.WriteLine($"Nostr zap request: {metadata.nostrZapRequest}");
        }

        // Access the Nostr zap receipt if present
        if (metadata.nostrZapReceipt != null)
        {
            // The nostrZapReceipt is a JSON string containing the Nostr event (kind 9735)
            Console.WriteLine($"Nostr zap receipt: {metadata.nostrZapReceipt}");
        }
    }
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details?.type === 'lightning') {
  const metadata = payment.details.lnurlReceiveMetadata

  // Access the Nostr zap request if present
  if (metadata?.nostrZapRequest != null) {
    // The nostrZapRequest is a JSON string containing the Nostr event (kind 9734)
    console.log('Nostr zap request:', metadata.nostrZapRequest)
  }

  // Access the Nostr zap receipt if present
  if (metadata?.nostrZapReceipt != null) {
    // The nostrZapReceipt is a JSON string containing the Nostr event (kind 9735)
    console.log('Nostr zap receipt:', metadata.nostrZapReceipt)
  }
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details?.tag === PaymentDetails_Tags.Lightning) {
  const metadata = payment.details.inner.lnurlReceiveMetadata

  // Access the Nostr zap request if present
  if (metadata?.nostrZapRequest != null) {
    // The nostrZapRequest is a JSON string containing the Nostr event (kind 9734)
    console.log('Nostr zap request:', metadata.nostrZapRequest)
  }

  // Access the Nostr zap receipt if present
  if (metadata?.nostrZapReceipt != null) {
    // The nostrZapReceipt is a JSON string containing the Nostr event (kind 9735)
    console.log('Nostr zap receipt:', metadata.nostrZapReceipt)
  }
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Check if this is a lightning payment with LNURL receive metadata
if (payment.details case PaymentDetails_Lightning lightningDetails) {
  final metadata = lightningDetails.lnurlReceiveMetadata;

  if (metadata != null) {
    // Access the Nostr zap request if present
    final zapRequest = metadata.nostrZapRequest;
    if (zapRequest != null) {
      // The zapRequest is a JSON string containing the Nostr event (kind 9734)
      print('Nostr zap request: $zapRequest');
    }

    // Access the Nostr zap receipt if present
    final zapReceipt = metadata.nostrZapReceipt;
    if (zapReceipt != null) {
      // The zapReceipt is a JSON string containing the Nostr event (kind 9735)
      print('Nostr zap receipt: $zapReceipt');
    }
  }
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Check if this is a lightning payment with LNURL receive metadata
if isinstance(payment.details, PaymentDetails.LIGHTNING):
    metadata = payment.details.lnurl_receive_metadata

    if metadata is not None:
        # Access the Nostr zap request if present
        if metadata.nostr_zap_request is not None:
            # The nostr_zap_request is a JSON string containing the Nostr event (kind 9734)
            print(f"Nostr zap request: {metadata.nostr_zap_request}")

        # Access the Nostr zap receipt if present
        if metadata.nostr_zap_receipt is not None:
            # The nostr_zap_receipt is a JSON string containing the Nostr event (kind 9735)
            print(f"Nostr zap receipt: {metadata.nostr_zap_receipt}")
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Check if this is a lightning payment with LNURL receive metadata
if lightningDetails, ok := (*payment.Details).(breez_sdk_spark.PaymentDetailsLightning); ok {
	metadata := lightningDetails.LnurlReceiveMetadata

	if metadata != nil {
		// Access the Nostr zap request if present
		if metadata.NostrZapRequest != nil {
			// The NostrZapRequest is a JSON string containing the Nostr event (kind 9734)
			println("Nostr zap request:", *metadata.NostrZapRequest)
		}

		// Access the Nostr zap receipt if present
		if metadata.NostrZapReceipt != nil {
			// The NostrZapReceipt is a JSON string containing the Nostr event (kind 9735)
			println("Nostr zap receipt:", *metadata.NostrZapReceipt)
		}
	}
}
```

</section>

</custom-tabs>


> **Note:** When used in [private mode](./config.md#private-mode-enabled-by-default), the nostr zap receipt will be published by the SDK when online. When used in public mode, the zap receipt will be published by the LNURL server on your behalf.

<h1 id="lnurl-withdraw">
    <a class="header" href="#lnurl-withdraw">Receiving payments using LNURL-Withdraw</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.lnurl_withdraw">API docs</a>
</h1>

After [parsing](parse.md) an LNURL-Withdraw input, you can use the resulting input data to initiate a withdrawal from an LNURL service.

By default, this function returns immediately. You can override this behavior by specifying a completion timeout in seconds. If the completion timeout is hit, a pending payment object is returned if available. If the payment completes, the completed payment object is returned.

<div class="warning">
<h4>Developer note</h4>
The minimum and maximum withdrawable amount returned from calling parse is denominated in millisatoshi.
</div>

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Endpoint can also be of the form:
// lnurlw://domain.com/lnurl-withdraw?key=val
let lnurl_withdraw_url = "lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekjmmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk";

if let Ok(InputType::LnurlWithdraw(withdraw_request)) = sdk.parse(lnurl_withdraw_url).await {
    // Amount to withdraw in sats between min/max withdrawable amounts
    let amount_sats = 5_000;
    let optional_completion_timeout_secs = Some(30);

    let response = sdk
        .lnurl_withdraw(LnurlWithdrawRequest {
            amount_sats,
            withdraw_request,
            completion_timeout_secs: optional_completion_timeout_secs,
        })
        .await?;

    let payment = response.payment;
    info!("Payment: {payment:?}");
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Endpoint can also be of the form:
// lnurlw://domain.com/lnurl-withdraw?key=val
let lnurlWithdrawUrl = "lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekjmmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk"

let inputType = try await sdk.parse(input: lnurlWithdrawUrl)
if case .lnurlWithdraw(v1: let withdrawRequest) = inputType {
    // Amount to withdraw in sats between min/max withdrawable amounts
    let amountSats: UInt64 = 5_000
    let optionalCompletionTimeoutSecs: UInt32 = 30

    let request = LnurlWithdrawRequest(
        amountSats: amountSats,
        withdrawRequest: withdrawRequest,
        completionTimeoutSecs: optionalCompletionTimeoutSecs
    )
    let response = try await sdk.lnurlWithdraw(request: request)

    let payment = response.payment
    print("Payment: \(payment)")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Endpoint can also be of the form:
// lnurlw://domain.com/lnurl-withdraw?key=val
val lnurlWithdrawUrl = "lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7..."
try {
    val inputType = sdk.parse(lnurlWithdrawUrl)
    if (inputType is InputType.LnurlWithdraw) {
        // Amount to withdraw in sats between min/max withdrawable amounts
        val amountSats = 5_000.toULong()
        val withdrawRequest = inputType.v1
        val optionalCompletionTimeoutSecs = 30.toUInt()

        val request = LnurlWithdrawRequest(
            amountSats,
            withdrawRequest,
            optionalCompletionTimeoutSecs
        )
        val response = sdk.lnurlWithdraw(request)

        val payment = response.payment
        // Log.v("Breez", "Payment: $payment")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Endpoint can also be of the form:
// lnurlw://domain.com/lnurl-withdraw?key=val
var lnurlWithdrawUrl = "lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekj" +
                        "mmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8" +
                        "qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk";

var inputType = await sdk.Parse(lnurlWithdrawUrl);
if (inputType is InputType.LnurlWithdraw lnurlWithdraw)
{
    // Amount to withdraw in sats between min/max withdrawable amounts
    var amountSats = 5_000UL;
    var withdrawRequest = lnurlWithdraw.v1;
    var optionalCompletionTimeoutSecs = 30U;

    var request = new LnurlWithdrawRequest(
        amountSats: amountSats,
        withdrawRequest: withdrawRequest,
        completionTimeoutSecs: optionalCompletionTimeoutSecs
    );
    var response = await sdk.LnurlWithdraw(request: request);

    var payment = response.payment;
    Console.WriteLine($"Payment: {payment}");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Endpoint can also be of the form:
// lnurlw://domain.com/lnurl-withdraw?key=val
const lnurlWithdrawUrl =
  'lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekjmmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk'

const input = await sdk.parse(lnurlWithdrawUrl)
if (input.type === 'lnurlWithdraw') {
  // Amount to withdraw in sats between min/max withdrawable amounts
  const amountSats = 5_000
  const withdrawRequest = input
  const optionalCompletionTimeoutSecs = 30

  const response = await sdk.lnurlWithdraw({
    amountSats,
    withdrawRequest,
    completionTimeoutSecs: optionalCompletionTimeoutSecs
  })

  const payment = response.payment
  console.log(`Payment: ${JSON.stringify(payment)}`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Endpoint can also be of the form:
// lnurlw://domain.com/lnurl-withdraw?key=val
const lnurlWithdrawUrl =
  'lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekjmmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk'

const input = await sdk.parse(lnurlWithdrawUrl)
if (input.tag === InputType_Tags.LnurlWithdraw) {
  // Amount to withdraw in sats between min/max withdrawable amounts
  const amountSats = BigInt(5_000)
  const withdrawRequest = input.inner[0]
  const optionalCompletionTimeoutSecs = 30

  const response = await sdk.lnurlWithdraw({
    amountSats,
    withdrawRequest,
    completionTimeoutSecs: optionalCompletionTimeoutSecs
  })

  const payment = response.payment
  console.log(`Payment: ${JSON.stringify(payment)}`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
/// Endpoint can also be of the form:
/// lnurlw://domain.com/lnurl-withdraw?key=val
String lnurlWithdrawUrl =
    "lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekjmmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk";

InputType inputType = await sdk.parse(input: lnurlWithdrawUrl);
if (inputType is InputType_LnurlWithdraw) {
  // Amount to withdraw in sats between min/max withdrawable amounts
  BigInt amountSats = BigInt.from(5000);
  LnurlWithdrawRequestDetails withdrawRequest = inputType.field0;
  int optionalCompletionTimeoutSecs = 30;

  LnurlWithdrawRequest request = LnurlWithdrawRequest(
    amountSats: amountSats,
    withdrawRequest: withdrawRequest,
    completionTimeoutSecs: optionalCompletionTimeoutSecs,
  );

  LnurlWithdrawResponse response = await sdk.lnurlWithdraw(request: request);

  Payment? payment = response.payment;
  print('Payment: $payment');
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Endpoint can also be of the form:
# lnurlw://domain.com/lnurl-withdraw?key=val
lnurl_withdraw_url = (
    "lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekj"
    "mmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8"
    "qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk"
)

try:
    input_type = await sdk.parse(lnurl_withdraw_url)
    if isinstance(input_type, InputType.LNURL_WITHDRAW):
        # Amount to withdraw in sats between min/max withdrawable amounts
        amount_sats = 5_000
        withdraw_request = input_type[0]
        optional_completion_timeout_secs = 30

        request = LnurlWithdrawRequest(
            amount_sats=amount_sats,
            withdraw_request=withdraw_request,
            completion_timeout_secs=optional_completion_timeout_secs,
        )
        response = await sdk.lnurl_withdraw(request=request)


        payment = response.payment
        logging.debug(f"Payment: {payment}")
        return response
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Endpoint can also be of the form:
// lnurlw://domain.com/lnurl-withdraw?key=val
lnurlWithdrawUrl := "lnurl1dp68gurn8ghj7mr0vdskc6r0wd6z7mrww4exctthd96xserjv9mn7um9wdekj" +
	"mmw843xxwpexdnxzen9vgunsvfexq6rvdecx93rgdmyxcuxverrvcursenpxvukzv3c8qunsdecx33nzwpnvg6ryc3hv93nzvecxgcxgwp3h33lxk"

input, err := sdk.Parse(lnurlWithdrawUrl)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

switch inputType := input.(type) {
case breez_sdk_spark.InputTypeLnurlWithdraw:
	// Amount to withdraw in sats between min/max withdrawable amounts
	amountSats := uint64(5_000)
	withdrawRequest := inputType.Field0
	optionalCompletionTimeoutSecs := uint32(30)

	request := breez_sdk_spark.LnurlWithdrawRequest{
		AmountSats:            amountSats,
		WithdrawRequest:       withdrawRequest,
		CompletionTimeoutSecs: &optionalCompletionTimeoutSecs,
	}

	response, err := sdk.LnurlWithdraw(request)

	if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
		return nil, err
	}

	payment := response.Payment
	log.Printf("Payment: %#v", payment)
	return &response, nil
}
```

</section>

</custom-tabs>


## Supported Specs

- [LUD-01](https://github.com/lnurl/luds/blob/luds/01.md) LNURL bech32 encoding
- [LUD-03](https://github.com/lnurl/luds/blob/luds/03.md) `withdrawRequest` spec
- [LUD-17](https://github.com/lnurl/luds/blob/luds/17.md) Support for lnurlw prefix with non-bech32-encoded LNURL URLs

<h1 id="lnurl-auth">
    <a class="header" href="#lnurl-auth">Using LNURL-Auth</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.lnurl_auth">API docs</a>
</h1>

LNURL-Auth allows users to authenticate with services using their Lightning app, without requiring passwords or usernames. The Breez SDK supports LNURL-Auth following the LUD-04 and LUD-05 specifications.

## How it works

LNURL-Auth uses cryptographic key derivation to generate domain-specific keys, ensuring that:
- Each service gets a unique authentication key
- Your master key remains private
- Authentication is secure and passwordless

The SDK handles:
1. Domain-specific key derivation (LUD-05)
2. Challenge signing
3. Callback to the LNURL service

## Parsing LNURL-Auth URLs

After [parsing](parse.md) an LNURL-Auth URL, you'll receive an `LnurlAuthRequestDetails` object containing:
- **k1** - The authentication challenge (hex-encoded 32 bytes)
- **action** - Optional action type: `register`, `login`, `link`, or `auth`
- **domain** - The service domain requesting authentication
- **url** - The callback URL

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
let lnurl_auth_url = "lnurl1...";

if let Ok(InputType::LnurlAuth(request_data)) = sdk.parse(lnurl_auth_url).await {
    info!("Domain: {}", request_data.domain);
    info!("Action: {:?}", request_data.action);

    // Show domain to user and ask for confirmation
    // This is important for security
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
let lnurlAuthUrl = "lnurl1..."

if case .lnurlAuth(v1: let requestData) = try await sdk.parse(input: lnurlAuthUrl) {
    print("Domain: \(requestData.domain)")
    print("Action: \(String(describing: requestData.action))")

    // Show domain to user and ask for confirmation
    // This is important for security
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
val lnurlAuthUrl = "lnurl1..."

when (val inputType = sdk.parse(lnurlAuthUrl)) {
    is InputType.LnurlAuth -> {
        val requestData = inputType.v1
        println("Domain: ${requestData.domain}")
        println("Action: ${requestData.action}")

        // Show domain to user and ask for confirmation
        // This is important for security
    }
    else -> {}
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
var lnurlAuthUrl = "lnurl1...";

var inputType = await sdk.Parse(lnurlAuthUrl);
if (inputType is InputType.LnurlAuth lnurlAuth)
{
    var requestData = lnurlAuth.v1;
    Console.WriteLine($"Domain: {requestData.domain}");
    Console.WriteLine($"Action: {requestData.action}");

    // Show domain to user and ask for confirmation
    // This is important for security
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
const lnurlAuthUrl = 'lnurl1...'

const inputType = await sdk.parse(lnurlAuthUrl)
if (inputType.type === 'lnurlAuth') {
  console.log(`Domain: ${inputType.domain}`)
  console.log(`Action: ${inputType.action}`)

  // Show domain to user and ask for confirmation
  // This is important for security
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
const lnurlAuthUrl = 'lnurl1...'

const inputType = await sdk.parse(lnurlAuthUrl)
if (inputType.tag === InputType_Tags.LnurlAuth) {
  const requestData = inputType.inner[0]
  console.log(`Domain: ${requestData.domain}`)
  console.log(`Action: ${requestData.action}`)

  // Show domain to user and ask for confirmation
  // This is important for security
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
String lnurlAuthUrl = "lnurl1...";

InputType inputType = await sdk.parse(input: lnurlAuthUrl);
if (inputType is InputType_LnurlAuth) {
  LnurlAuthRequestDetails requestData = inputType.field0;
  print("Domain: ${requestData.domain}");
  print("Action: ${requestData.action}");

  // Show domain to user and ask for confirmation
  // This is important for security
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# LNURL-auth URL from a service
# Can be in the form:
# - lnurl1... (bech32 encoded)
# - https://service.com/lnurl-auth?tag=login&k1=...
lnurl_auth_url = "lnurl1..."

try:
    input_type = await sdk.parse(lnurl_auth_url)
    if isinstance(input_type, InputType.LNURL_AUTH):
        request_data = input_type[0]
        logging.debug(f"Domain: {request_data.domain}")
        logging.debug(f"Action: {request_data.action}")

        # Show domain to user and ask for confirmation
        # This is important for security
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// LNURL-auth URL from a service
// Can be in the form:
// - lnurl1... (bech32 encoded)
// - https://service.com/lnurl-auth?tag=login&k1=...
lnurlAuthUrl := "lnurl1..."

inputType, err := sdk.Parse(lnurlAuthUrl)
if err == nil {
	if lnurlAuth, ok := inputType.(breez_sdk_spark.InputTypeLnurlAuth); ok {
		requestData := lnurlAuth.Field0
		log.Printf("Domain: %s", requestData.Domain)
		log.Printf("Action: %v", requestData.Action)

		// Show domain to user and ask for confirmation
		// This is important for security
	}
}
```

</section>

</custom-tabs>


## Performing Authentication

Once you have the authentication request details, you can perform the authentication by passing the request to the `lnurl_auth` method. The SDK will:
1. Derive a domain-specific key pair
2. Sign the challenge with the derived key
3. Send the signature and public key to the service

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Perform LNURL authentication
let result = sdk.lnurl_auth(request_data).await?;

match result {
    LnurlCallbackStatus::Ok => {
        info!("Authentication successful");
    }
    LnurlCallbackStatus::ErrorStatus { error_details } => {
        info!("Authentication failed: {}", error_details.reason);
    }
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Perform LNURL authentication
let result = try await sdk.lnurlAuth(requestData: requestData)

switch result {
case .ok:
    print("Authentication successful")
case .errorStatus(errorDetails: let errorDetails):
    print("Authentication failed: \(errorDetails.reason)")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Perform LNURL authentication
when (val result = sdk.lnurlAuth(requestData)) {
    is LnurlCallbackStatus.Ok -> {
        println("Authentication successful")
    }
    is LnurlCallbackStatus.ErrorStatus -> {
        println("Authentication failed: ${result.errorDetails.reason}")
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Perform LNURL authentication
var result = await sdk.LnurlAuth(requestData);

if (result is LnurlCallbackStatus.Ok)
{
    Console.WriteLine("Authentication successful");
}
else if (result is LnurlCallbackStatus.ErrorStatus errorStatus)
{
    Console.WriteLine($"Authentication failed: {errorStatus.errorDetails.reason}");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Perform LNURL authentication
const result = await sdk.lnurlAuth(requestData)

if (result.type === 'ok') {
  console.log('Authentication successful')
} else if (result.type === 'errorStatus') {
  console.log(`Authentication failed: ${result.errorDetails.reason}`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Perform LNURL authentication
const result = await sdk.lnurlAuth(requestData)

if (result.tag === LnurlCallbackStatus_Tags.Ok) {
  console.log('Authentication successful')
} else if (result.tag === LnurlCallbackStatus_Tags.ErrorStatus) {
  console.log(`Authentication failed: ${result.inner.errorDetails.reason}`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Perform LNURL authentication
LnurlCallbackStatus result = await sdk.lnurlAuth(requestData: requestData);

if (result is LnurlCallbackStatus_Ok) {
  print("Authentication successful");
} else if (result is LnurlCallbackStatus_ErrorStatus) {
  print("Authentication failed: ${result.errorDetails.reason}");
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Perform LNURL authentication
try:
    result = await sdk.lnurl_auth(request_data=request_data)

    if isinstance(result, LnurlCallbackStatus.OK):
        logging.debug("Authentication successful")
    elif isinstance(result, LnurlCallbackStatus.ERROR_STATUS):
        logging.debug(f"Authentication failed: {result.error_details.reason}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Perform LNURL authentication
result, err := sdk.LnurlAuth(requestData)
if err != nil {
	log.Printf("Authentication error: %v", err)
	return
}

switch v := result.(type) {
case breez_sdk_spark.LnurlCallbackStatusOk:
	log.Println("Authentication successful")
case breez_sdk_spark.LnurlCallbackStatusErrorStatus:
	log.Printf("Authentication failed: %s", v.ErrorDetails.Reason)
}
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>
The SDK automatically derives domain-specific keys according to LUD-05, ensuring that each service gets a unique linking key. This protects user privacy by preventing services from correlating user identities across different domains.
</div>

## Action Types

LNURL-Auth supports different action types that indicate the purpose of the authentication:

- **register** - Create a new account
- **login** - Sign in to an existing account
- **link** - Link the Lightning wallet to an existing account
- **auth** - Generic authentication

Your application can use the `action` field to provide appropriate UI feedback to users.

## Security Considerations

- Always verify the domain before authenticating
- Show the domain to users for confirmation
- The SDK derives unique keys per domain to prevent tracking
- Authentication keys cannot be used to access funds

## Supported Specs

- [LUD-01](https://github.com/lnurl/luds/blob/luds/01.md) LNURL bech32 encoding
- [LUD-04](https://github.com/lnurl/luds/blob/luds/04.md) `auth` base spec
- [LUD-05](https://github.com/lnurl/luds/blob/luds/05.md) BIP32-based seed generation for `auth`
- [LUD-17](https://github.com/lnurl/luds/blob/luds/17.md) Support for lnurl auth 

# User settings

The SDK exposes a set of user settings that are shared across all SDK instances, even from different partners.

<h2 id="available-user-settings">
    <a class="header" href="#available-user-settings">Available user settings</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.UserSettings.html">API docs</a>
</h2>

The following user settings are available:

- **Spark private mode**: Spark supports opt-in wallet privacy. When enabled, the wallet's Bitcoin payments and balance will not be accessible through public indexers like [Sparkscan](https://sparkscan.io). The SDK enables this by default for new wallets, and we highly recommend keeping it enabled. However, some applications may require the wallet to be visible to the public.

> **Note:** Spark private mode only applies to Bitcoin payments. Token payments are not affected by the private mode and will still be publicly available.

<h2 id="getting-the-current-user-settings">
    <a class="header" href="#getting-the-current-user-settings">Getting the current user settings</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.get_user_settings">API docs</a>
</h2>

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let user_settings = sdk.get_user_settings().await?;
info!("User settings: {:?}", user_settings);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let userSettings = try await sdk.getUserSettings()
print("User settings: \(userSettings)")
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val userSettings = sdk.getUserSettings()
    println("User settings: $userSettings")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var userSettings = await sdk.GetUserSettings();

Console.WriteLine($"User settings: {userSettings}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const userSettings = await sdk.getUserSettings()
console.log(`User settings: ${JSON.stringify(userSettings)}`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const userSettings = await sdk.getUserSettings()
console.log(`User settings: ${JSON.stringify(userSettings)}`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final userSettings = await sdk.getUserSettings();
print('User settings: $userSettings');
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    user_settings = await sdk.get_user_settings()

    print(f"User settings: {user_settings}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
userSettings, err := sdk.GetUserSettings()

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

log.Printf("User settings: %v", userSettings)
```

</section>

</custom-tabs>


<h2 id="updating-the-user-settings">
    <a class="header" href="#updating-the-user-settings">Updating the user settings</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.update_user_settings">API docs</a>
</h2>

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let spark_private_mode_enabled = true;
sdk.update_user_settings(UpdateUserSettingsRequest {
    spark_private_mode_enabled: Some(spark_private_mode_enabled),
})
.await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let sparkPrivateModeEnabled = true
try await sdk.updateUserSettings(
    request: UpdateUserSettingsRequest(
        sparkPrivateModeEnabled: sparkPrivateModeEnabled
    ))
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val sparkPrivateModeEnabled = true
    sdk.updateUserSettings(UpdateUserSettingsRequest(sparkPrivateModeEnabled))
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var sparkPrivateModeEnabled = true;
await sdk.UpdateUserSettings(
    request: new UpdateUserSettingsRequest(
        sparkPrivateModeEnabled: sparkPrivateModeEnabled
    )
);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const sparkPrivateModeEnabled = true
await sdk.updateUserSettings({
  sparkPrivateModeEnabled
})
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const sparkPrivateModeEnabled = true
await sdk.updateUserSettings({
  sparkPrivateModeEnabled
})
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final bool sparkPrivateModeEnabled = true;

await sdk.updateUserSettings(
    request: UpdateUserSettingsRequest(
        sparkPrivateModeEnabled: sparkPrivateModeEnabled));
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    spark_private_mode_enabled = True
    await sdk.update_user_settings(
        request=UpdateUserSettingsRequest(
            spark_private_mode_enabled=spark_private_mode_enabled
        )
    )
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
sparkPrivateModeEnabled := true
err := sdk.UpdateUserSettings(breez_sdk_spark.UpdateUserSettingsRequest{
	SparkPrivateModeEnabled: &sparkPrivateModeEnabled,
})

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}
```

</section>

</custom-tabs>


# Signing and verifying messages

Through signing and verifying messages we can provide proof that a digital signature was created by a private key.

<h2 id="signing-a-message">
    <a class="header" href="#signing-a-message">Signing a message</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.sign_message">API docs</a>
</h2>

By signing a message using the SDK we can provide a digital signature. Anyone with the `message`, `pubkey` and `signature` can verify the signature was created by the private key of this pubkey.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let message = "<message to sign>".to_string();
// Set to true to get a compact signature rather than a DER
let compact = true;

let sign_message_request = SignMessageRequest { message, compact };
let sign_message_response = sdk.sign_message(sign_message_request).await?;

let signature = sign_message_response.signature;
let pubkey = sign_message_response.pubkey;

info!("Pubkey: {}", pubkey);
info!("Signature: {}", signature);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Set to true to get a compact signature rather than a DER
let compact = true

let signMessageRequest = SignMessageRequest(
    message: "<message to sign>",
    compact: compact
)
let signMessageResponse = try await sdk
    .signMessage(request: signMessageRequest)

let signature = signMessageResponse.signature
let pubkey = signMessageResponse.pubkey

print("Pubkey: {}", pubkey);
print("Signature: {}", signature);
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val message = "<message to sign>"
// Set to true to get a compact signature rather than a DER
val compact = true
try {
    val signMessageRequest = SignMessageRequest(message, compact)
    val signMessageResponse = sdk.signMessage(signMessageRequest)

    val signature = signMessageResponse?.signature
    val pubkey = signMessageResponse?.pubkey

    // Log.v("Breez", "Pubkey: ${pubkey}")
    // Log.v("Breez", "Signature: ${signature}")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var message = "<message to sign>";
// Set to true to get a compact signature rather than a DER
var compact = true;
var signMessageRequest = new SignMessageRequest(
    message: message,
    compact: compact
);
var signMessageResponse = await sdk.SignMessage(request: signMessageRequest);

var signature = signMessageResponse.signature;
var pubkey = signMessageResponse.pubkey;

Console.WriteLine($"Pubkey: {pubkey}");
Console.WriteLine($"Signature: {signature}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Set to true to get a compact signature rather than a DER
const compact = true

const signMessageResponse = await sdk.signMessage({
  message: '<message to sign>',
  compact
})

const signature = signMessageResponse.signature
const pubkey = signMessageResponse.pubkey

console.log(`Pubkey: ${pubkey}`)
console.log(`Signature: ${signature}`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Set to true to get a compact signature rather than a DER
const compact = true

const signMessageResponse = await sdk.signMessage({
  message: '<message to sign>',
  compact
})

const signature = signMessageResponse.signature
const pubkey = signMessageResponse.pubkey

console.log(`Pubkey: ${pubkey}`)
console.log(`Signature: ${signature}`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Set to true to get a compact signature rather than a DER
bool compact = true;

SignMessageRequest signMessageRequest = SignMessageRequest(
  message: "<message to sign>",
  compact: compact,
);

SignMessageResponse signMessageResponse = await sdk.signMessage(
  request: signMessageRequest,
);

String signature = signMessageResponse.signature;
String pubkey = signMessageResponse.pubkey;

print("Pubkey: $pubkey");
print("Signature: $signature");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
message = "<message to sign>"
# Set to true to get a compact signature rather than a DER
compact = True
try:
    sign_message_request = SignMessageRequest(
        message=message, compact=compact
    )
    sign_message_response = await sdk.sign_message(request=sign_message_request)

    signature = sign_message_response.signature
    pubkey = sign_message_response.pubkey

    logging.debug(f"Pubkey: {pubkey}")
    logging.debug(f"Signature: {signature}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
message := "<message to sign>"
// Set to true to get a compact signature rather than a DER
compact := true

signMessageRequest := breez_sdk_spark.SignMessageRequest{
	Message: message,
	Compact: compact,
}
signMessageResponse, err := sdk.SignMessage(signMessageRequest)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

signature := signMessageResponse.Signature
pubkey := signMessageResponse.Pubkey

log.Printf("Pubkey: %v", pubkey)
log.Printf("Signature: %v", signature)
```

</section>

</custom-tabs>


<h2 id="verifying-a-message">
    <a class="header" href="#verifying-a-message">Verifying a message</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.check_message">API docs</a>
</h2>

You can prove control of a private key by verifying a `message` with it's `signature` and `pubkey`.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let check_message_request = CheckMessageRequest {
    message: "<message>".to_string(),
    pubkey: "<pubkey of signer>".to_string(),
    signature: "<message signature>".to_string(),
};
let check_message_response = sdk.check_message(check_message_request).await?;

let is_valid = check_message_response.is_valid;

info!("Signature valid: {}", is_valid);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let checkMessageRequest = CheckMessageRequest(
    message: "<message>",
    pubkey: "<pubkey of signer>",
    signature: "<message signature>"
)
let checkMessageResponse = try await sdk
    .checkMessage(request: checkMessageRequest)

let isValid = checkMessageResponse.isValid

print("Signature valid: {}", isValid);
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val message = "<message>"
val pubkey = "<pubkey of signer>"
val signature = "<message signature>"
try {
    val checkMessageRequest = CheckMessageRequest(message, pubkey, signature)
    val checkMessageResponse = sdk.checkMessage(checkMessageRequest)

    val isValid = checkMessageResponse?.isValid

    // Log.v("Breez", "Signature valid: ${isValid}")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var message = "<message>";
var pubkey = "<pubkey of signer>";
var signature = "<message signature>";
var checkMessageRequest = new CheckMessageRequest(
    message: message,
    pubkey: pubkey,
    signature: signature
);
var checkMessageResponse = await sdk.CheckMessage(request: checkMessageRequest);

var isValid = checkMessageResponse.isValid;

Console.WriteLine($"Signature valid: {isValid}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const checkMessageResponse = await sdk.checkMessage({
  message: '<message>',
  pubkey: '<pubkey of signer>',
  signature: '<message signature>'
})
const isValid = checkMessageResponse.isValid

console.log(`Signature valid: ${isValid}`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const checkMessageResponse = await sdk.checkMessage({
  message: '<message>',
  pubkey: '<pubkey of signer>',
  signature: '<message signature>'
})
const isValid = checkMessageResponse.isValid

console.log(`Signature valid: ${isValid}`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
CheckMessageRequest checkMessageRequest = CheckMessageRequest(
  message: "<message>",
  pubkey: "<pubkey of signer>",
  signature: "<message signature>",
);

CheckMessageResponse checkMessageResponse = await sdk.checkMessage(
  request: checkMessageRequest,
);

bool isValid = checkMessageResponse.isValid;

print("Signature valid: $isValid");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
message = "<message>"
pubkey = "<pubkey of signer>"
signature = "<message signature>"
try:
    check_message_request = CheckMessageRequest(
        message=message, pubkey=pubkey, signature=signature
    )
    check_message_response = await sdk.check_message(request=check_message_request)

    is_valid = check_message_response.is_valid

    logging.debug(f"Signature valid: {is_valid}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
message := "<message>"
pubkey := "<pubkey of signer>"
signature := "<message signature>"

checkMessageRequest := breez_sdk_spark.CheckMessageRequest{
	Message:   message,
	Pubkey:    pubkey,
	Signature: signature,
}
checkMessageResponse, err := sdk.CheckMessage(checkMessageRequest)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

isValid := checkMessageResponse.IsValid

log.Printf("Signature valid: %v", isValid)
```

</section>

</custom-tabs>


# Supporting fiat currencies

<h2 id="list-fiat-currencies">
    <a class="header" href="#list-fiat-currencies">List fiat currencies</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.list_fiat_currencies">API docs</a>
</h2>

You can get the full details of supported fiat currencies, such as symbols and localized names:

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let response = sdk.list_fiat_currencies().await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let response = try await sdk.listFiatCurrencies()
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val response = sdk.listFiatCurrencies()
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var response = await sdk.ListFiatCurrencies();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.listFiatCurrencies()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const response = await sdk.listFiatCurrencies()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
ListFiatCurrenciesResponse response = await sdk.listFiatCurrencies();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    response = await sdk.list_fiat_currencies()
except Exception as error:
    print(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
response, err := sdk.ListFiatCurrencies()

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}
```

</section>

</custom-tabs>


<h2 id="list-fiat-rates">
    <a class="header" href="#list-fiat-rates">Fetch fiat rates</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.list_fiat_rates">API docs</a>
</h2>

To get the current BTC rate in the various supported fiat currencies:

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let response = sdk.list_fiat_rates().await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let response = try await sdk.listFiatRates()
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val response = sdk.listFiatRates()
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var response = await sdk.ListFiatRates();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.listFiatRates()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const response = await sdk.listFiatRates()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
ListFiatRatesResponse response = await sdk.listFiatRates();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    response = await sdk.list_fiat_rates()
except Exception as error:
    print(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
response, err := sdk.ListFiatRates()

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}
```

</section>

</custom-tabs>


# End-User Fees

**The Breez SDK is free for developers.** 

There are small fees for end-users to send and receive payments.

You can learn more about end-user fees [here](https://docs.spark.money/wallets/estimate-fees).

# Handling tokens

How to send, receive and manage issued tokens using the Breez SDK - Nodeless *(Spark Implementation)*:

- **[Token payments]** - Send and receive [BTKN protocol](https://docs.spark.money/learn/tokens/hello-btkn) tokens
- **[Issuing tokens]** - Manage your issued [BTKN protocol](https://docs.spark.money/learn/tokens/hello-btkn) tokens

[Token payments]: token_payments.md
[Issuing tokens]: issuing_tokens.md

# Sending and receiving tokens

Spark supports tokens using the [BTKN protocol](https://docs.spark.money/learn/tokens/hello-btkn). The Breez SDK enables you to send and receive these tokens using the standard payments API.

<h2 id="fetching-the-balance">
    <a class="header" href="#fetching-the-balance">Fetching token balances</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.get_info">API docs</a>
</h2>

Token balances for all tokens currently held in the wallet can be retrieved along with general wallet information. Each token balance includes both the balance amount and the token metadata (identifier, name, ticker, issuer public key, etc.).

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let info = sdk
    .get_info(GetInfoRequest {
        // ensure_synced: true will ensure the SDK is synced with the Spark network
        // before returning the balance
        ensure_synced: Some(false),
    })
    .await?;

// Token balances are a map of token identifier to balance
let token_balances = info.token_balances;
for (token_id, token_balance) in token_balances {
    info!("Token ID: {}", token_id);
    info!("Balance: {}", token_balance.balance);
    info!("Name: {}", token_balance.token_metadata.name);
    info!("Ticker: {}", token_balance.token_metadata.ticker);
    info!("Decimals: {}", token_balance.token_metadata.decimals);
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// ensureSynced: true will ensure the SDK is synced with the Spark network
// before returning the balance
let info = try await sdk.getInfo(
    request: GetInfoRequest(
        ensureSynced: false
    ))

// Token balances are a map of token identifier to balance
let tokenBalances = info.tokenBalances
for (tokenId, tokenBalance) in tokenBalances {
    print("Token ID: \(tokenId)")
    print("Balance: \(tokenBalance.balance)")
    print("Name: \(tokenBalance.tokenMetadata.name)")
    print("Ticker: \(tokenBalance.tokenMetadata.ticker)")
    print("Decimals: \(tokenBalance.tokenMetadata.decimals)")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    // ensureSynced: true will ensure the SDK is synced with the Spark network
    // before returning the balance
    val info = sdk.getInfo(GetInfoRequest(false))

    // Token balances are a map of token identifier to balance
    val tokenBalances = info.tokenBalances
    for ((tokenId, tokenBalance) in tokenBalances) {
        println("Token ID: $tokenId")
        println("Balance: ${tokenBalance.balance}")
        println("Name: ${tokenBalance.tokenMetadata.name}")
        println("Ticker: ${tokenBalance.tokenMetadata.ticker}")
        println("Decimals: ${tokenBalance.tokenMetadata.decimals}")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// ensureSynced: true will ensure the SDK is synced with the Spark network
// before returning the balance
var info = await sdk.GetInfo(request: new GetInfoRequest(ensureSynced: false));

// Token balances are a map of token identifier to balance
var tokenBalances = info.tokenBalances;
foreach (var kvp in tokenBalances)
{
    var tokenId = kvp.Key;
    var tokenBalance = kvp.Value;
    Console.WriteLine($"Token ID: {tokenId}");
    Console.WriteLine($"Balance: {tokenBalance.balance}");
    Console.WriteLine($"Name: {tokenBalance.tokenMetadata.name}");
    Console.WriteLine($"Ticker: {tokenBalance.tokenMetadata.ticker}");
    Console.WriteLine($"Decimals: {tokenBalance.tokenMetadata.decimals}");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const info = await sdk.getInfo({
  // ensureSynced: true will ensure the SDK is synced with the Spark network
  // before returning the balance
  ensureSynced: false
})

// Token balances are a map of token identifier to balance
const tokenBalances = info.tokenBalances
for (const [tokenId, tokenBalance] of Object.entries(tokenBalances)) {
  console.log(`Token ID: ${tokenId}`)
  console.log(`Balance: ${tokenBalance.balance}`)
  console.log(`Name: ${tokenBalance.tokenMetadata.name}`)
  console.log(`Ticker: ${tokenBalance.tokenMetadata.ticker}`)
  console.log(`Decimals: ${tokenBalance.tokenMetadata.decimals}`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const info = await sdk.getInfo({
  // ensureSynced: true will ensure the SDK is synced with the Spark network
  // before returning the balance
  ensureSynced: false
})

// Token balances are a map of token identifier to balance
const tokenBalances = info.tokenBalances
for (const [tokenId, tokenBalance] of Object.entries(tokenBalances)) {
  console.log(`Token ID: ${tokenId}`)
  console.log(`Balance: ${tokenBalance.balance}`)
  console.log(`Name: ${tokenBalance.tokenMetadata.name}`)
  console.log(`Ticker: ${tokenBalance.tokenMetadata.ticker}`)
  console.log(`Decimals: ${tokenBalance.tokenMetadata.decimals}`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// ensureSynced: true will ensure the SDK is synced with the Spark network
// before returning the balance
final info = await sdk.getInfo(request: GetInfoRequest(ensureSynced: false));

// Token balances are a map of token identifier to balance
final tokenBalances = info.tokenBalances;
tokenBalances.forEach((tokenId, tokenBalance) {
  print('Token ID: $tokenId');
  print('Balance: ${tokenBalance.balance}');
  print('Name: ${tokenBalance.tokenMetadata.name}');
  print('Ticker: ${tokenBalance.tokenMetadata.ticker}');
  print('Decimals: ${tokenBalance.tokenMetadata.decimals}');
});
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    # ensure_synced: True will ensure the SDK is synced with the Spark network
    # before returning the balance
    info = await sdk.get_info(request=GetInfoRequest(ensure_synced=False))

    # Token balances are a map of token identifier to balance
    token_balances = info.token_balances
    for token_id, token_balance in token_balances.items():
        print(f"Token ID: {token_id}")
        print(f"Balance: {token_balance.balance}")
        print(f"Name: {token_balance.token_metadata.name}")
        print(f"Ticker: {token_balance.token_metadata.ticker}")
        print(f"Decimals: {token_balance.token_metadata.decimals}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
ensureSynced := false
info, err := sdk.GetInfo(breez_sdk_spark.GetInfoRequest{
	// EnsureSynced: true will ensure the SDK is synced with the Spark network
	// before returning the balance
	EnsureSynced: &ensureSynced,
})

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

// Token balances are a map of token identifier to balance
tokenBalances := info.TokenBalances
for tokenId, tokenBalance := range tokenBalances {
	log.Printf("Token ID: %v", tokenId)
	log.Printf("Balance: %v", tokenBalance.Balance)
	log.Printf("Name: %v", tokenBalance.TokenMetadata.Name)
	log.Printf("Ticker: %v", tokenBalance.TokenMetadata.Ticker)
	log.Printf("Decimals: %v", tokenBalance.TokenMetadata.Decimals)
}
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>
Token balances are cached for fast responses. For details on ensuring up-to-date balances, see the <a href="./get_info.md#fetching-the-balance">Fetching the balance</a> section.
</div>

<h2 id="fetching-token-metadata">
    <a class="header" href="#fetching-token-metadata">Fetching token metadata</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.get_tokens_metadata">API docs</a>
</h2>

Token metadata can be fetched for specific tokens by providing their identifiers. This is especially useful for retrieving metadata for tokens that are not currently held in the wallet. The metadata is cached locally after the first fetch for faster subsequent lookups.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let response = sdk
    .get_tokens_metadata(GetTokensMetadataRequest {
        token_identifiers: vec![
            String::from("<token identifier 1>"),
            String::from("<token identifier 2>"),
        ],
    })
    .await?;

let tokens_metadata = response.tokens_metadata;
for token_metadata in tokens_metadata {
    info!("Token ID: {}", token_metadata.identifier);
    info!("Name: {}", token_metadata.name);
    info!("Ticker: {}", token_metadata.ticker);
    info!("Decimals: {}", token_metadata.decimals);
    info!("Max Supply: {}", token_metadata.max_supply);
    info!("Is Freezable: {}", token_metadata.is_freezable);
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let response = try await sdk.getTokensMetadata(
    request: GetTokensMetadataRequest(tokenIdentifiers: [
        "<token identifier 1>", "<token identifier 2>",
    ]))

let tokensMetadata = response.tokensMetadata
for tokenMetadata in tokensMetadata {
    print("Token ID: \(tokenMetadata.identifier)")
    print("Name: \(tokenMetadata.name)")
    print("Ticker: \(tokenMetadata.ticker)")
    print("Decimals: \(tokenMetadata.decimals)")
    print("Max Supply: \(tokenMetadata.maxSupply)")
    print("Is Freezable: \(tokenMetadata.isFreezable)")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val response = 
        sdk.getTokensMetadata(
            GetTokensMetadataRequest(
                tokenIdentifiers = listOf("<token identifier 1>", "<token identifier 2>")
        )
    )   

    val tokensMetadata = response.tokensMetadata
    for (tokenMetadata in tokensMetadata) {
        println("Token ID: ${tokenMetadata.identifier}")
        println("Name: ${tokenMetadata.name}")
        println("Ticker: ${tokenMetadata.ticker}")
        println("Decimals: ${tokenMetadata.decimals}")
        println("Max Supply: ${tokenMetadata.maxSupply}")
        println("Is Freezable: ${tokenMetadata.isFreezable}")
    }
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var response = await sdk.GetTokensMetadata(
    request: new GetTokensMetadataRequest(
        tokenIdentifiers: new List<string> { "<token identifier 1>", "<token identifier 2>" }
    )
);

var tokensMetadata = response.tokensMetadata;
foreach (var tokenMetadata in tokensMetadata)
{
    Console.WriteLine($"Token ID: {tokenMetadata.identifier}");
    Console.WriteLine($"Name: {tokenMetadata.name}");
    Console.WriteLine($"Ticker: {tokenMetadata.ticker}");
    Console.WriteLine($"Decimals: {tokenMetadata.decimals}");
    Console.WriteLine($"Max Supply: {tokenMetadata.maxSupply}");
    Console.WriteLine($"Is Freezable: {tokenMetadata.isFreezable}");
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.getTokensMetadata({
  tokenIdentifiers: ['<token identifier 1>', '<token identifier 2>']
})

const tokensMetadata = response.tokensMetadata
for (const tokenMetadata of tokensMetadata) {
  console.log(`Token ID: ${tokenMetadata.identifier}`)
  console.log(`Name: ${tokenMetadata.name}`)
  console.log(`Ticker: ${tokenMetadata.ticker}`)
  console.log(`Decimals: ${tokenMetadata.decimals}`)
  console.log(`Max Supply: ${tokenMetadata.maxSupply}`)
  console.log(`Is Freezable: ${tokenMetadata.isFreezable}`)
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const response = await sdk.getTokensMetadata({
  tokenIdentifiers: ['<token identifier 1>', '<token identifier 2>']
})

const tokensMetadata = response.tokensMetadata
for (const tokenMetadata of tokensMetadata) {
  console.log(`Token ID: ${tokenMetadata.identifier}`)
  console.log(`Name: ${tokenMetadata.name}`)
  console.log(`Ticker: ${tokenMetadata.ticker}`)
  console.log(`Decimals: ${tokenMetadata.decimals}`)
  console.log(`Max Supply: ${tokenMetadata.maxSupply}`)
  console.log(`Is Freezable: ${tokenMetadata.isFreezable}`)
}
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final response = await sdk.getTokensMetadata(
  request: GetTokensMetadataRequest(
    tokenIdentifiers: ['<token identifier 1>', '<token identifier 2>']
    )
  );

final tokensMetadata = response.tokensMetadata;
for (final tokenMetadata in tokensMetadata) {
  print('Token ID: $tokenMetadata.identifier');
  print('Name: ${tokenMetadata.name}');
  print('Ticker: ${tokenMetadata.ticker}');
  print('Decimals: ${tokenMetadata.decimals}');
  print('Max Supply: ${tokenMetadata.maxSupply}');
  print('Is Freezable: ${tokenMetadata.isFreezable}');
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    response = await sdk.get_tokens_metadata(
        request=GetTokensMetadataRequest(
            token_identifiers=["<token identifier 1>", "<token identifier 2>"]
            )
        )

    tokens_metadata = response.tokens_metadata
    for token_metadata in tokens_metadata:
        print(f"Token ID: {token_metadata.identifier}")
        print(f"Name: {token_metadata.name}")
        print(f"Ticker: {token_metadata.ticker}")
        print(f"Decimals: {token_metadata.decimals}")
        print(f"Max Supply: {token_metadata.max_supply}")
        print(f"Is Freezable: {token_metadata.is_freezable}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
tokenIdentifiers := []string{"<token identifier 1>", "<token identifier 2>"}
response, err := sdk.GetTokensMetadata(breez_sdk_spark.GetTokensMetadataRequest{
	TokenIdentifiers: tokenIdentifiers,
})

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

tokensMetadata := response.TokensMetadata
for _, tokenMetadata := range tokensMetadata {
	log.Printf("Token ID: %v", tokenMetadata.Identifier)
	log.Printf("Name: %v", tokenMetadata.Name)
	log.Printf("Ticker: %v", tokenMetadata.Ticker)
	log.Printf("Decimals: %v", tokenMetadata.Decimals)
	log.Printf("Max Supply: %v", tokenMetadata.MaxSupply)
	log.Printf("Is Freezable: %v", tokenMetadata.IsFreezable)
}
```

</section>

</custom-tabs>


<h2 id="receiving-payments">
    <a class="header" href="#receiving-payments">Receiving a token payment</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.receive_payment">API docs</a>
</h2>

Token payments can be received using either a Spark address or invoice. Using an invoice is useful to impose restrictions on the payment, such as the token to receive, amount, expiry, and who can pay it.

### Spark address

Token payments use the same Spark address as Bitcoin payments - no separate address is required. Your application can retrieve the Spark address as described in the [Receiving a payment](./receive_payment.md#spark) guide. The payer will use this address to send tokens to the wallet.

### Spark invoice

Spark token invoices can be created using the same API as Bitcoin Spark invoices. The only difference is that a token identifier is provided.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let token_identifier = Some("<token identifier>".to_string());
let optional_description = Some("<invoice description>".to_string());
let optional_amount = Some(5_000);
// Optionally set the expiry UNIX timestamp in seconds
let optional_expiry_time_seconds = Some(1716691200);
let optional_sender_public_key = Some("<sender public key>".to_string());

let response = sdk
    .receive_payment(ReceivePaymentRequest {
        payment_method: ReceivePaymentMethod::SparkInvoice {
            token_identifier,
            description: optional_description,
            amount: optional_amount,
            expiry_time: optional_expiry_time_seconds,
            sender_public_key: optional_sender_public_key,
        },
    })
    .await?;

let payment_request = response.payment_request;
info!("Payment request: {payment_request}");
let receive_fee = response.fee;
info!("Fees: {receive_fee} token base units");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let tokenIdentifier = "<token identifier>"
let optionalDescription = "<invoice description>"
let optionalAmount = BInt(5_000)
// Optionally set the expiry UNIX timestamp in seconds
let optionalExpiryTimeSeconds: UInt64 = 1_716_691_200
let optionalSenderPublicKey = "<sender public key>"

let response =
    try await sdk
    .receivePayment(
        request: ReceivePaymentRequest(
            paymentMethod: ReceivePaymentMethod.sparkInvoice(
                amount: optionalAmount,
                tokenIdentifier: tokenIdentifier,
                expiryTime: optionalExpiryTimeSeconds,
                description: optionalDescription,
                senderPublicKey: optionalSenderPublicKey
            )
        ))

let paymentRequest = response.paymentRequest
print("Payment request: \(paymentRequest)")
let receiveFeeSats = response.fee
print("Fees: \(receiveFeeSats) token base units")
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val tokenIdentifier = "<token identifier>"
    val optionalDescription = "<invoice description>"
    // Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in
    // package)
    val optionalAmount = BigInteger.fromLong(5_000L)
    // Android (BigInteger from java.math)
    // val optionalAmount = BigInteger.valueOf(5_000L)
    // Optionally set the expiry UNIX timestamp in seconds
    val optionalExpiryTimeSeconds = 1716691200.toULong()
    val optionalSenderPublicKey = "<sender public key>"

    val request = ReceivePaymentRequest(
        ReceivePaymentMethod.SparkInvoice(
            tokenIdentifier = tokenIdentifier,
            description = optionalDescription,
            amount = optionalAmount,
            expiryTime = optionalExpiryTimeSeconds,
            senderPublicKey = optionalSenderPublicKey
        )
    )
    val response = sdk.receivePayment(request)

    val paymentRequest = response.paymentRequest
    println("Payment request: $paymentRequest")
    val receiveFee = response.fee
    println("Fees: $receiveFee token base units")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var tokenIdentifier = "<token identifier>";
var optionalDescription = "<invoice description>";
var optionalAmount = new BigInteger(5000);
// Optionally set the expiry UNIX timestamp in seconds
var optionalExpiryTimeSeconds = 1716691200UL;
var optionalSenderPublicKey = "<sender public key>";

var request = new ReceivePaymentRequest(
    paymentMethod: new ReceivePaymentMethod.SparkInvoice(
        tokenIdentifier: tokenIdentifier,
        description: optionalDescription,
        amount: optionalAmount,
        expiryTime: optionalExpiryTimeSeconds,
        senderPublicKey: optionalSenderPublicKey
    )
);
var response = await sdk.ReceivePayment(request: request);

var paymentRequest = response.paymentRequest;
Console.WriteLine($"Payment request: {paymentRequest}");
var receiveFee = response.fee;
Console.WriteLine($"Fees: {receiveFee} token base units");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const tokenIdentifier = '<token identifier>'
const optionalDescription = '<invoice description>'
const optionalAmount = '5000'
// Optionally set the expiry UNIX timestamp in seconds
const optionalExpiryTimeSeconds = 1716691200
const optionalSenderPublicKey = '<sender public key>'

const response = await sdk.receivePayment({
  paymentMethod: {
    type: 'sparkInvoice',
    tokenIdentifier,
    description: optionalDescription,
    amount: optionalAmount,
    expiryTime: optionalExpiryTimeSeconds,
    senderPublicKey: optionalSenderPublicKey
  }
})

const paymentRequest = response.paymentRequest
console.log(`Payment request: ${paymentRequest}`)
const receiveFeeSats = response.fee
console.log(`Fees: ${receiveFeeSats} token base units`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const tokenIdentifier = '<token identifier>'
const optionalDescription = '<invoice description>'
const optionalAmount = BigInt(5_000)
// Optionally set the expiry UNIX timestamp in seconds
const optionalExpiryTimeSeconds = BigInt(1716691200)
const optionalSenderPublicKey = '<sender public key>'

const response = await sdk.receivePayment({
  paymentMethod: new ReceivePaymentMethod.SparkInvoice({
    tokenIdentifier,
    description: optionalDescription,
    amount: optionalAmount,
    expiryTime: optionalExpiryTimeSeconds,
    senderPublicKey: optionalSenderPublicKey
  })
})

const paymentRequest = response.paymentRequest
console.log(`Payment request: ${paymentRequest}`)
const receiveFee = response.fee
console.log(`Fees: ${receiveFee} token base units`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String tokenIdentifier = '<token identifier>';
String optionalDescription = "<invoice description>";
BigInt optionalAmount = BigInt.from(5000);
// Optionally set the expiry UNIX timestamp in seconds
BigInt optionalExpiryTimeSeconds = BigInt.from(1716691200);
String optionalSenderPublicKey = "<sender public key>"; 

ReceivePaymentRequest request =
    ReceivePaymentRequest(paymentMethod: ReceivePaymentMethod.sparkInvoice(
      tokenIdentifier: tokenIdentifier,
      description: optionalDescription,
      amount: optionalAmount,
      expiryTime: optionalExpiryTimeSeconds,
      senderPublicKey: optionalSenderPublicKey,
    ));
ReceivePaymentResponse response = await sdk.receivePayment(
  request: request,
);

String paymentRequest = response.paymentRequest;
print("Payment request: $paymentRequest");
BigInt receiveFee = response.fee;
print("Fees: $receiveFee token base units");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    token_identifier = "<token identifier>"
    optional_description = "<invoice description>"
    optional_amount = 5_000
    # Optionally set the expiry UNIX timestamp in seconds
    optional_expiry_time_seconds = 1716691200
    optional_sender_public_key = "<sender public key>"

    request = ReceivePaymentRequest(
        payment_method=ReceivePaymentMethod.SPARK_INVOICE(
            token_identifier=token_identifier,
            description=optional_description,
            amount=optional_amount,
            expiry_time=optional_expiry_time_seconds,
            sender_public_key=optional_sender_public_key,
        )
    )
    response = await sdk.receive_payment(request=request)

    payment_request = response.payment_request
    print(f"Payment request: {payment_request}")
    receive_fee = response.fee
    print(f"Fees: {receive_fee} token base units")
    return response
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
tokenIdentifier := "<token identifier>"
optionalDescription := "<invoice description>"
optionalAmount := new(big.Int).SetInt64(5_000)
// Optionally set the expiry UNIX timestamp in seconds
optionalExpiryTimeSeconds := uint64(1716691200)
optionalSenderPublicKey := "<sender public key>"

request := breez_sdk_spark.ReceivePaymentRequest{
	PaymentMethod: breez_sdk_spark.ReceivePaymentMethodSparkInvoice{
		TokenIdentifier: &tokenIdentifier,
		Description:     &optionalDescription,
		Amount:          &optionalAmount,
		ExpiryTime:      &optionalExpiryTimeSeconds,
		SenderPublicKey: &optionalSenderPublicKey,
	},
}

response, err := sdk.ReceivePayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

paymentRequest := response.PaymentRequest
log.Printf("Payment Request: %v", paymentRequest)
receiveFees := response.Fee
log.Printf("Fees: %v token base units", receiveFees)
```

</section>

</custom-tabs>


<h2 id="preparing-payments">
    <a class="header" href="#preparing-payments">Sending a token payment</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.prepare_send_payment">API docs</a>
</h2>

To send tokens, provide a Spark address as the payment request. The token identifier must be specified in one of two ways:

1. **Using a Spark invoice**: If the payee provides a Spark address with an embedded token identifier and amount (a Spark invoice), the SDK automatically extracts and uses those values.
2. **Manual specification**: For a plain Spark address without embedded payment details, your application must provide both the token identifier and amount parameters when preparing the payment.

Your application can use the [parse](./parse.md) functionality to determine if a Spark address contains embedded token payment details before preparing the payment.

The code example below demonstrates manual specification. Follow the standard prepare/send payment flow as described in the [Sending a payment](./send_payment.md) guide.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let payment_request = "<spark address or invoice>".to_string();
// Token identifier must match the invoice in case it specifies one.
let token_identifier = Some("<token identifier>".to_string());
// Set the amount of tokens you wish to send.
let optional_amount = Some(1_000);

let prepare_response = sdk
    .prepare_send_payment(PrepareSendPaymentRequest {
        payment_request,
        amount: optional_amount,
        token_identifier,
        conversion_options: None,
    })
    .await?;

// If the fees are acceptable, continue to send the token payment
match &prepare_response.payment_method {
    SendPaymentMethod::SparkAddress {
        fee,
        token_identifier: token_id,
        ..
    } => {
        info!("Token ID: {:?}", token_id);
        info!("Fees: {} token base units", fee);
    }
    SendPaymentMethod::SparkInvoice {
        fee,
        token_identifier: token_id,
        ..
    } => {
        info!("Token ID: {:?}", token_id);
        info!("Fees: {} token base units", fee);
    }
    _ => {}
}

// Send the token payment
let send_response = sdk
    .send_payment(SendPaymentRequest {
        prepare_response,
        options: None,
        idempotency_key: None,
    })
    .await?;
let payment = send_response.payment;
info!("Payment: {payment:?}");
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let paymentRequest = "<spark address or invoice>"
// Token identifier must match the invoice in case it specifies one.
let tokenIdentifier = "<token identifier>"
// Set the amount of tokens you wish to send. (requires 'import BigNumber')
let optionalAmount = BInt(1_000)

let prepareResponse = try await sdk.prepareSendPayment(
    request: PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        amount: optionalAmount,
        tokenIdentifier: tokenIdentifier
    ))

// If the fees are acceptable, continue to send the token payment
if case let .sparkAddress(address, fee, tokenId) = prepareResponse.paymentMethod {
    print("Token ID: \(String(describing: tokenId))")
    print("Fees: \(fee) token base units")
}
if case let .sparkInvoice(invoice, fee, tokenId) = prepareResponse.paymentMethod {
    print("Token ID: \(String(describing: tokenId))")
    print("Fees: \(fee) token base units")
}

// Send the token payment
let sendResponse = try await sdk.sendPayment(
    request: SendPaymentRequest(
        prepareResponse: prepareResponse,
        options: nil
    ))
let payment = sendResponse.payment
print("Payment: \(payment)")
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val paymentRequest = "<spark address or invoice>"
    // Token identifier must match the invoice in case it specifies one.
    val tokenIdentifier = "<token identifier>"
    // Set the amount of tokens you wish to send.
    // Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in
    // package)
    val optionalAmount = BigInteger.fromLong(1_000L)
    // Android (BigInteger from java.math)
    // val optionalAmount = BigInteger.valueOf(1_000L)

    val prepareResponse =
        sdk.prepareSendPayment(
            PrepareSendPaymentRequest(
                paymentRequest = paymentRequest,
                amount = optionalAmount,
                tokenIdentifier = tokenIdentifier
            )
        )

    // If the fees are acceptable, continue to send the token payment
    when (val method = prepareResponse.paymentMethod) {
        is SendPaymentMethod.SparkAddress -> {
            println("Token ID: ${method.tokenIdentifier}")
            println("Fees: ${method.fee} token base units")
        }
        is SendPaymentMethod.SparkInvoice -> {
            println("Token ID: ${method.tokenIdentifier}")
            println("Fees: ${method.fee} token base units")
        }
        else -> {}
    }

    // Send the token payment
    val sendResponse =
        sdk.sendPayment(
            SendPaymentRequest(prepareResponse = prepareResponse, options = null)
        )
    val payment = sendResponse.payment
    println("Payment: $payment")
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var paymentRequest = "<spark address or invoice>";
// Token identifier must match the invoice in case it specifies one.
var tokenIdentifier = "<token identifier>";
// Set the amount of tokens you wish to send.
var optionalAmount = new BigInteger(1000);

var prepareResponse = await sdk.PrepareSendPayment(
    request: new PrepareSendPaymentRequest(
        paymentRequest: paymentRequest,
        amount: optionalAmount,
        tokenIdentifier: tokenIdentifier
    )
);

// If the fees are acceptable, continue to send the token payment
if (prepareResponse.paymentMethod is SendPaymentMethod.SparkAddress sparkAddress)
{
    Console.WriteLine($"Token ID: {sparkAddress.tokenIdentifier}");
    Console.WriteLine($"Fees: {sparkAddress.fee} token base units");
}
if (prepareResponse.paymentMethod is SendPaymentMethod.SparkInvoice sparkInvoice)
{
    Console.WriteLine($"Token ID: {sparkInvoice.tokenIdentifier}");
    Console.WriteLine($"Fees: {sparkInvoice.fee} token base units");
}

// Send the token payment
var sendResponse = await sdk.SendPayment(
    request: new SendPaymentRequest(
        prepareResponse: prepareResponse,
        options: null
    )
);
var payment = sendResponse.payment;
Console.WriteLine($"Payment: {payment}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const paymentRequest = '<spark address or invoice>'
// Token identifier must match the invoice in case it specifies one.
const tokenIdentifier = '<token identifier>'
// Set the amount of tokens you wish to send.
const optionalAmount = BigInt(1_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: optionalAmount,
  tokenIdentifier
})

// If the fees are acceptable, continue to send the token payment
if (prepareResponse.paymentMethod.type === 'sparkAddress') {
  console.log(`Token ID: ${prepareResponse.paymentMethod.tokenIdentifier}`)
  console.log(`Fees: ${prepareResponse.paymentMethod.fee} token base units`)
}
if (prepareResponse.paymentMethod.type === 'sparkInvoice') {
  console.log(`Token ID: ${prepareResponse.paymentMethod.tokenIdentifier}`)
  console.log(`Fees: ${prepareResponse.paymentMethod.fee} token base units`)
}

// Send the token payment
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options: undefined
})
const payment = sendResponse.payment
console.log(`Payment: ${JSON.stringify(payment)}`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const paymentRequest = '<spark address or invoice>'
// Token identifier must match the invoice in case it specifies one.
const tokenIdentifier = '<token identifier>'
// Set the amount of tokens you wish to send.
const optionalAmount = BigInt(1_000)

const prepareResponse = await sdk.prepareSendPayment({
  paymentRequest,
  amount: optionalAmount,
  tokenIdentifier,
  conversionOptions: undefined
})

// If the fees are acceptable, continue to send the token payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.SparkAddress) {
  console.log(`Token ID: ${prepareResponse.paymentMethod.inner.tokenIdentifier}`)
  console.log(`Fees: ${prepareResponse.paymentMethod.inner.fee} token base units`)
}
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.SparkInvoice) {
  console.log(`Token ID: ${prepareResponse.paymentMethod.inner.tokenIdentifier}`)
  console.log(`Fees: ${prepareResponse.paymentMethod.inner.fee} token base units`)
}

// Send the token payment
const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options: undefined,
  idempotencyKey: undefined
})
const payment = sendResponse.payment
console.log(`Payment: ${JSON.stringify(payment)}`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final paymentRequest = '<spark address or invoice>';
// Token identifier must match the invoice in case it specifies one.
final tokenIdentifier = '<token identifier>';
// Set the amount of tokens you wish to send.
final optionalAmount = BigInt.from(1000);

final prepareResponse = await sdk.prepareSendPayment(
  request: PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    amount: optionalAmount,
    tokenIdentifier: tokenIdentifier,
  ),
);

// If the fees are acceptable, continue to send the token payment
if (prepareResponse.paymentMethod is SendPaymentMethod_SparkAddress) {
  final method = prepareResponse.paymentMethod as SendPaymentMethod_SparkAddress;
  print('Token ID: ${method.tokenIdentifier}');
  print('Fees: ${method.fee} token base units');
}
if (prepareResponse.paymentMethod is SendPaymentMethod_SparkInvoice) {
  final method = prepareResponse.paymentMethod as SendPaymentMethod_SparkInvoice;
  print('Token ID: ${method.tokenIdentifier}');
  print('Fees: ${method.fee} token base units');
}

// Send the token payment
final sendResponse = await sdk.sendPayment(
  request: SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: null,
  ),
);
final payment = sendResponse.payment;
print('Payment: $payment');
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    payment_request = "<spark address or invoice>"
    # Token identifier must match the invoice in case it specifies one.
    token_identifier = "<token identifier>"
    # Set the amount of tokens you wish to send.
    optional_amount = 1_000

    prepare_response = await sdk.prepare_send_payment(
        request=PrepareSendPaymentRequest(
            payment_request=payment_request,
            amount=optional_amount,
            token_identifier=token_identifier,
        )
    )

    # If the fees are acceptable, continue to send the token payment
    if isinstance(prepare_response.payment_method, SendPaymentMethod.SPARK_ADDRESS):
        print(f"Token ID: {prepare_response.payment_method.token_identifier}")
        print(f"Fees: {prepare_response.payment_method.fee} token base units")
    if isinstance(prepare_response.payment_method, SendPaymentMethod.SPARK_INVOICE):
        print(f"Token ID: {prepare_response.payment_method.token_identifier}")
        print(f"Fees: {prepare_response.payment_method.fee} token base units")

    # Send the token payment
    send_response = await sdk.send_payment(
        request=SendPaymentRequest(
            prepare_response=prepare_response,
            options=None,
        )
    )
    payment = send_response.payment
    print(f"Payment: {payment}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
paymentRequest := "<spark address or invoice>"
// Token identifier must match the invoice in case it specifies one.
tokenIdentifier := "<token identifier>"
// Set the amount of tokens you wish to send.
optionalAmount := new(big.Int).SetInt64(1_000)

prepareResponse, err := sdk.PrepareSendPayment(breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest:  paymentRequest,
	Amount:          &optionalAmount,
	TokenIdentifier: &tokenIdentifier,
})

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

// If the fees are acceptable, continue to send the token payment
switch method := prepareResponse.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodSparkAddress:
	log.Printf("Token ID: %v", method.TokenIdentifier)
	log.Printf("Fees: %v token base units", method.Fee)
case breez_sdk_spark.SendPaymentMethodSparkInvoice:
	log.Printf("Token ID: %v", method.TokenIdentifier)
	log.Printf("Fees: %v token base units", method.Fee)
}

// Send the token payment
sendResponse, err := sdk.SendPayment(breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	Options:         nil,
})

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

payment := sendResponse.Payment
log.Printf("Payment: %#v", payment)
```

</section>

</custom-tabs>


<h2 id="listing-payments">
    <a class="header" href="#listing-payments">Listing token payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.list_payments">API docs</a>
</h2>

Token payments are included in the regular payment history alongside Bitcoin payments. Your application can retrieve and distinguish token payments from other payment types using the standard payment listing functionality. See the [Listing payments](./list_payments.md) guide for more details.

<h2 id="issuing-tokens">
    <a class="header" href="#issuing-tokens">Issuing tokens</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.get_token_issuer">API docs</a>
</h2>

The Breez SDK provides a specialized Token Issuer interface for managing custom token issuance on the Spark network using the using the [BTKN protocol](https://docs.spark.money/learn/tokens/hello-btkn). This functionality enables token creators to issue, manage, and control their own tokens with advanced features.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let token_issuer = sdk.get_token_issuer();
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let tokenIssuer = sdk.getTokenIssuer()
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val tokenIssuer = sdk.getTokenIssuer()
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var tokenIssuer = sdk.GetTokenIssuer();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const tokenIssuer = sdk.getTokenIssuer()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const tokenIssuer = sdk.getTokenIssuer()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
TokenIssuer tokenIssuer = sdk.getTokenIssuer();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
token_issuer = sdk.get_token_issuer()
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
tokenIssuer := sdk.GetTokenIssuer()
```

</section>

</custom-tabs>


<h2 id="token-creation">
    <a class="header" href="#token-creation">Token creation</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.TokenIssuer.html#method.create_issuer_token">API docs</a>
</h2>

Create a custom token with configurable parameters. Define the decimal precision, max supply and if the token can be frozen.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let request = CreateIssuerTokenRequest {
    name: "My Token".to_string(),
    ticker: "MTK".to_string(),
    decimals: 6,
    is_freezable: false,
    max_supply: 1_000_000,
};
let token_metadata = token_issuer.create_issuer_token(request).await?;
info!("Token identifier: {}", token_metadata.identifier);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let request = CreateIssuerTokenRequest(
    name: "My Token",
    ticker: "MTK",
    decimals: UInt32(6),
    isFreezable: false,
    maxSupply: BInt(1_000_000)
)
let tokenMetadata = try await tokenIssuer.createIssuerToken(request: request)
print("Token identifier: {}", tokenMetadata.identifier)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val request =
            CreateIssuerTokenRequest(
                    name = "My Token",
                    ticker = "MTK",
                    decimals = 6.toUInt(),
                    isFreezable = false,
                    maxSupply = BigInteger.fromLong(1_000_000L)
            )
    val tokenMetadata = tokenIssuer.createIssuerToken(request)
    // Log.v("Breez", "Token identifier: ${tokenMetadata.identifier}")
} catch (e: Exception) {
    // Handle exception
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var maxSupply = new BigInteger(1000000);
var request = new CreateIssuerTokenRequest(
    name: "My Token",
    ticker: "MTK",
    decimals: 6,
    isFreezable: false,
    maxSupply: maxSupply
);

var tokenMetadata = await tokenIssuer.CreateIssuerToken(request);
Console.WriteLine($"Token identifier: {tokenMetadata.identifier}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const tokenMetadata = await tokenIssuer.createIssuerToken({
  name: 'My Token',
  ticker: 'MTK',
  decimals: 6,
  isFreezable: false,
  maxSupply: BigInt(1_000_000)
})
console.debug(`Token identifier: ${tokenMetadata.identifier}`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const tokenMetadata = await tokenIssuer.createIssuerToken({
  name: 'My Token',
  ticker: 'MTK',
  decimals: 6,
  isFreezable: false,
  maxSupply: BigInt(1_000_000)
})
console.debug(`Token identifier: ${tokenMetadata.identifier}`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
CreateIssuerTokenRequest request = CreateIssuerTokenRequest(
  name: "My Token",
  ticker: "MTK",
  decimals: 6,
  isFreezable: false,
  maxSupply: BigInt.from(1000000),
);
TokenMetadata tokenMetadata =
    await tokenIssuer.createIssuerToken(request: request);
print("Token identifier: ${tokenMetadata.identifier}");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    request = CreateIssuerTokenRequest(
        name="My Token",
        ticker="MTK",
        decimals=6,
        is_freezable=False,
        max_supply=1_000_000,
    )
    token_metadata = await token_issuer.create_issuer_token(request)
    logging.debug(f"Token identifier: {token_metadata.identifier}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.CreateIssuerTokenRequest{
	Name:        "My Token",
	Ticker:      "MTK",
	Decimals:    6,
	IsFreezable: false,
	MaxSupply:   new(big.Int).SetInt64(1_000_000),
}
tokenMetadata, err := tokenIssuer.CreateIssuerToken(request)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}
log.Printf("Token identifier: %v", tokenMetadata.Identifier)
```

</section>

</custom-tabs>


### Creating multiple tokens

Token creation is limited to one token per issuer wallet. If you need to create and then manage more than one token using the same mnemonic, we recommend using different account numbers when initializing the SDK.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let account_number = 21;

let mnemonic = "<mnemonic words>".to_string();
let seed = Seed::Mnemonic {
    mnemonic,
    passphrase: None,
};
let config = default_config(Network::Mainnet);
let mut builder = SdkBuilder::new(config, seed);
builder = builder.with_default_storage("./.data".to_string());

// Set the account number for the SDK
builder = builder.with_key_set(KeySetConfig {
    key_set_type: KeySetType::Default,
    use_address_index: false,
    account_number: Some(account_number),
});

let sdk = builder.build().await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let accountNumber = UInt32(21)

let mnemonic = "<mnemonic words>"
let seed = Seed.mnemonic(mnemonic: mnemonic, passphrase: nil)
let config = defaultConfig(network: Network.mainnet)
let builder = SdkBuilder(config: config, seed: seed)
await builder.withDefaultStorage(storageDir: "./.data")

// Set the account number for the SDK
let keySetConfig = KeySetConfig(
    keySetType: KeySetType.default,
    useAddressIndex: false,
    accountNumber: accountNumber
)
await builder.withKeySet(config: keySetConfig)

let sdk = try await builder.build()
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val accountNumber = 21u

val mnemonic = "<mnemonic words>"
val seed = Seed.Mnemonic(mnemonic, null)
val config = defaultConfig(Network.MAINNET)
config.apiKey = "<breez api key>"

try {
    val builder = SdkBuilder(config, seed)
    builder.withDefaultStorage("./.data")

    // Set the account number for the SDK
    val keySetConfig = KeySetConfig(
        keySetType = KeySetType.DEFAULT,
        useAddressIndex = false,
        accountNumber = accountNumber
    )
    builder.withKeySet(keySetConfig)

    val sdk = builder.build()
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var accountNumber = 21u;

var mnemonic = "<mnemonic words>";
var seed = new Seed.Mnemonic(mnemonic: mnemonic, passphrase: null);
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    apiKey = "<breez api key>"
};
var builder = new SdkBuilder(config: config, seed: seed);
await builder.WithDefaultStorage(storageDir: "./.data");

// Set the account number for the SDK
var keySetConfig = new KeySetConfig(
    keySetType: KeySetType.Default,
    useAddressIndex: false,
    accountNumber
);
await builder.WithKeySet(keySetConfig);

var sdk = await builder.Build();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
await init()

const accountNumber = 21

const mnemonic = '<mnemonic words>'
const seed: Seed = { type: 'mnemonic', mnemonic, passphrase: undefined }
const config = defaultConfig('mainnet')
config.apiKey = '<breez api key>'
let builder = SdkBuilder.new(config, seed)
builder = await builder.withDefaultStorage('./.data')

// Set the account number for the SDK
builder = builder.withKeySet({
  keySetType: 'default',
  useAddressIndex: false,
  accountNumber
})

const sdk = await builder.build()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const accountNumber = 21

const mnemonic = '<mnemonics words>'
const seed = new Seed.Mnemonic({ mnemonic, passphrase: undefined })
const config = defaultConfig(Network.Mainnet)
config.apiKey = '<breez api key>'
const builder = new SdkBuilder(config, seed)
await builder.withDefaultStorage(`${RNFS.DocumentDirectoryPath}/data`)

// Set the account number for the SDK
const keySetConfig: KeySetConfig = {
  keySetType: KeySetType.Default,
  useAddressIndex: false,
  accountNumber
}
await builder.withKeySet(keySetConfig)

const sdk = await builder.build()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
var accountNumber = 21;

String mnemonic = "<mnemonic words>";
final seed = Seed.mnemonic(mnemonic: mnemonic, passphrase: null);
final config = defaultConfig(network: Network.mainnet)
    .copyWith(apiKey: "<breez api key>");
final builder = SdkBuilder(config: config, seed: seed);
builder.withDefaultStorage(storageDir: "./.data");

// Set the account number for the SDK
builder.withKeySet(
  config: KeySetConfig(
    keySetType: KeySetType.default_,
    useAddressIndex: false,
    accountNumber: accountNumber,
  ),
);

var sdk = await builder.build();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
account_number = 21

mnemonic = "<mnemonic words>"
seed = Seed.MNEMONIC(mnemonic=mnemonic, passphrase=None)
config = default_config(network=Network.MAINNET)
config.api_key = "<breez api key>"
try:
    builder = SdkBuilder(config=config, seed=seed)
    await builder.with_default_storage(storage_dir="./.data")

    # Set the account number for the SDK
    key_set_config = KeySetConfig(
        key_set_type=KeySetType.DEFAULT,
        use_address_index=False,
        account_number=account_number,
    )
    await builder.with_key_set(config=key_set_config)

    sdk = await builder.build()
    return sdk
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
accountNumber := uint32(21)

mnemonic := "<mnemonic words>"
var seed breez_sdk_spark.Seed = breez_sdk_spark.SeedMnemonic{
	Mnemonic:   mnemonic,
	Passphrase: nil,
}
apiKey := "<breez api key>"
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
config.ApiKey = &apiKey
builder := breez_sdk_spark.NewSdkBuilder(config, seed)
builder.WithDefaultStorage("./.data")

// Set the account number for the SDK
keySetConfig := breez_sdk_spark.KeySetConfig{
	KeySetType:      breez_sdk_spark.KeySetTypeDefault,
	UseAddressIndex: false,
	AccountNumber:   &accountNumber,
}
builder.WithKeySet(keySetConfig)

sdk, err := builder.Build()
```

</section>

</custom-tabs>


## Supply Management

<h3 id="minting-a-token">
    <a class="header" href="#minting-a-token">Minting a token</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.TokenIssuer.html#method.mint_issuer_token">API docs</a>
</h3>

Mint to increase the circulating supply of the token.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let request = MintIssuerTokenRequest { amount: 1_000 };

let payment = token_issuer.mint_issuer_token(request).await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let request = MintIssuerTokenRequest(
    amount: BInt(1_000)
)
let payment = try await tokenIssuer.mintIssuerToken(request: request)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val request =
            MintIssuerTokenRequest(
                    amount = BigInteger.fromLong(1_000L),
            )
    val payment = tokenIssuer.mintIssuerToken(request)
} catch (e: Exception) {
    // Handle exception
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var amount = new BigInteger(1000);
var request = new MintIssuerTokenRequest(
    amount: amount
);
var payment = await tokenIssuer.MintIssuerToken(request);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const payment = await tokenIssuer.mintIssuerToken({
  amount: BigInt(1_000)
})
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const payment = await tokenIssuer.mintIssuerToken({
  amount: BigInt(1_000)
})
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
MintIssuerTokenRequest request = MintIssuerTokenRequest(
  amount: BigInt.from(1000),
);
Payment payment = await tokenIssuer.mintIssuerToken(request: request);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    request = MintIssuerTokenRequest(
        amount=1_000,
    )
    payment = await token_issuer.mint_issuer_token(request)
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.MintIssuerTokenRequest{
	Amount: new(big.Int).SetInt64(1_000),
}
payment, err := tokenIssuer.MintIssuerToken(request)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}
```

</section>

</custom-tabs>


<h3 id="burning-a-token">
    <a class="header" href="#burning-a-token">Burning a token</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.TokenIssuer.html#method.burn_issuer_token">API docs</a>
</h3>

Permanently remove tokens from the circulating supply by burning them.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let request = BurnIssuerTokenRequest { amount: 1_000 };

let payment = token_issuer.burn_issuer_token(request).await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let request = BurnIssuerTokenRequest(
    amount: BInt(1_000)
)
let payment = try await tokenIssuer.burnIssuerToken(request: request)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val request =
            BurnIssuerTokenRequest(
                    amount = BigInteger.fromLong(1_000L),
            )
    val payment = tokenIssuer.burnIssuerToken(request)
} catch (e: Exception) {
    // Handle exception
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var amount = new BigInteger(1000);
var request = new BurnIssuerTokenRequest(
    amount: amount
);
var payment = await tokenIssuer.BurnIssuerToken(request);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const payment = await tokenIssuer.burnIssuerToken({
  amount: BigInt(1_000)
})
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const payment = await tokenIssuer.burnIssuerToken({
  amount: BigInt(1_000)
})
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
BurnIssuerTokenRequest request = BurnIssuerTokenRequest(
  amount: BigInt.from(1000),
);
Payment payment = await tokenIssuer.burnIssuerToken(request: request);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    request = BurnIssuerTokenRequest(
        amount=1_000,
    )
    payment = await token_issuer.burn_issuer_token(request)
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
request := breez_sdk_spark.BurnIssuerTokenRequest{
	Amount: new(big.Int).SetInt64(1_000),
}
payment, err := tokenIssuer.BurnIssuerToken(request)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}
```

</section>

</custom-tabs>


## Query balance & metadata

Retrieve the current issue token balance and fetch the token metadata.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let token_balance = token_issuer.get_issuer_token_balance().await?;
info!("Token balance: {}", token_balance.balance);

let token_metadata = token_issuer.get_issuer_token_metadata().await?;
info!("Token ticker: {}", token_metadata.ticker);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let tokenBalance = try await tokenIssuer.getIssuerTokenBalance()
print("Token balance: {}", tokenBalance.balance)

let tokenMetadata = try await tokenIssuer.getIssuerTokenMetadata()
print("Token ticker: {}", tokenMetadata.ticker)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val tokenBalance = tokenIssuer.getIssuerTokenBalance()
    // Log.v("Breez", "Token balance: ${tokenBalance.balance}")

    val tokenMetadata = tokenIssuer.getIssuerTokenMetadata()
    // Log.v("Breez", "Token ticker: ${tokenMetadata.ticker}")
} catch (e: Exception) {
    // Handle exception
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var tokenBalance = await tokenIssuer.GetIssuerTokenBalance();
Console.WriteLine($"Token balance: {tokenBalance.balance}");

var tokenMetadata = await tokenIssuer.GetIssuerTokenMetadata();
Console.WriteLine($"Token ticker: {tokenMetadata.ticker}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const tokenBalance = await tokenIssuer.getIssuerTokenBalance()
console.debug(`Token balance: ${tokenBalance.balance}`)

const tokenMetadata = await tokenIssuer.getIssuerTokenMetadata()
console.debug(`Token ticker: ${tokenMetadata.ticker}`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const tokenBalance = await tokenIssuer.getIssuerTokenBalance()
console.debug(`Token balance: ${tokenBalance.balance}`)

const tokenMetadata = await tokenIssuer.getIssuerTokenMetadata()
console.debug(`Token ticker: ${tokenMetadata.ticker}`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
TokenBalance tokenBalance = await tokenIssuer.getIssuerTokenBalance();
print("Token balance: ${tokenBalance.balance}");

TokenMetadata tokenMetadata = await tokenIssuer.getIssuerTokenMetadata();
print("Token ticker: ${tokenMetadata.ticker}");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    token_balance = await token_issuer.get_issuer_token_balance()
    logging.debug(f"Token balance: {token_balance.balance}")

    token_metadata = await token_issuer.get_issuer_token_metadata()
    logging.debug(f"Token ticker: {token_metadata.ticker}")
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
tokenBalance, err := tokenIssuer.GetIssuerTokenBalance()
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}
log.Printf("Token balance: %v", tokenBalance.Balance)

tokenMetadata, err := tokenIssuer.GetIssuerTokenMetadata()
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}
log.Printf("Token ticker: %v", tokenMetadata.Ticker)
```

</section>

</custom-tabs>


## Freeze and unfreeze tokens

Freeze and unfreeze tokens at a specific Spark address if the token metadata allows it.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let spark_address = "<spark address>".to_string();
// Freeze the tokens held at the specified Spark address
let freeze_request = FreezeIssuerTokenRequest {
    address: spark_address.clone(),
};
let freeze_response = token_issuer.freeze_issuer_token(freeze_request).await?;

// Unfreeze the tokens held at the specified Spark address
let unfreeze_request = UnfreezeIssuerTokenRequest {
    address: spark_address,
};
let unfreeze_response = token_issuer.unfreeze_issuer_token(unfreeze_request).await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let sparkAddress = "<spark address>"
// Freeze the tokens held at the specified Spark address
let freezeRequest = FreezeIssuerTokenRequest(
    address: sparkAddress
)
let freezeResponse = try await tokenIssuer.freezeIssuerToken(request: freezeRequest)

// Unfreeze the tokens held at the specified Spark address
let unfreezeRequest = UnfreezeIssuerTokenRequest(
    address: sparkAddress
)
let unfreezeResponse = try await tokenIssuer.unfreezeIssuerToken(request: unfreezeRequest)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val sparkAddress = "<spark address>"
    // Freeze the tokens held at the specified Spark address
    val freezeRequest =
            FreezeIssuerTokenRequest(
                    address = sparkAddress,
            )
    val freezeResponse = tokenIssuer.freezeIssuerToken(freezeRequest)

    // Unfreeze the tokens held at the specified Spark address
    val unfreezeRequest =
            UnfreezeIssuerTokenRequest(
                    address = sparkAddress,
            )
    val unfreezeResponse = tokenIssuer.unfreezeIssuerToken(unfreezeRequest)
} catch (e: Exception) {
    // Handle exception
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var sparkAddress = "<spark address>";
var freezeRequest = new FreezeIssuerTokenRequest(
    address: sparkAddress
);
var freezeReponse = await tokenIssuer.FreezeIssuerToken(freezeRequest);

var unfreezeRequest = new UnfreezeIssuerTokenRequest(
    address: sparkAddress
);
var unfreezeResponse = await tokenIssuer.UnfreezeIssuerToken(unfreezeRequest);
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const sparkAddress = '<spark address>'
// Freeze the tokens held at the specified Spark address
const freezeResponse = await tokenIssuer.freezeIssuerToken({
  address: sparkAddress
})

// Unfreeze the tokens held at the specified Spark address
const unfreezeResponse = await tokenIssuer.unfreezeIssuerToken({
  address: sparkAddress
})
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const sparkAddress = '<spark address>'
// Freeze the tokens held at the specified Spark address
const freezeResponse = await tokenIssuer.freezeIssuerToken({
  address: sparkAddress
})

// To unfreeze the tokens, use the following:
const unfreezeResponse = await tokenIssuer.unfreezeIssuerToken({
  address: sparkAddress
})
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String sparkAddress = "<spark address>";
// Freeze the tokens held at the specified Spark address
FreezeIssuerTokenRequest freezeRequest =
    FreezeIssuerTokenRequest(address: sparkAddress);
FreezeIssuerTokenResponse freezeResponse =
    await tokenIssuer.freezeIssuerToken(request: freezeRequest);

// Unfreeze the tokens held at the specified Spark address
UnfreezeIssuerTokenRequest unfreezeRequest =
    UnfreezeIssuerTokenRequest(address: sparkAddress);
UnfreezeIssuerTokenResponse unfreezeResponse =
    await tokenIssuer.unfreezeIssuerToken(request: unfreezeRequest);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
try:
    spark_address = "<spark address>"
    # Freeze the tokens held at the specified Spark address
    freeze_request = FreezeIssuerTokenRequest(
        address=spark_address,
    )
    freeze_response = await token_issuer.freeze_issuer_token(freeze_request)
    # Unfreeze the tokens held at the specified Spark address
    unfreeze_request = UnfreezeIssuerTokenRequest(
        address=spark_address,
    )
    unfreeze_response = await token_issuer.unfreeze_issuer_token(unfreeze_request)
except Exception as error:
    logging.error(error)
    raise
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
sparkAddress := "<spark address>"
// Freeze the tokens held at the specified Spark address
freezeRequest := breez_sdk_spark.FreezeIssuerTokenRequest{
	Address: sparkAddress,
}
freezeResponse, err := tokenIssuer.FreezeIssuerToken(freezeRequest)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}

// Unfreeze the tokens held at the specified Spark address
unfreezeRequest := breez_sdk_spark.UnfreezeIssuerTokenRequest{
	Address: sparkAddress,
}
unfreezeResponse, err := tokenIssuer.UnfreezeIssuerToken(unfreezeRequest)
if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return err
}
```

</section>

</custom-tabs>


# Advanced features

The SDK supports advanced features that may be useful in specific use cases:

- **[Using an External Signer](external_signer.md)** provides custom signing logic and enables integrating with hardware wallets, MPC protocols, or existing wallet infrastructure
- **[Spark HTLC payments](htlcs.md)** enable conditional payments and are useful for implementing atomic cross-chain swaps
- **[Custom leaf optimization](optimize.md)** allows defining the leaf optimization policy and controlling when it occurs in order to minimize payment latency

<h1 id="custom-configuration">
    <a class="header" href="#custom-configuration">Custom configuration</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.Config.html">API docs</a>
</h1>

The SDK supports various configuration options to customize its behavior. During [initialization](./initializing.md#basic-initialization), you must provide a configuration object, which we recommend creating by modifying the default configuration. This page describes the available configuration options.

## Max deposit claim fee

Receiving Bitcoin payments through on-chain deposits may involve fees. This configuration option controls the automatic claiming of incoming funds, allowing it when the required fees are below specified thresholds. The available options are:

- Absolute fee amount in sats
- Feerate in sats/vbyte
- Fastest network recommended fee at the time of claim, with a leeway in sats/vbyte

You can also disable automatic claiming entirely. Deposits that are not automatically claimed require manual intervention.

By default, automatic claiming is enabled with a maximum feerate of 1 sats/vbyte.

More information can be found in the [Handling unclaimed deposits](./unclaimed_deposits.md) page.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Create the default config
let mut config = default_config(Network::Mainnet);
config.api_key = Some("<breez api key>".to_string());

// Disable automatic claiming
config.max_deposit_claim_fee = None;

// Set a maximum feerate of 10 sat/vB
config.max_deposit_claim_fee = Some(MaxFee::Rate { sat_per_vbyte: 10 });

// Set a maximum fee of 1000 sat
config.max_deposit_claim_fee = Some(MaxFee::Fixed { amount: 1000 });

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.max_deposit_claim_fee = Some(MaxFee::NetworkRecommended {
    leeway_sat_per_vbyte: 1,
});
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Create the default config
var config = defaultConfig(network: Network.mainnet)
config.apiKey = "<breez api key>"

// Disable automatic claiming
config.maxDepositClaimFee = nil

// Set a maximum feerate of 10 sat/vB
config.maxDepositClaimFee = MaxFee.rate(satPerVbyte: 10)

// Set a maximum fee of 1000 sat
config.maxDepositClaimFee = MaxFee.fixed(amount: 1000)

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = MaxFee.networkRecommended(leewaySatPerVbyte: 1)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Create the default config
val config = defaultConfig(Network.MAINNET)
config.apiKey = "<breez api key>"

// Disable automatic claiming
config.maxDepositClaimFee = null

// Set a maximum feerate of 10 sat/vB
config.maxDepositClaimFee = MaxFee.Rate(10u)

// Set a maximum fee of 1000 sat
config.maxDepositClaimFee = MaxFee.Fixed(1000u)

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = MaxFee.NetworkRecommended(1u)
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Create the default config with API key
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    apiKey = "<breez api key>"
};

// Disable automatic claiming
config = config with { maxDepositClaimFee = null };

// Set a maximum feerate of 10 sat/vB
config = config with { maxDepositClaimFee = new MaxFee.Rate(satPerVbyte: 10) };

// Set a maximum fee of 1000 sat
config = config with { maxDepositClaimFee = new MaxFee.Fixed(amount: 1000) };

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config = config with { maxDepositClaimFee = new MaxFee.NetworkRecommended(leewaySatPerVbyte: 1) };
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Create the default config
const config = defaultConfig('mainnet')
config.apiKey = '<breez api key>'

// Disable automatic claiming
config.maxDepositClaimFee = undefined

// Set a maximum feerate of 10 sat/vB
config.maxDepositClaimFee = { type: 'rate', satPerVbyte: 10 }

// Set a maximum fee of 1000 sat
config.maxDepositClaimFee = { type: 'fixed', amount: 1000 }

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = { type: 'networkRecommended', leewaySatPerVbyte: 1 }
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Create the default config
const config = defaultConfig(Network.Mainnet)
config.apiKey = '<breez api key>'

// Disable automatic claiming
config.maxDepositClaimFee = undefined

// Set a maximum feerate of 10 sat/vB
config.maxDepositClaimFee = new MaxFee.Rate({ satPerVbyte: BigInt(10) })

// Set a maximum fee of 1000 sat
config.maxDepositClaimFee = new MaxFee.Fixed({ amount: BigInt(1000) })

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config.maxDepositClaimFee = new MaxFee.NetworkRecommended({ leewaySatPerVbyte: BigInt(1) })
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Create the default config
var config = defaultConfig(network: Network.mainnet)
    .copyWith(apiKey: "<breez api key>");

// Disable automatic claiming
config = config.copyWith(maxDepositClaimFee: null);

// Set a maximum feerate of 10 sat/vB
config = config.copyWith(
    maxDepositClaimFee: MaxFee.rate(satPerVbyte: BigInt.from(10)));

// Set a maximum fee of 1000 sat
config = config.copyWith(
    maxDepositClaimFee: MaxFee.fixed(amount: BigInt.from(1000)));

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
config = config.copyWith(
    maxDepositClaimFee:
        MaxFee.networkRecommended(leewaySatPerVbyte: BigInt.from(1)));
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Create the default config
config = default_config(network=Network.MAINNET)
config.api_key = "<breez api key>"

# Disable automatic claiming
config.max_deposit_claim_fee = None

# Set a maximum feerate of 10 sat/vB
config.max_deposit_claim_fee = MaxFee.RATE(sat_per_vbyte=10)

# Set a maximum fee of 1000 sat
config.max_deposit_claim_fee = MaxFee.FIXED(amount=1000)

# Set the maximum fee to the fastest network recommended fee at the time of claim
# with a leeway of 1 sats/vbyte
config.max_deposit_claim_fee = MaxFee.NETWORK_RECOMMENDED(leeway_sat_per_vbyte=1)
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Create the default config
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
apiKey := "<breez api key>"
config.ApiKey = &apiKey

// Disable automatic claiming
config.MaxDepositClaimFee = nil

// Set a maximum feerate of 10 sat/vB
feeRateInterface := breez_sdk_spark.MaxFee(breez_sdk_spark.MaxFeeRate{SatPerVbyte: 10})
config.MaxDepositClaimFee = &feeRateInterface

// Set a maximum fee of 1000 sat
feeFixedInterface := breez_sdk_spark.MaxFee(breez_sdk_spark.MaxFeeFixed{Amount: 1000})
config.MaxDepositClaimFee = &feeFixedInterface

// Set the maximum fee to the fastest network recommended fee at the time of claim
// with a leeway of 1 sats/vbyte
networkRecommendedInterface := breez_sdk_spark.MaxFee(breez_sdk_spark.MaxFeeNetworkRecommended{LeewaySatPerVbyte: 1})
config.MaxDepositClaimFee = &networkRecommendedInterface
```

</section>

</custom-tabs>


## Synchronization interval

The SDK performs regular background synchronization to check for payment status updates. You can configure how often this synchronization occurs.

The synchronization process is used to detect some payment status updates that are not detected in real-time through event streams.

A shorter synchronization interval provides more responsive detection of payment updates but increases resource usage and may trigger API rate limits. The default interval balances responsiveness with resource efficiency for most use cases.

## LNURL Domain

The LNURL domain to be used for receiving LNURL and Lightning address payments. By default, the [Breez LNURL server](https://github.com/breez/spark-sdk/tree/main/crates/breez-sdk/lnurl) instance will be used. You may configure a different domain, or set no domain to disable receiving payments using LNURL. For more information, see [Receiving payments using LNURL-Pay](./receive_lnurl_pay.md).

## Prefer Spark over Lightning

An on-off switch that determines whether to prefer settlement using Spark when sending and receiving payments via Lightning invoices. 

## External input parsing

The SDK's parsing module can be extended by providing external parsers that are used when input is not recognized. Some [default external parsers](./parse.md#default-external-parsers) are provided but can be disabled. You can add new external parsers as described in [Configuring external parsers](./parse.md#configuring-external-parsers).

## Real-time sync server URL

The SDK synchronizes user data across different SDK instances using a [real-time synchronization server](https://github.com/breez/data-sync). By default, a Breez instance will be used, but you may configure a different instance by providing its URL, or disable it entirely by providing no URL.

## Private mode enabled by default

Configures whether the Spark private mode should be enabled by default. By default, it is enabled. When enabled, the Spark private mode will be enabled on the first initialization of the SDK. If disabled, no changes will be made to the Spark private mode.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
// Disable Spark private mode by default
let mut config = default_config(Network::Mainnet);
config.private_enabled_default = false;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
// Disable Spark private mode by default
var config = defaultConfig(network: Network.mainnet)
config.privateEnabledDefault = false
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
// Disable Spark private mode by default
val config = defaultConfig(Network.MAINNET)
config.privateEnabledDefault = false
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
// Disable Spark private mode by default
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    privateEnabledDefault = false
};
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
// Disable Spark private mode by default
const config = defaultConfig('mainnet')
config.privateEnabledDefault = false
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
// Disable Spark private mode by default
const config = defaultConfig(Network.Mainnet)
config.privateEnabledDefault = false
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
// Disable Spark private mode by default
var config = defaultConfig(network: Network.mainnet)
    .copyWith(privateEnabledDefault: false);
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
# Disable Spark private mode by default
config = default_config(network=Network.MAINNET)
config.private_enabled_default = False
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
// Disable Spark private mode by default
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
config.PrivateEnabledDefault = false
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>

This configuration option is only relevant when the SDK is initialized for the first time. To update the user settings after that, or to explicitly disable the Spark private mode, see the [User settings](./user_settings.md) page.

</div>

## Optimization configuration

The SDK can automatically optimize the Spark leaf set to maximize unilateral exit efficiency or increase payment speed. Fewer, larger leaves allow more funds to be exited unilaterally, while having more leaves enables payments without requiring swaps, improving payment speed.

This configuration controls optimization through the following options:

- **Automatic optimization enabled**: whether optimization runs automatically when a payment is sent or received. Enabled by default.
- **Multiplicity**: the desired multiplicity for the leaf set. Values range from 0 to 5. Default value is 1. Setting it to 0 fully optimizes for unilateral exit efficiency. Setting it to a value greater than 0 also optimizes for payment speed, with higher values prioritizing payment speed more aggressively at the cost of higher unilateral exit fees.

See [Custom leaf optimization](./optimize.md) for more information and recommendations on how to configure optimization.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let mut config = default_config(Network::Mainnet);
config.optimization_config = OptimizationConfig {
    auto_enabled: true,
    multiplicity: 1,
};
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
var config = defaultConfig(network: Network.mainnet)
config.optimizationConfig = OptimizationConfig(autoEnabled: true, multiplicity: 1)
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val config = defaultConfig(Network.MAINNET)
config.optimizationConfig = OptimizationConfig(autoEnabled = true, multiplicity = 1u)
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
{
    optimizationConfig = new OptimizationConfig(autoEnabled: true, multiplicity: 1)
};
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const config = defaultConfig('mainnet')
config.optimizationConfig = { autoEnabled: true, multiplicity: 1 }
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const config = defaultConfig(Network.Mainnet)
config.optimizationConfig = { autoEnabled: true, multiplicity: 1 }
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
var config = defaultConfig(network: Network.mainnet).copyWith(
    optimizationConfig:
        OptimizationConfig(autoEnabled: true, multiplicity: 1));
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
config = default_config(network=Network.MAINNET)
config.optimization_config = OptimizationConfig(auto_enabled=True, multiplicity=1)
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
config.OptimizationConfig = breez_sdk_spark.OptimizationConfig{AutoEnabled: true, Multiplicity: 1}
```

</section>

</custom-tabs>


# Spark HTLC payments

Hash Time-Locked Contract (HTLC) payments are conditional payments that enable atomic cross-chain swaps. The SDK supports Spark HTLCs through a simple API.

In an HTLC payment, the sender locks funds using a cryptographic hash of a secret preimage and sets an expiration time. The receiver can claim the payment by revealing the preimage before expiration. If the receiver fails to claim the payment in time, the funds are automatically returned to the sender.

## Sending HTLC Payments

HTLC payments use the standard payment API described in [Sending payments](send_payment.md). To create an HTLC payment, prepare the payment normally, then provide the Spark HTLC options when [sending](send_payment.md#spark). These options include the payment hash (SHA-256 hash of the preimage) and the expiry duration.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let payment_request = "<spark address>".to_string();
// Set the amount you wish the pay the receiver
let amount_sats = Some(50_000);
let prepare_request = PrepareSendPaymentRequest {
    payment_request,
    amount: amount_sats,
    token_identifier: None,
    conversion_options: None,
};
let prepare_response = sdk.prepare_send_payment(prepare_request).await?;

// If the fees are acceptable, continue to create the HTLC Payment
if let SendPaymentMethod::SparkAddress { fee, .. } = prepare_response.payment_method {
    info!("Fees: {} sats", fee);
}

let preimage = "<32-byte unique preimage hex>";
let preimage_bytes = hex::decode(preimage)?;
let payment_hash_bytes = sha256::digest(preimage_bytes);
let payment_hash = hex::encode(payment_hash_bytes);

// Set the HTLC options
let options = SendPaymentOptions::SparkAddress {
    htlc_options: Some(SparkHtlcOptions {
        payment_hash,
        expiry_duration_secs: 1000,
    }),
};

let request = SendPaymentRequest {
    prepare_response,
    options: Some(options),
    idempotency_key: None,
};
let send_response = sdk.send_payment(request).await?;
let payment = send_response.payment;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let paymentRequest = "<spark address>"
// Set the amount you wish the pay the receiver (requires 'import BigNumber')
let amountSats = BInt(50_000)
let prepareRequest = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    amount: amountSats
)
let prepareResponse = try await sdk.prepareSendPayment(request: prepareRequest)

// If the fees are acceptable, continue to create the HTLC Payment
if case let .sparkAddress(_, fee, _) = prepareResponse.paymentMethod {
    print("Fees: \(fee) sats")
}

let preimage = "<32-byte unique preimage hex>"
let preimageData = Data(hexString: preimage)!
let paymentHashDigest = SHA256.hash(data: preimageData)
let paymentHash = Data(paymentHashDigest).hexEncodedString()

// Set the HTLC options
let htlcOptions = SparkHtlcOptions(
    paymentHash: paymentHash,
    expiryDurationSecs: 1000
)
let options = SendPaymentOptions.sparkAddress(htlcOptions: htlcOptions)

let request = SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options
)
let sendResponse = try await sdk.sendPayment(request: request)
let payment = sendResponse.payment
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val paymentRequest = "<spark address>"
// Set the amount you wish the pay the receiver
// Kotlin MPP (BigInteger from com.ionspin.kotlin.bignum.integer, which is included in package)
val amountSats = BigInteger.fromLong(50_000L)
// Android (BigInteger from java.math)
// val amountSats = BigInteger.valueOf(50_000L)
try {
    val prepareRequest = PrepareSendPaymentRequest(paymentRequest, amountSats)
    val prepareResponse = sdk.prepareSendPayment(prepareRequest)

    // If the fees are acceptable, continue to create the HTLC Payment
    val paymentMethod = prepareResponse.paymentMethod
    if (paymentMethod is SendPaymentMethod.SparkAddress) {
        val fee = paymentMethod.fee
        // Log.v("Breez", "Fees: ${fee} sats")
    }

    val preimage = "<32-byte unique preimage hex>"
    val preimageBytes = preimage.hexToByteArray()
    val digest = SHA256()
    digest.update(preimageBytes)
    val paymentHashBytes = digest.digest()
    val paymentHash = paymentHashBytes.toHexString()

    // Set the HTLC options
    val htlcOptions = SparkHtlcOptions(
        paymentHash = paymentHash,
        expiryDurationSecs = 1000u
    )
    val options = SendPaymentOptions.SparkAddress(htlcOptions = htlcOptions)

    val request = SendPaymentRequest(
        prepareResponse = prepareResponse,
        options = options
    )
    val sendResponse = sdk.sendPayment(request)
    val payment = sendResponse.payment
} catch (e: Exception) {
    // handle error
    throw e
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var paymentRequest = "<spark address>";
// Set the amount you wish the pay the receiver
var amountSats = new BigInteger(50000);
var prepareRequest = new PrepareSendPaymentRequest(
    paymentRequest: paymentRequest,
    amount: amountSats
);
var prepareResponse = await sdk.PrepareSendPayment(request: prepareRequest);

// If the fees are acceptable, continue to create the HTLC Payment
if (prepareResponse.paymentMethod is SendPaymentMethod.SparkAddress sparkMethod)
{
    var fee = sparkMethod.fee;
    Console.WriteLine($"Fees: {fee} sats");
}

var preimage = "<32-byte unique preimage hex>";
var preimageBytes = Convert.FromHexString(preimage);
var paymentHashBytes = System.Security.Cryptography.SHA256.HashData(preimageBytes);
var paymentHash = Convert.ToHexString(paymentHashBytes).ToLower();

// Set the HTLC options
var options = new SendPaymentOptions.SparkAddress(
    htlcOptions: new SparkHtlcOptions(
        paymentHash: paymentHash,
        expiryDurationSecs: 1000
    )
);

var request = new SendPaymentRequest(
    prepareResponse: prepareResponse,
    options: options
);
var sendResponse = await sdk.SendPayment(request: request);
var payment = sendResponse.payment;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const paymentRequest = '<spark address>'
// Set the amount you wish the pay the receiver
const amountSats = BigInt(50000)
const prepareRequest = {
  paymentRequest,
  amount: amountSats
}
const prepareResponse = await sdk.prepareSendPayment(prepareRequest)

// If the fees are acceptable, continue to create the HTLC Payment
if (prepareResponse.paymentMethod.type === 'sparkAddress') {
  const fee = prepareResponse.paymentMethod.fee
  console.debug(`Fees: ${fee} sats`)
}

const preimage = '<32-byte unique preimage hex>'
const preimageBuffer = Buffer.from(preimage, 'hex')
const paymentHash = createHash('sha256').update(preimageBuffer).digest('hex')

const sendResponse = await sdk.sendPayment({
  prepareResponse,
  options: {
    type: 'sparkAddress',
    htlcOptions: {
      paymentHash,
      expiryDurationSecs: 1000
    }
  }
})
const payment = sendResponse.payment
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const paymentRequest = '<spark address>'
// Set the amount you wish the pay the receiver
const amountSats = BigInt(50000)
const prepareRequest = {
  paymentRequest,
  amount: amountSats,
  tokenIdentifier: undefined,
  conversionOptions: undefined
}
const prepareResponse = await sdk.prepareSendPayment(prepareRequest)

// If the fees are acceptable, continue to create the HTLC Payment
if (prepareResponse.paymentMethod?.tag === SendPaymentMethod_Tags.SparkAddress) {
  const fee = prepareResponse.paymentMethod.inner.fee
  console.debug(`Fees: ${fee} sats`)
}

const preimage = '<32-byte unique preimage hex>'
const preimageBuffer = Buffer.from(preimage, 'hex')
const paymentHash = createHash('sha256').update(preimageBuffer).digest('hex')

// Set the HTLC options
const options = new SendPaymentOptions.SparkAddress({
  htlcOptions: {
    paymentHash,
    expiryDurationSecs: BigInt(1000)
  }
})

const request = {
  prepareResponse,
  options,
  idempotencyKey: undefined
}
const sendResponse = await sdk.sendPayment(request)
const payment = sendResponse.payment
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String paymentRequest = "<spark address>";
// Set the amount you wish the pay the receiver
BigInt amountSats = BigInt.from(50000);
final prepareRequest = PrepareSendPaymentRequest(
    paymentRequest: paymentRequest, amount: amountSats);
final prepareResponse = await sdk.prepareSendPayment(request: prepareRequest);

// If the fees are acceptable, continue to create the HTLC Payment
final paymentMethod = prepareResponse.paymentMethod;
if (paymentMethod is SendPaymentMethod_SparkAddress) {
  final fee = paymentMethod.fee;
  print("Fees: $fee sats");
}

String preimage = "<32-byte unique preimage hex>";
List<int> preimageBytes = hex.decode(preimage);
Digest paymentHashDigest = sha256.convert(preimageBytes);
String paymentHash = hex.encode(paymentHashDigest.bytes);

// Set the HTLC options
final htlcOptions = SparkHtlcOptions(
    paymentHash: paymentHash, expiryDurationSecs: BigInt.from(1000));
final options = SendPaymentOptions.sparkAddress(htlcOptions: htlcOptions);

final request =
    SendPaymentRequest(prepareResponse: prepareResponse, options: options);
final sendResponse = await sdk.sendPayment(request: request);
final payment = sendResponse.payment;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
payment_request = "<spark address>"
# Set the amount you wish the pay the receiver
amount_sats = 50_000
prepare_request = PrepareSendPaymentRequest(
    payment_request=payment_request, amount=amount_sats
)
prepare_response = await sdk.prepare_send_payment(request=prepare_request)

# If the fees are acceptable, continue to create the HTLC Payment
if hasattr(prepare_response.payment_method, "fee"):
    fee = prepare_response.payment_method.fee
    logging.debug(f"Fees: {fee} sats")

preimage = "<32-byte unique preimage hex>"
preimage_bytes = bytes.fromhex(preimage)
payment_hash_bytes = hashlib.sha256(preimage_bytes).digest()
payment_hash = payment_hash_bytes.hex()

# Set the HTLC options
options = SendPaymentOptions.SPARK_ADDRESS(
    htlc_options=SparkHtlcOptions(
        payment_hash=payment_hash, expiry_duration_secs=1000
    )
)

request = SendPaymentRequest(
    prepare_response=prepare_response, options=options
)
send_response = await sdk.send_payment(request=request)
payment = send_response.payment
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
paymentRequest := "<spark address>"
// Set the amount you wish the pay the receiver
amountSats := new(big.Int).SetInt64(50_000)
prepareRequest := breez_sdk_spark.PrepareSendPaymentRequest{
	PaymentRequest: paymentRequest,
	Amount:         &amountSats,
}
prepareResponse, err := sdk.PrepareSendPayment(prepareRequest)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

// If the fees are acceptable, continue to create the HTLC Payment
switch paymentMethod := prepareResponse.PaymentMethod.(type) {
case breez_sdk_spark.SendPaymentMethodSparkAddress:
	fee := paymentMethod.Fee
	log.Printf("Fees: %v sats", fee)
}

preimage := "<32-byte unique preimage hex>"
preimageBytes, err := hex.DecodeString(preimage)
if err != nil {
	return nil, err
}
paymentHashBytes := sha256.Sum256(preimageBytes)
paymentHash := hex.EncodeToString(paymentHashBytes[:])

// Set the HTLC options
htlcOptions := breez_sdk_spark.SparkHtlcOptions{
	PaymentHash:        paymentHash,
	ExpiryDurationSecs: 1000,
}
var options breez_sdk_spark.SendPaymentOptions = breez_sdk_spark.SendPaymentOptionsSparkAddress{
	HtlcOptions: &htlcOptions,
}

request := breez_sdk_spark.SendPaymentRequest{
	PrepareResponse: prepareResponse,
	Options:         &options,
}
sendResponse, err := sdk.SendPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payment := sendResponse.Payment
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>
Preimages are required to be unique and are not managed by the SDK. It is your responsibility as a developer to manage them, including how to generate them, store them, and eventually share them with the receiver.
</div>

<h2 id="listing-claimable-htlc-payments">
    <a class="header" href="#listing-claimable-htlc-payments">Listing claimable HTLC payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.list_payments">API docs</a>
</h2>

Once detected, claimable HTLC payments are immediately listed as pending in the [list of payments](/guide/list_payments.md). Additionally, a `PaymentPending` event is emitted to notify your application. See [Listening to events](/guide/events.md) for more details.

To list only claimable HTLC payments, you can filter by HTLC status.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let request = ListPaymentsRequest {
    type_filter: Some(vec![PaymentType::Receive]),
    status_filter: Some(vec![PaymentStatus::Pending]),
    payment_details_filter: Some(vec![PaymentDetailsFilter::Spark {
        htlc_status: Some(vec![SparkHtlcStatus::WaitingForPreimage]),
        conversion_refund_needed: None,
    }]),
    ..Default::default()
};

let response = sdk.list_payments(request).await?;
let payments = response.payments;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let request = ListPaymentsRequest(
    typeFilter: [PaymentType.receive],
    statusFilter: [PaymentStatus.pending],
    paymentDetailsFilter: [PaymentDetailsFilter.spark(
        htlcStatus: [SparkHtlcStatus.waitingForPreimage],
        conversionRefundNeeded: nil
    )]
)

let response = try await sdk.listPayments(request: request)
let payments = response.payments
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val request = ListPaymentsRequest(
        typeFilter = listOf(PaymentType.RECEIVE),
        statusFilter = listOf(PaymentStatus.PENDING),
        paymentDetailsFilter = listOf(
            PaymentDetailsFilter.Spark(
                htlcStatus = listOf(SparkHtlcStatus.WAITING_FOR_PREIMAGE),
                conversionRefundNeeded = null
            )
        )
    )

    val response = sdk.listPayments(request)
    val payments = response.payments
} catch (e: Exception) {
    // handle error
    throw e
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var request = new ListPaymentsRequest(
    typeFilter: new List<PaymentType> { PaymentType.Receive },
    statusFilter: new List<PaymentStatus> { PaymentStatus.Pending },
    paymentDetailsFilter: new List<PaymentDetailsFilter> {
        new PaymentDetailsFilter.Spark(
            htlcStatus: new List<SparkHtlcStatus> {
                SparkHtlcStatus.WaitingForPreimage
            },
            conversionRefundNeeded: null
        )
    }
);

var response = await sdk.ListPayments(request: request);
var payments = response.payments;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const response = await sdk.listPayments({
  typeFilter: ['receive'],
  statusFilter: ['pending'],
  paymentDetailsFilter: [{
    type: 'spark',
    htlcStatus: ['waitingForPreimage']
  }],
  assetFilter: undefined
})
const payments = response.payments
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const request = {
  typeFilter: [PaymentType.Receive],
  statusFilter: [PaymentStatus.Pending],
  paymentDetailsFilter: [new PaymentDetailsFilter.Spark({
    htlcStatus: [SparkHtlcStatus.WaitingForPreimage],
    conversionRefundNeeded: undefined
  })],
  assetFilter: undefined,
  fromTimestamp: undefined,
  toTimestamp: undefined,
  offset: undefined,
  limit: undefined,
  sortAscending: undefined
}

const response = await sdk.listPayments(request)
const payments = response.payments
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
final request = ListPaymentsRequest(
  typeFilter: [PaymentType.receive],
  statusFilter: [PaymentStatus.pending],
  paymentDetailsFilter: [PaymentDetailsFilter.spark(
    htlcStatus: [SparkHtlcStatus.waitingForPreimage],
  )],
);

final response = await sdk.listPayments(request: request);
final payments = response.payments;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
request = ListPaymentsRequest(
    type_filter=[PaymentType.RECEIVE],
    status_filter=[PaymentStatus.PENDING],
    payment_details_filter=[cast(PaymentDetailsFilter, PaymentDetailsFilter.SPARK(
        htlc_status=[SparkHtlcStatus.WAITING_FOR_PREIMAGE],
        conversion_refund_needed=None
    ))],
)

response = await sdk.list_payments(request=request)
payments = response.payments
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
typeFilter := []breez_sdk_spark.PaymentType{
	breez_sdk_spark.PaymentTypeReceive,
}
statusFilter := []breez_sdk_spark.PaymentStatus{
	breez_sdk_spark.PaymentStatusPending,
}
paymentDetailsFilter := []breez_sdk_spark.PaymentDetailsFilter{
	breez_sdk_spark.PaymentDetailsFilterSpark{
		HtlcStatus: &[]breez_sdk_spark.SparkHtlcStatus{
			breez_sdk_spark.SparkHtlcStatusWaitingForPreimage,
		},
	},
}

request := breez_sdk_spark.ListPaymentsRequest{
	TypeFilter:            &typeFilter,
	StatusFilter:          &statusFilter,
	PaymentDetailsFilter:  &paymentDetailsFilter,
}

response, err := sdk.ListPayments(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payments := response.Payments
```

</section>

</custom-tabs>


<h2 id="claiming-htlc-payments">
    <a class="header" href="#claiming-htlc-payments">Claiming HTLC Payments</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.claim_htlc_payment">API docs</a>
</h2>

To claim an HTLC payment, provide the preimage that matches the payment hash.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let preimage = "<preimage hex>".to_string();
let response = sdk
    .claim_htlc_payment(ClaimHtlcPaymentRequest { preimage })
    .await?;
let payment = response.payment;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let preimage = "<preimage hex>"
let response = try await sdk.claimHtlcPayment(
    request: ClaimHtlcPaymentRequest(preimage: preimage)
)
let payment = response.payment
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    val preimage = "<preimage hex>"
    val request = ClaimHtlcPaymentRequest(preimage = preimage)
    val response = sdk.claimHtlcPayment(request)
    val payment = response.payment
} catch (e: Exception) {
    // handle error
    throw e
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var preimage = "<preimage hex>";
var response = await sdk.ClaimHtlcPayment(
    request: new ClaimHtlcPaymentRequest(preimage: preimage)
);
var payment = response.payment;
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const preimage = '<preimage hex>'
const response = await sdk.claimHtlcPayment({
  preimage
})
const payment = response.payment
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const preimage = '<preimage hex>'
const response = await sdk.claimHtlcPayment(
  { preimage }
)
const payment = response.payment
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
String preimage = "<preimage hex>";
final response = await sdk.claimHtlcPayment(
    request: ClaimHtlcPaymentRequest(preimage: preimage));
final payment = response.payment;
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
preimage = "<preimage hex>"
response = await sdk.claim_htlc_payment(
    request=ClaimHtlcPaymentRequest(preimage=preimage)
)
payment = response.payment
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
preimage := "<preimage hex>"
request := breez_sdk_spark.ClaimHtlcPaymentRequest{
	Preimage: preimage,
}
response, err := sdk.ClaimHtlcPayment(request)

if sdkErr := err.(*breez_sdk_spark.SdkError); sdkErr != nil {
	return nil, err
}

payment := response.Payment
```

</section>

</custom-tabs>


# Custom leaf optimization

The SDK implements a configurable Spark leaf optimization process. It supports two optimization policies:

- **Maximize unilateral exit efficiency**: aims to minimize the number of leaves, reducing costs for unilaterally exiting Bitcoin funds.
- **Increase payment speed**: maintains multiple copies of each leaf denomination to reduce the need for swaps during Bitcoin payments.

## Configuring the optimization policy

The optimization behavior is controlled by the **multiplicity** setting, an integer value in the range 0-5. Setting it to 0 fully optimizes for unilateral exit efficiency, while values greater than 0 also optimize for payment speed. Higher values prioritize payment speed more aggressively, resulting in higher unilateral exit costs but faster payments, especially for bursts of transactions.

See [Configuration](./config.md#optimization-configuration) to learn how to set the multiplicity.

### Impact on payment speed

Multiplicity defines how many copies of each leaf denomination the SDK maintains. A higher multiplicity provides more flexibility in leaf combinations, reducing the frequency of swaps during payments. However, the exact number of swap-free payments depends on transaction amounts and patterns.

With automatic optimization, which is enabled by default, a multiplicity of 1 (the default) works well for most single-user applications with low payment frequency, eliminating the need for swaps in the vast majority of payment scenarios. Higher multiplicities are better suited for high-volume payment processing.

### Impact on unilateral exit costs

Maintaining more leaves increases the total cost of unilaterally exiting funds, as each leaf incurs its own exit fee regardless of the leaf's value. This makes small denomination leaves cost-ineffective to exit.

<div class="warning">
<h4>Developer note</h4>

Keep multiplicity as low as possible while meeting your performance requirements. A high multiplicity can make unilateral exits prohibitively expensive.

</div>

## Controlling optimization timing

The optimization process runs as a background task that reorganizes leaves by swapping them to achieve optimal denominations. During this process, funds in leaves being swapped become temporarily unavailable for payments, which can delay transaction processing.

By default, the SDK automatically triggers optimization after each payment (sent or received). For applications requiring more control, you can disable automatic optimization in the [configuration](./config.md#optimization-configuration) and manage it manually as described below.

<h3 id="start-optimization">
    <a class="header" href="#start-optimization">Start optimization</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.start_leaf_optimization">API docs</a>
</h3>

You can manually trigger the optimization task to start running in the background. If optimization is already running, no new task will be started.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
sdk.start_leaf_optimization();
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
sdk.startLeafOptimization()
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
sdk.startLeafOptimization()
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
sdk.StartLeafOptimization();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
sdk.startLeafOptimization()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
sdk.startLeafOptimization()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
sdk.startLeafOptimization();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
sdk.start_leaf_optimization()
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
sdk.StartLeafOptimization()
```

</section>

</custom-tabs>


<h3 id="cancel-optimization">
    <a class="header" href="#cancel-optimization">Cancel optimization</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.cancel_leaf_optimization">API docs</a>
</h3>

You can cancel an ongoing optimization task and wait for it to stop completely. Optimization is done in rounds, and the current round will complete before stopping.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
sdk.cancel_leaf_optimization().await?;
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
do {
    try await sdk.cancelLeafOptimization()
} catch {
    print("Failed to cancel optimization: \(error)")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
try {
    sdk.cancelLeafOptimization()
} catch (e: Exception) {
    // handle error
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
await sdk.CancelLeafOptimization();
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
await sdk.cancelLeafOptimization()
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
await sdk.cancelLeafOptimization()
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
await sdk.cancelLeafOptimization();
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
await sdk.cancel_leaf_optimization()
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
err := sdk.CancelLeafOptimization()
if err != nil {
	return err
}
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>

The SDK automatically cancels optimization when it would block an immediate payment. Use manual cancellation only when anticipating upcoming payment activity, not when there is an immediate need to make a payment.

</div>

<h3 id="get-optimization-progress">
    <a class="header" href="#get-optimization-progress">Get optimization progress</a>
    <a class="tag" target="_blank" href="https://breez.github.io/spark-sdk/breez_sdk_spark/struct.BreezSdk.html#method.get_leaf_optimization_progress">API docs</a>
</h3>

You can retrieve the current optimization progress to monitor the optimization task.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
let progress = sdk.get_leaf_optimization_progress();

info!("Optimization is running: {}", progress.is_running);
info!("Current round: {}", progress.current_round);
info!("Total rounds: {}", progress.total_rounds);
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
let progress = sdk.getLeafOptimizationProgress()

print("Optimization is running: \(progress.isRunning)")
print("Current round: \(progress.currentRound)")
print("Total rounds: \(progress.totalRounds)")
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
val progress = sdk.getLeafOptimizationProgress()

println("Optimization is running: ${progress.isRunning}")
println("Current round: ${progress.currentRound}")
println("Total rounds: ${progress.totalRounds}")
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
var progress = sdk.GetLeafOptimizationProgress();

Console.WriteLine($"Optimization is running: {progress.isRunning}");
Console.WriteLine($"Current round: {progress.currentRound}");
Console.WriteLine($"Total rounds: {progress.totalRounds}");
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const progress = sdk.getLeafOptimizationProgress()

console.log(`Optimization is running: ${progress.isRunning}`)
console.log(`Current round: ${progress.currentRound}`)
console.log(`Total rounds: ${progress.totalRounds}`)
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const progress = sdk.getLeafOptimizationProgress()

console.log(`Optimization is running: ${progress.isRunning}`)
console.log(`Current round: ${progress.currentRound}`)
console.log(`Total rounds: ${progress.totalRounds}`)
```

</section>

<div slot="title">Flutter</div>
<section>

```dart,ignore
var progress = sdk.getLeafOptimizationProgress();

print("Optimization is running: ${progress.isRunning}");
print("Current round: ${progress.currentRound}");
print("Total rounds: ${progress.totalRounds}");
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
progress = sdk.get_leaf_optimization_progress()

logging.debug(f"Optimization is running: {progress.is_running}")
logging.debug(f"Current round: {progress.current_round}")
logging.debug(f"Total rounds: {progress.total_rounds}")
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
progress := sdk.GetLeafOptimizationProgress()

log.Printf("Optimization is running: %v\n", progress.IsRunning)
log.Printf("Current round: %v\n", progress.CurrentRound)
log.Printf("Total rounds: %v\n", progress.TotalRounds)
```

</section>

</custom-tabs>


## Optimization events

The SDK emits events to keep your application informed about optimization status. See [Listening to events](./events.md) for subscription instructions.

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
match event {
    OptimizationEvent::Started { total_rounds } => {
        info!("Optimization started with {} rounds", total_rounds);
    }
    OptimizationEvent::RoundCompleted { current_round, total_rounds } => {
        info!("Optimization round {} of {} completed", current_round, total_rounds);
    }
    OptimizationEvent::Completed => {
        info!("Optimization completed successfully");
    }
    OptimizationEvent::Cancelled => {
        info!("Optimization was cancelled");
    }
    OptimizationEvent::Failed { error } => {
        info!("Optimization failed: {}", error);
    }
    OptimizationEvent::Skipped => {
        info!("Optimization was skipped because leaves are already optimal");
    }
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
switch event {
    case .started(let totalRounds):
        print("Optimization started with \(totalRounds) rounds")
    case .roundCompleted(let currentRound, let totalRounds):
        print("Optimization round \(currentRound) of \(totalRounds) completed")
    case .completed:
        print("Optimization completed successfully")
    case .cancelled:
        print("Optimization was cancelled")
    case .failed(let error):
        print("Optimization failed: \(error)")
    case .skipped:
        print("Optimization was skipped because leaves are already optimal")
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
when (optimizationEvent) {
    is OptimizationEvent.Started -> {
        // Log.v("Breez", "Optimization started with ${optimizationEvent.totalRounds} rounds")
    }
    is OptimizationEvent.RoundCompleted -> {
        // Log.v("Breez", "Optimization round ${optimizationEvent.currentRound} of ${optimizationEvent.totalRounds} completed")
    }
    is OptimizationEvent.Completed -> {
        // Log.v("Breez", "Optimization completed successfully")
    }
    is OptimizationEvent.Cancelled -> {
        // Log.v("Breez", "Optimization was cancelled")
    }
    is OptimizationEvent.Failed -> {
        // Log.v("Breez", "Optimization failed: ${optimizationEvent.error}")
    }
    is OptimizationEvent.Skipped -> {
        // Log.v("Breez", "Optimization was skipped because leaves are already optimal")
    }
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
switch (event.type) {
  case 'started': {
    console.log(`Optimization started with ${event.totalRounds} rounds`)
    break
  }
  case 'roundCompleted': {
    console.log(`Optimization round ${event.currentRound} of ${event.totalRounds} completed`)
    break
  }
  case 'completed': {
    console.log('Optimization completed successfully')
    break
  }
  case 'cancelled': {
    console.log('Optimization was cancelled')
    break
  }
  case 'failed': {
    console.log(`Optimization failed: ${event.error}`)
    break
  }
  case 'skipped': {
    console.log('Optimization was skipped because leaves are already optimal')
    break
  }
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
if (optimizationEvent.tag === OptimizationEvent_Tags.Started) {
  console.log(`Optimization started with ${optimizationEvent.inner.totalRounds} rounds`)
} else if (optimizationEvent.tag === OptimizationEvent_Tags.RoundCompleted) {
  console.log(`Optimization round ${optimizationEvent.inner.currentRound} of ${optimizationEvent.inner.totalRounds} completed`)
} else if (optimizationEvent.tag === OptimizationEvent_Tags.Completed) {
  console.log('Optimization completed successfully')
} else if (optimizationEvent.tag === OptimizationEvent_Tags.Cancelled) {
  console.log('Optimization was cancelled')
} else if (optimizationEvent.tag === OptimizationEvent_Tags.Failed) {
  console.log(`Optimization failed: ${optimizationEvent.inner.error}`)
} else if (optimizationEvent.tag === OptimizationEvent_Tags.Skipped) {
  console.log('Optimization was skipped because leaves are already optimal')
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
if isinstance(optimization_event, OptimizationEvent.STARTED):
    logging.debug(f"Optimization started with {optimization_event.total_rounds} rounds")
elif isinstance(optimization_event, OptimizationEvent.ROUND_COMPLETED):
    logging.debug(f"Optimization round {optimization_event.current_round} of "
        f"{optimization_event.total_rounds} completed")
elif isinstance(optimization_event, OptimizationEvent.COMPLETED):
    logging.debug("Optimization completed successfully")
elif isinstance(optimization_event, OptimizationEvent.CANCELLED):
    logging.debug("Optimization was cancelled")
elif isinstance(optimization_event, OptimizationEvent.FAILED):
    logging.debug(f"Optimization failed: {optimization_event.error}")
elif isinstance(optimization_event, OptimizationEvent.SKIPPED):
    logging.debug("Optimization was skipped because leaves are already optimal")
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
switch event := optimizationEvent.(type) {
case breez_sdk_spark.OptimizationEventStarted:
	log.Printf("Optimization started with %v rounds\n", event.TotalRounds)
case breez_sdk_spark.OptimizationEventRoundCompleted:
	log.Printf("Optimization round %v of %v completed\n", event.CurrentRound, event.TotalRounds)
case breez_sdk_spark.OptimizationEventCompleted:
	log.Printf("Optimization completed successfully\n")
case breez_sdk_spark.OptimizationEventCancelled:
	log.Printf("Optimization was cancelled\n")
case breez_sdk_spark.OptimizationEventFailed:
	log.Printf("Optimization failed: %v\n", event.Error)
case breez_sdk_spark.OptimizationEventSkipped:
	log.Printf("Optimization was skipped because leaves are already optimal\n")
}
```

</section>

</custom-tabs>


# Using an External Signer

The External Signer feature allows you to provide custom signing logic for the SDK rather than relying on the SDK's internal key management. This is useful when you want to:

- Keep keys in a secured environment
- Implement custom key derivation logic
- Integrate with existing wallet infrastructure

## Using the Default External Signer

The SDK provides a convenient factory function `default_external_signer` that creates a signer from a mnemonic. This is the easiest way to get started:

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
fn create_signer() -> Result<Arc<dyn ExternalSigner>, SdkError> {
    let mnemonic = "<mnemonic words>".to_string();
    let network = Network::Mainnet;

    let signer = default_external_signer(
        mnemonic,
        None, // passphrase
        network,
        Some(KeySetConfig {
            key_set_type: KeySetType::Default,
            use_address_index: false,
            account_number: Some(0),
        }),
    )?;

    Ok(signer)
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
func createSigner() throws -> ExternalSigner {
    let mnemonic = "<mnemonic words>"
    let network = Network.mainnet

    let signer = try defaultExternalSigner(
        mnemonic: mnemonic,
        passphrase: nil,
        network: network,
        keySetConfig: KeySetConfig(
            keySetType: KeySetType.default,
            useAddressIndex: false,
            accountNumber: 0
        )
    )

    return signer
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
fun createSigner(): breez_sdk_spark.ExternalSigner {
    val mnemonic = "<mnemonic words>"
    val network = Network.MAINNET
    val keySetType = KeySetType.DEFAULT
    val useAddressIndex = false
    val accountNumber = 0U

    val keySetConfig = KeySetConfig(
        keySetType = keySetType,
        useAddressIndex = useAddressIndex,
        accountNumber = accountNumber
    )

    val signer = defaultExternalSigner(
        mnemonic = mnemonic,
        passphrase = null,
        network = network,
        keySetConfig = keySetConfig
    )

    return signer
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
public static ExternalSigner CreateSigner()
{
    var mnemonic = "<mnemonic words>";
    var network = Network.Mainnet;
    var keySetType = KeySetType.Default;
    var useAddressIndex = false;
    uint accountNumber = 0;

    var keySetConfig = new KeySetConfig(
        keySetType: keySetType,
        useAddressIndex: useAddressIndex,
        accountNumber: accountNumber
    );

    var signer = BreezSdkSparkMethods.DefaultExternalSigner(
        mnemonic: mnemonic,
        passphrase: null,
        network: network,
        keySetConfig: keySetConfig
    );

    return signer;
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const createSigner = () => {
  const mnemonic = '<mnemonic words>'
  const keySetConfig: KeySetConfig = {
    keySetType: 'default',
    useAddressIndex: false,
    accountNumber: 0
  }

  // Create the default signer from the SDK
  const signer = defaultExternalSigner(mnemonic, null, 'mainnet', keySetConfig)

  return signer
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const createSigner = () => {
  const mnemonic = '<mnemonic words>'
  const keySetConfig: KeySetConfig = {
    keySetType: KeySetType.Default,
    useAddressIndex: false,
    accountNumber: 0
  }

  // Create the default signer from the SDK
  const signer = defaultExternalSigner(mnemonic, undefined, Network.Mainnet, keySetConfig)

  return signer
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
def create_signer() -> ExternalSigner:
    mnemonic = "<mnemonic words>"
    network = Network.MAINNET
    key_set_type = KeySetType.DEFAULT
    use_address_index = False
    account_number = 0

    key_set_config = KeySetConfig(
        key_set_type=key_set_type,
        use_address_index=use_address_index,
        account_number=account_number,
    )

    signer = default_external_signer(
        mnemonic=mnemonic,
        passphrase=None,
        network=network,
        key_set_config=key_set_config,
    )

    return signer
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
func createSigner() (breez_sdk_spark.ExternalSigner, error) {
	mnemonic := "<mnemonic words>"
	network := breez_sdk_spark.NetworkMainnet
	keySetType := breez_sdk_spark.KeySetTypeDefault
	useAddressIndex := false
	var accountNumber uint32 = 0

	keySetConfig := breez_sdk_spark.KeySetConfig{
		KeySetType:      keySetType,
		UseAddressIndex: useAddressIndex,
		AccountNumber:   &accountNumber,
	}

	signer, err := breez_sdk_spark.DefaultExternalSigner(
		mnemonic,
		nil, // passphrase
		network,
		&keySetConfig,
	)
	if err != nil {
		return nil, err
	}

	return signer, nil
}
```

</section>

</custom-tabs>


Once you have a signer, you can use it when connecting to the SDK with the `connect_with_signer` method instead of the regular `connect` method:

<custom-tabs category="lang">
<div slot="title">Rust</div>
<section>

```rust,ignore
async fn connect_example(signer: Arc<dyn ExternalSigner>) -> Result<BreezSdk, SdkError> {
    // Create the config
    let mut config = default_config(Network::Mainnet);
    config.api_key = Some("<breez api key>".to_string());

    // Connect using the external signer
    let sdk = connect_with_signer(ConnectWithSignerRequest {
        config,
        signer,
        storage_dir: "./.data".to_string(),
    })
    .await?;

    Ok(sdk)
}
```

</section>

<div slot="title">Swift</div>
<section>

```swift,ignore
func connectExample(signer: ExternalSigner) async throws -> BreezSdk {
    // Create the config
    var config = defaultConfig(network: .mainnet)
    config.apiKey = "<breez api key>"

    // Connect using the external signer
    let sdk = try await BreezSdkSpark.connectWithSigner(request: ConnectWithSignerRequest(
        config: config,
        signer: signer,
        storageDir: "./.data"
    ))

    return sdk
}
```

</section>

<div slot="title">Kotlin</div>
<section>

```kotlin,ignore
suspend fun connectWithSigner(signer: breez_sdk_spark.ExternalSigner) {
    // Create the config
    val config = defaultConfig(Network.MAINNET)
    config.apiKey = "<breez api key>"

    try {
        // Connect using the external signer
        val sdk = connectWithSigner(ConnectWithSignerRequest(
            config = config,
            signer = signer,
            storageDir = "./.data"
        ))
    } catch (e: Exception) {
        // handle error
    }
}
```

</section>

<div slot="title">C#</div>
<section>

```csharp,ignore
public static async Task<BreezSdk> ConnectWithSigner(ExternalSigner signer)
{
    // Create the config
    var config = BreezSdkSparkMethods.DefaultConfig(Network.Mainnet) with
    {
        apiKey = "<breez api key>"
    };

    // Connect using the external signer
    var sdk = await BreezSdkSparkMethods.ConnectWithSigner(new ConnectWithSignerRequest(
        config: config,
        signer: signer,
        storageDir: "./.data"
    ));

    return sdk;
}
```

</section>

<div slot="title">Javascript</div>
<section>

```typescript,ignore
const exampleConnectWithSigner = async (signer: ReturnType<typeof defaultExternalSigner>) => {
  // Create the config
  const config = defaultConfig('mainnet')
  config.apiKey = '<breez api key>'

  // Connect using the external signer
  const sdk = await connectWithSigner(
    config,
    signer,
    'breez_spark_db' // For WASM, this is the IndexedDB database name
  )
}
```

</section>

<div slot="title">React Native</div>
<section>

```typescript,ignore
const exampleConnectWithSigner = async (signer: ReturnType<typeof defaultExternalSigner>) => {
  // Create the config
  const config = defaultConfig(Network.Mainnet)
  config.apiKey = '<breez api key>'

  // Connect using the external signer
  const sdk = await connectWithSigner({
    config,
    signer,
    storageDir: `${RNFS.DocumentDirectoryPath}/data`
  })
}
```

</section>

<div slot="title">Python</div>
<section>

```python,ignore
async def example_connect_with_signer(signer: ExternalSigner) -> BreezSdk:
    # Create the config
    config = default_config(Network.MAINNET)
    config.api_key = "<breez api key>"

    # Connect using the external signer
    sdk = await connect_with_signer(ConnectWithSignerRequest(
        config=config,
        signer=signer,
        storage_dir="./.data"
    ))

    return sdk
```

</section>

<div slot="title">Go</div>
<section>

```go,ignore
func connectWithSigner(signer breez_sdk_spark.ExternalSigner) (*breez_sdk_spark.BreezSdk, error) {
	// Create the config
	config := breez_sdk_spark.DefaultConfig(breez_sdk_spark.NetworkMainnet)
	apiKey := "<breez api key>"
	config.ApiKey = &apiKey

	// Connect using the external signer
	sdk, err := breez_sdk_spark.ConnectWithSigner(breez_sdk_spark.ConnectWithSignerRequest{
		Config:     config,
		Signer:     signer,
		StorageDir: "./.data",
	})
	if err != nil {
		return nil, err
	}

	return sdk, nil
}
```

</section>

</custom-tabs>


<div class="warning">
<h4>Developer note</h4>
When using an external signer, you don't provide a seed directly to the SDK. Instead, the signer handles all cryptographic operations internally.
</div>

## Implementing a Custom Signer

If you need full control over the signing process, you can implement the [ExternalSigner](https://github.com/breez/spark-sdk/blob/main/crates/breez-sdk/core/src/signer/external.rs) interface in your application. This interface defines all the cryptographic operations the SDK needs.

The [DefaultSigner](https://github.com/breez/spark-sdk/blob/main/crates/spark/src/signer/default_signer.rs) implementation can be used as a reference for what's expected.

<div class="warning">
<h4>Developer note</h4>

Implementing a custom signer requires deep understanding of Bitcoin cryptography. The default signer implementation provides a solid reference for what's expected.

Most applications should use the default external signer factory function rather than implementing their own.
</div>

<div class="warning">
<h4>Flutter Limitation</h4>

External signers are not supported in Flutter due to limitations with passing trait objects through the flutter_rust_bridge FFI. Flutter applications should use the standard `connect` method with mnemonic-based key management.
</div>

# Moving to production

## Production checklist

Before moving to production, we strongly recommend verifying that these use cases are correctly implemented. Here is a checklist you can use to ensure that your application is production ready.

- **Add logging**: Add sufficient logging into your application to diagnose any issues users are having. Include log entries from the Breez SDK up to and including **DEBUG** level. For more information see [Adding logging](logging.md).
  > ⚠️ Proper logging is a prerequisite for troubleshooting. If logging is not implemented (or is implemented incorrectly), the Breez team will not be able to assist in diagnosing or resolving reported issues.

- **Display pending payments**: Payments always contain a status field that can be used to determine whether the payment was completed or not. Make sure you handle the case where the payment is still pending by showing the correct status to the user.

- **Claiming on-chain deposits**: Make sure you handle the case where an on-chain deposit is unclaimed. For more information see [Claiming on-chain deposits](onchain_claims.md).

# UX Guidelines

These guidelines describe how to integrate the Breez SDK to create a consistent UI/UX that feels natural for end users. They are based on [Misty Breez](https://breez.technology/misty/) patterns and are recommendations you can adapt to your specific use cases.

> **Reference:** Many of these guidelines are implemented in **Misty Breez**. Use it as the primary UX reference during SDK implementation.

## Core UX principles

- **Simplicity over choice**: users should not have to pick protocols or rails unless absolutely necessary.
- **Transparency without jargon**: show limits, fees, and conditions up front in plain language.
- **Progressive disclosure**: keep advanced details available but tucked away by default.

## Guidelines

- **[Receiving payments]**
- **[Sending payments]**
- **[Displaying payments]**
- **[Seed & key management]**

[Receiving payments]: uxguide_receive.md
[Sending payments]: uxguide_send.md
[Displaying payments]: uxguide_display.md
[Seed & key management]: uxguide_seed.md

## Receiving payments

### UX principles

- Receiving should feel like **sharing an identifier** (akin to an email), not a multi-step process.
- **Lightning first**: other rails are fallbacks, not choices users must make.

### Guidelines

1. **Lightning should be the primary means of receiving payments.** Lightning is the common language of Bitcoin. **On-chain Bitcoin is secondary** and used as an additional way to on-ramp **only if needed**.
2. **Don’t expose underlying implementation addresses** (i.e. Spark) to end users unless absolutely necessary. More options → more confusion. Moreover, until Spark supports dynamic addresses, exposing a Spark address involves privacy trade-offs.
3. **Display an LNURL-Pay QR code** by default (widest supported reusable method).  
   Provide **fallback to BOLT11** for one-off payment requests, typically with a specified amount.
4. **Provide a human-readable Lightning address.** Start with a **random** address that the user can **customize later**.
5. **Expose two primary actions**:
   - **Copy** → copies the Lightning address
   - **Share** → shares the LNURL-Pay string  
     (Matches patterns of popular Lightning wallets and maximizes compatibility.)
6. **If BOLT12 can be supported (currently only on the Liquid implementation)**, use the **same Lightning address** and **enhance it with BIP-353** so the address can retrieve both **LNURL-Pay** (BOLT11 under the hood) **and a BOLT12 offer**.
7. **If there are limits or fees, display them.** Make constraints visible before users attempt payment.
8. Interact with the SDK events according to these [UX recommendations](/guide/receive_payment.md#lightning-1).

## Sending payments

### UX principles

- Provide a **unified entry point** that “just works” regardless of the pasted/scanned data.
- Users shouldn’t need to recognize standards (BOLT11 vs. LNURL vs. address).

### Guidelines

1. **Consolidate all sending methods in the same UI** (BOLT11, Lightning address, BTC address, LNURL, etc.).
2. Add **On-chain Bitcoin** to the above UI as an additional way to off-ramp **only if needed**.
3. Support **Paste**, **Scan** (external QR), and **Upload** (scan from photos/screenshots).
4. **Contacts:** Allow users to **save Lightning addresses** in a manageable **Contacts** list to improve the send experience (not yet implemented in Misty Breez, but recommended).
5. Provide **Use all funds** when paying to a Lightning or Bitcoin address.
6. **Validate and display amount limits and fees** before confirmation.
7. Interact with the SDK events according to these [UX recommendations](/guide/send_payment.md#lightning-2).

## Displaying payments

### UX principles

- History should be **clear, transparent, and verifiable**.
- Offer both **simple summaries** and **deeper technical details**.

### Guidelines

1. **Display fees separately** from the amount.
2. **Prefer the Lightning address** over the invoice description in titles for readability.
3. **Show associated metadata** — at minimum the **invoice** and **preimage**.  
   Keep under an expandable **Details** section to avoid clutter by default.
4. **Represent states:** **Pending**, **Succeeded**, **Failed** (with distinct visuals).

## Seed & key management

### UX principles

- Onboarding should be **seamless**; don’t block first use with seed backup.
- Encourage security without forcing it prematurely.

### Guidelines

1. **Allow seed backup after wallet creation** or **after the first received payment** to keep onboarding smooth.
2. **Explain** the need to **write down and save** the seed phrase.
3. **Consider validation** (e.g., partial re-entry) to confirm backup.
4. **Enhance key-management UX where possible:** encrypted cloud backup, or **Web 2 / identity–based** approaches that preserve self-custody.

